// Возвращает головную организацию для заданной организации
// Если для организации реквизит ГоловнаяОрганизация не заполнен 
// это значит, что сама организация является голвной
//
// Параметры
//  Организация – СправочникСсылка.Организации
//                 <продолжение описания параметра>
//
// Возвращаемое значение:
//   СправочникСсылка.Организации
//
Функция ГоловнаяОрганизация(Организация) Экспорт

	Если Организация.Пустая() ИЛИ Организация.ГоловнаяОрганизация.Пустая() Тогда
		Возврат Организация;

	Иначе
		Возврат Организация.ГоловнаяОрганизация;

	КонецЕсли;

КонецФункции // ГоловнаяОрганизация()

// Функция проверяет наличие в строке только цифр
//
// Параметры
//  СтрокаПроверки - Строка для проверки только цифр
//
// Возвращаемое значение:
//   Булево
//
Функция ТолькоЦифрыВСтроке(Знач СтрокаПроверки, УчитыватьЛидирующиеНули = Истина, УчитыватьПробелы = Истина) Экспорт
	
	Если ТипЗнч(СтрокаПроверки) <> Тип("Строка") Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если ЗначениеНеЗаполнено(СтрокаПроверки) Тогда
		Возврат Истина;
	КонецЕсли; 
	
	Если НЕ УчитыватьПробелы Тогда
		СтрокаПроверки = СтрЗаменить(СтрокаПроверки, " ", "");
	КонецЕсли;
	
	Если НЕ УчитыватьЛидирующиеНули Тогда
		НомерПервойЦифры = 0;
		Для а = 1 По СтрДлина(СтрокаПроверки) Цикл
			НомерПервойЦифры = НомерПервойЦифры + 1;
			КодСимвола = КодСимвола(Сред(СтрокаПроверки, а, 1));
			Если КодСимвола <> 48 Тогда
				Прервать;
			КонецЕсли;
		КонецЦикла;
		СтрокаПроверки = Сред(СтрокаПроверки, НомерПервойЦифры);
	КонецЕсли;
	
	Для а = 1 По СтрДлина(СтрокаПроверки) Цикл
		КодСимвола = КодСимвола(Сред(СтрокаПроверки, а, 1));
		Если НЕ (КодСимвола >= 48 И КодСимвола <= 57) Тогда
			Возврат Ложь;
		КонецЕсли; 
	КонецЦикла; 

	Возврат Истина;
	
КонецФункции

Функция ПолучитьРабочуюДату() Экспорт
	
	#Если Клиент Тогда
		Дата = РабочаяДата;
	#Иначе
		Дата = ТекущаяДата();
	#КонецЕсли
	
	Возврат Дата;
	
КонецФункции // ПолучитьРабочуюДату()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ВАЛЮТАМИ

// Эта функция пересчитывает сумму из валюты ВалютаНач по курсу ПоКурсуНач 
// в валюту ВалютаКон по курсу ПоКурсуКон
//
// Параметры:      
//	Сумма          - сумма, которую следует пересчитать;
//	ВалютаНач      - ссылка на элемент справочника Валют;
//                   определяет валюты из которой надо пересчитвать;
//	ВалютаКон      - ссылка на элемент справочника Валют;
//                   определяет валюты в которую надо пересчитвать;
// 	ПоКурсуНач     - курс из которого надо пересчитать;
// 	ПоКурсуКон     - курс в который надо пересчитать;
// 	ПоКратностьНач - кратность из которого надо пересчитать (по умолчанию = 1);
// 	ПоКратностьКон - кратность в который надо пересчитать  (по умолчанию = 1);
//
// Возвращаемое значение: 
//  Сумма, пересчитанная в другую валюту
//
Функция ПересчитатьИзВалютыВВалюту(Сумма, ВалютаНач, ВалютаКон, ПоКурсуНач, ПоКурсуКон, 
	                               ПоКратностьНач = 1, ПоКратностьКон = 1 ) Экспорт

	Если (ВалютаНач = ВалютаКон) Тогда

		// Считаем, что пересчет не нужен.
		Возврат Сумма;

	КонецЕсли;

	Если (ПоКурсуНач     = ПоКурсуКон) 
	   и (ПоКратностьНач = ПоКратностьКон) Тогда

		// ну, тут и считать нечего...
		Возврат Сумма;

	КонецЕсли;

	Если ПоКурсуНач     = 0 
	 или ПоКурсуКон     = 0 
	 или ПоКратностьНач = 0 
	 или ПоКратностьКон = 0 Тогда
		СообщитьОбОшибке("Процедура ""ПересчитатьИзВалютыВВалюту()"": при пересчете обнаружен нулевой курс.");
		Возврат 0;

	КонецЕсли;

	Возврат Окр((Сумма * ПоКурсуНач * ПоКратностьКон) / (ПоКурсуКон * ПоКратностьНач), 2);

КонецФункции //ПересчитатьИзВалютыВВалюту()

// Возвращает курс валюты на дату
//
// Параметры:
//  Валюта     - Валюта (элемент справочника "Валюты")
//  ДатаКурса  - Дата, на которую следует получить курс
//
// Возвращаемое значение: 
//  Структура, содержащая:
//   Курс      - курс валюты
//   Кратность - кратность валюты
//
Функция ПолучитьКурсВалюты(Валюта, ДатаКурса) Экспорт

	СтруктураКурса = РегистрыСведений.КурсыВалют.ПолучитьПоследнее(ДатаКурса, Новый Структура("Валюта", Валюта));
	
	Если СтруктураКурса.Кратность=0 Тогда
		СтруктураКурса.Кратность=1;
	КонецЕсли;	

	Возврат СтруктураКурса;
	
КонецФункции // ПолучитьКурсВалюты()

// Определяет курс документа, который равен либо курсу документа (если в документе он существует),
// либо курсу взаиморасчетов, либо 1.
//
// Параметры: 
//  ДокументОбъект                 - объект документа, курс которого надо получить
//  ВалютаРегламентированногоУчета - валюта регламентированного учета
//
// Возвращаемое значение:
//  Число - курс документа.
//
Функция КурсДокумента(ДокументОбъект, ВалютаРегламентированногоУчета) Экспорт

	МетаданныеДокумента = ДокументОбъект.Метаданные();
	
	Если ЕстьРеквизитДокумента("ВалютаДокумента", МетаданныеДокумента) Тогда
		// Если валюта документа совпадает с валютой регл. учета, то курс 1.
		Если ДокументОбъект.ВалютаДокумента <> ВалютаРегламентированногоУчета Тогда
			
			МетаданныеДокумента = ДокументОбъект.Метаданные();
			
			// Если есть реквизит КурсДокумента - его и вернем
			Если ЕстьРеквизитДокумента("КурсДокумента", МетаданныеДокумента) Тогда
				Возврат ДокументОбъект.КурсДокумента;
			КонецЕсли;
			
			// Если нет КурсДокумента и валюта документа не совпадает с валютой регл. учета, 
			// то такой документ может быть выписан только в валюте взаиморасчетов,
			// если есть реквизит КурсВзаиморасчетов - его и вернем.
			Если ЕстьРеквизитДокумента("КурсВзаиморасчетов", МетаданныеДокумента) Тогда
				Возврат ДокументОбъект.КурсВзаиморасчетов;
			КонецЕсли;
			
			// Если нет КурсВзаиморасчетов и валюта документа не совпадает с валютой регл. учета, 
			// то КурсВзаиморасчетов долежн быть в табличной части документа или может вообще отсутсвовать.
			// Тогда возьмем курс из справочника на дату документа.
			Возврат ПолучитьКурсВалюты(ДокументОбъект.ВалютаДокумента,ДокументОбъект.Дата).Курс;
			
		КонецЕсли;
	КонецЕсли;

	Возврат 1;

КонецФункции // КурсДокумента()

// Определяет кратность документа, которая равен либо кратности документа (если в документе она существует),
// либо кратности взаиморасчетов, либо 1.
//
// Параметры: 
//  ДокументОбъект - объект документа, курс которого надо получить
//  ВалютаРегламентированногоУчета - валюта регламентированного учета
//
// Возвращаемое значение:
//  Число - кратность валюты в документе.
//
Функция КратностьДокумента(ДокументОбъект, ВалютаРегламентированногоУчета) Экспорт

	МетаданныеДокумента = ДокументОбъект.Метаданные();
	
	Если ЕстьРеквизитДокумента("ВалютаДокумента", МетаданныеДокумента) Тогда
		// Если валюта документа совпадает с валютой регл. учета, то кратность 1.
		Если ДокументОбъект.ВалютаДокумента <> ВалютаРегламентированногоУчета Тогда
			
			// Если есть реквизит КратностьДокумента - его и вернем
			Если ЕстьРеквизитДокумента("КратностьДокумента", МетаданныеДокумента) Тогда
				Возврат ДокументОбъект.КратностьДокумента;
			КонецЕсли;
			
			// Если нет КратностьДокумента и валюта документа не совпадает с валютой регл. учета, 
			// то такой документ может быть выписан только в валюте взаиморасчетов,
			// если есть реквизит КратностьВзаиморасчетов - его и вернем.
			Если ЕстьРеквизитДокумента("КратностьВзаиморасчетов", МетаданныеДокумента) Тогда
				Возврат ДокументОбъект.КратностьВзаиморасчетов;
			КонецЕсли;
			
			// Если нет КратностьВзаиморасчетов и валюта документа не совпадает с валютой регл. учета, 
			// то КратностьВзаиморасчетов должна быть в табличной части документа или может вообще отсутсвовать.
			//Тогда возьмем Кратность из справочника на дату документа.
			Возврат ПолучитьКурсВалюты(ДокументОбъект.ВалютаДокумента,ДокументОбъект.Дата).Кратность;
			
		КонецЕсли;
    КонецЕсли;
	
	Возврат 1;

КонецФункции // КратностьДокумента()

// Проверяет наличие установленного курс аи кратности валюты на 1 января 1980 года.
// В случае отсутствия устанавливает курс и кратность равными единице.
//
// Параметры:
//  Валюта - ссылка на элемент справочника Валют
//
Процедура ПроверитьКорректностьКурсаНа01_01_1980(Валюта) Экспорт

	ДатаКурса = Дата(1980, 1, 1);
	СтруктураКурса = ПолучитьКурсВалюты(Валюта, ДатаКурса);

	Если (СтруктураКурса.Курс = 0) Или (СтруктураКурса.Кратность = 0) Тогда

		// установим курс и кратность = 1 на 01.01.1980, чтобы не было ошибок при создании документов

		РегистрКурсыВалют = РегистрыСведений.КурсыВалют.СоздатьМенеджерЗаписи();

		РегистрКурсыВалют.Период    = ДатаКурса;
		РегистрКурсыВалют.Валюта    = Валюта;
		РегистрКурсыВалют.Курс      = 1;
		РегистрКурсыВалют.Кратность = 1;
		РегистрКурсыВалют.Записать();

	КонецЕсли;

КонецПроцедуры // ПроверитьКорректностьКурсаНа01_01_1980()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ЗАПИСИ НАБОРА КОНСТАНТ

// Записывает набор констант, сравнивая его с эталонным набором
// Записываются только те константы, которые были изменены относительно эталонного набора
//
// Параметры: 
//  НаборКонстант  - Набор констант
//  ЭталонныйНабор - Эталонный набор констант
//  Модифицированность - Устанавливается в истину, если операция выполнена успешно
//
// Возвращаемое значение:
//  Истина - операция выполнена, ложь - иначе.
//
Функция ЗаписатьНаборКонстант(НаборКонстант, ЭталонныйНабор, Модифицированность = Истина) Экспорт
	
	ЗаписываемыеКонстанты = "";
	Для каждого Константа Из Метаданные.Константы Цикл
		
		ИмяКонстанты = Константа.Имя;
		
		ЗначениеНабора    = ЗначениеВСтрокуВнутр(НаборКонстант[ИмяКонстанты]);
		ЭталонноеЗначение = ЗначениеВСтрокуВнутр(ЭталонныйНабор[ИмяКонстанты]);
		
		Если Не ЗначениеНабора = ЭталонноеЗначение Тогда
			
			ТекущееЗначение   = ЗначениеВСтрокуВнутр(Константы[ИмяКонстанты].Получить());
			
			Если Не ЗначениеНабора = ТекущееЗначение Тогда
				ЗаписываемыеКонстанты = ЗаписываемыеКонстанты + ?(ПустаяСтрока(ЗаписываемыеКонстанты), "", ", ") + ИмяКонстанты;
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Если Не ПустаяСтрока(ЗаписываемыеКонстанты) Тогда
		
		ЗаписываемыйНабор = Константы.СоздатьНабор(ЗаписываемыеКонстанты);
		ЗаполнитьЗначенияСвойств(ЗаписываемыйНабор, НаборКонстант, ЗаписываемыеКонстанты);
		
		Попытка
			ЗаписываемыйНабор.Записать();
		Исключение
			СообщитьОбОшибке(ОписаниеОшибки());
			Возврат Ложь;
		КонецПопытки;
		
		НаборКонстант.Прочитать();
		ЗаполнитьЗначенияСвойств(ЭталонныйНабор, НаборКонстант);
		
	КонецЕсли; 
	
	Модифицированность = Ложь;
	Возврат Истина;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ПРОВЕРКИ НАЛИЧИЯ И ЗАПОЛНЕНИЯ РЕВИЗИТОВ

// Определяет заполнено ли переданное значение
//
// Параметры: 
//  Значение - значение, заполенение которого надо проверить
//
// Возвращаемое значение:
//  Истина - значение не заполнено, ложь - иначе.
//
Функция ЗначениеНеЗаполнено(Значение) Экспорт

	Результат   = Ложь;
	ТипЗначения = ТипЗнч(Значение);

	// Сначала примитивные типы
	Если Значение = Неопределено Тогда
		Результат = Истина;

	ИначеЕсли Значение = NULL Тогда
		Результат = Истина;

	ИначеЕсли ТипЗначения = Тип("Строка") Тогда
		Если СокрЛП(Значение) = "" Тогда
			Результат = Истина;
		КонецЕсли;

	ИначеЕсли ТипЗначения = Тип("Число") Тогда
		Если Значение = 0 Тогда
			Результат = Истина;
		КонецЕсли;

	ИначеЕсли ТипЗначения = Тип("Дата") Тогда
		Если Значение = Дата('00010101') Тогда
			Результат = Истина;
		КонецЕсли;

	ИначеЕсли ТипЗначения = Тип("Булево") Тогда
		Результат = Ложь; // Булево будем считать не пустым

		//Отдельное определение, так как конструкторов данного типа не существует	
	ИначеЕсли ТипЗначения = Тип("РежимПроведенияДокумента") Тогда

		Если Значение = РежимПроведенияДокумента.Неоперативный или Значение = РежимПроведенияДокумента.Оперативный тогда
			Результат = Ложь;
		КонецЕсли;

		// Для остальных будем считать значение пустым, если оно равно
		// дефолтному значению своего типа

	Иначе

		Если Значение = Новый(ТипЗначения) Тогда
			Результат = Истина;
		КонецЕсли;

	КонецЕсли;

	Возврат Результат;

КонецФункции // ЗначениеНеЗаполнено()

// Позволяет определить есть ли среди реквизитов шапки документа
// реквизит с переданным именем.
//
// Параметры: 
//  ИмяРеквизита - строковое имя искомого реквизита, 
//  МетаданныеДокумента - объект описания метаданных документа, среди реквизитов которого производится поиск.
//
// Возвращаемое значение:
//  Истина - нашли реквизит с таким именем, Ложь - не нашли.
//
Функция ЕстьРеквизитДокумента(ИмяРеквизита, МетаданныеДокумента) Экспорт

	Возврат НЕ (МетаданныеДокумента.Реквизиты.Найти(ИмяРеквизита) = Неопределено);

КонецФункции // ЕстьРеквизитДокумента()

// Позволяет определить есть ли табличная часть документа с переданным именем.
//
// Параметры: 
//  ИмяТабЧасти - строковое имя искомой табличной части,
//  МетаданныеДокумента - объект описания метаданных документа, среди реквизитов которого производится поиск.
//
// Возвращаемое значение:
//  Истина - нашли реквизит с таким именем, Ложь - не нашли.
//
Функция ЕстьТабЧастьДокумента(ИмяТабЧасти, МетаданныеДокумента) Экспорт

	Если МетаданныеДокумента.ТабличныеЧасти.Найти(ИмяТабЧасти) = Неопределено Тогда
		Возврат Ложь;
	Иначе
		Возврат Истина;
	КонецЕсли; 

КонецФункции // ЕстьТабЧастьДокумента()

// Позволяет определить есть ли среди реквизитов табличной части документа
// реквизит с переданным именем.
//
// Параметры: 
//  ИмяРеквизита - строковое имя искомого реквизита, 
//  МетаданныеДокумента - объект описания метаданных документа, среди реквизитов которого производится поиск.
//  ИмяТабЧасти  - строковое имя табличной части документа, среди реквизитов которого производится поиск
//
// Возвращаемое значение:
//  Истина - нашли реквизит с таким именем, Ложь - не нашли.
//
Функция ЕстьРеквизитТабЧастиДокумента(ИмяРеквизита, МетаданныеДокумента, ИмяТабЧасти) Экспорт

	ТабЧасть = МетаданныеДокумента.ТабличныеЧасти.Найти(ИмяТабЧасти);

	Если ТабЧасть = Неопределено Тогда // Нет такой таб. части в документе
		Возврат Ложь;

	Иначе
		Возврат НЕ (ТабЧасть.Реквизиты.Найти(ИмяРеквизита) = Неопределено);

	КонецЕсли;

КонецФункции // ЕстьРеквизитТабЧастиДокумента()

// Функция проверяет наличие в строке только цифр
//
// Параметры
//  СтрокаПроверки - Строка для проверки только цифр
//
// Возвращаемое значение:
//   Булево
//
Функция ЕстьНеЦифры(Знач СтрокаПроверки) Экспорт

	СписокКодовЧисел = Новый СписокЗначений;
	Для а = 48 По 57 Цикл
		СписокКодовЧисел.Добавить(а);
	КонецЦикла; 
	
	СтрокаПроверки = СокрЛП(СтрокаПроверки);
	
	Если ТипЗнч(СтрокаПроверки) <> Тип("Строка") Тогда
		
		Возврат Истина;
		
	Иначе
		
		Для а = 1 По СтрДлина(СтрокаПроверки) Цикл
			Если СписокКодовЧисел.НайтиПоЗначению(КодСимвола(Сред(СтрокаПроверки, а, 1))) = Неопределено Тогда
				Возврат Истина;
			КонецЕсли; 
		КонецЦикла; 
		
	КонецЕсли; 

	Возврат Ложь;
	
КонецФункции

// Процедура устанавливает новое значение для переданного реквизита.
// Если новое значение совпадает со старым, то флаг модифицированности не взводится.
//
// Параметры
//  Реквизит  – Произвольный – Реквизит, для которого надо установить новое значение
//  Значение  – Произвольный – Новое значение для реквизита
//
Процедура УстановитьЗначение(Реквизит, Значение) Экспорт

	Если Реквизит <> Значение Тогда
		Реквизит = Значение;
	КонецЕсли;

КонецПроцедуры // УстановитьЗначение(Реквизит, Значение)

// Процедура устанавливает номер документа.
//
// Параметры:
//  ДокументОбъект  - ДокументОбъект. Экземпляр документа, которому 
//                    необходимо присвоить новый номер
//
Процедура УстановитьНомерДокумента(ДокументОбъект) Экспорт

	// Если  нет реквизита "Организация" или для нее не задан префикс, то 
	// используем пустой префикс,
	// иначе используем префикс организации.
	МетаданныеДокумента = ДокументОбъект.Метаданные();

	Если Не ЕстьРеквизитДокумента("Организация", МетаданныеДокумента)
	 Или ЗначениеНеЗаполнено(ДокументОбъект.Организация.Префикс) Тогда

		ДокументОбъект.УстановитьНовыйНомер("00");

	Иначе

		ДокументОбъект.УстановитьНовыйНомер(ДокументОбъект.Организация.Префикс);
        		
	КонецЕсли;
	
	//Если ЕстьРеквизитДокумента("НДСВключенВСтоимость", МетаданныеДокумента) И
	//	ЕстьРеквизитДокумента("Организация", МетаданныеДокумента) Тогда
	//	Если ПрименениеУСН(ДокументОбъект.Организация, ДокументОбъект.Дата) Тогда
	//		ДокументОбъект.НДСВключенВСтоимость = Истина;
	//	КонецЕсли;
	//КонецЕсли;


КонецПроцедуры // УстановитьНомерДокумента()


////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С МЕХАНИЗМОМ ОТПРАВКИ СООБЩЕНИЙ В ОТДЕЛ ТЕХНИЧЕСКОЙ ПОДДЕРЖКИ ПОЛЬЗОВАТЕЛЕЙ

// Функнция проверяет заполнения обязательных параметров для отправки сообщения
//  в отдел технической поддержки.
//
// Параметры
//  ТаблицаДанных - Таблица значений
//
// Возвращаемое значение:
//   Булево - результат корректости проверки
//
Функция ПроверитьСтруктуруЗаполненияПараметровДляОтправкиСообщенияВОтделТехническойПоддержки(ТаблицаДанных, ПубликоватьСообщения = Истина) Экспорт

	ЗначениеПроверки = Истина;
	СтрокаЗаголовкаОшибки = "Не заполнены настройки для отправки сообщения.";
	
	СписокИменОбязательныхРеквизитов = Новый СписокЗначений;
	СписокИменОбязательныхРеквизитов.Добавить("ПараметрыОтправкиЭлектронногоСообщения_АдресЭлектроннойПочтыОтделаТехническойПоддержки");
	СписокИменОбязательныхРеквизитов.Добавить("ПараметрыОтправкиЭлектронногоСообщения_АдресЭлектроннойПочтыОтправителя");
	СписокИменОбязательныхРеквизитов.Добавить("ПараметрыОтправкиЭлектронногоСообщения_АдресCервераSMTP");
	СписокИменОбязательныхРеквизитов.Добавить("ПараметрыОтправкиЭлектронногоСообщения_ПортSMTP");
	СписокИменОбязательныхРеквизитов.Добавить("ОсновныеДанные_РегистрационныйНомерПрограммы");
	СписокИменОбязательныхРеквизитов.Добавить("Владелец_Организация");
	
	Для каждого СтрокаРаздела Из ТаблицаДанных Цикл
		Для каждого ЭлементЗначения Из СтрокаРаздела.ДанныеРаздела Цикл
			Если СписокИменОбязательныхРеквизитов.НайтиПоЗначению(ЭлементЗначения.Ключ) <> Неопределено И ЗначениеНеЗаполнено(ЭлементЗначения.Значение[1]) Тогда
				Если ПубликоватьСообщения Тогда
					СообщитьОбОшибке("Не указан """ + Лев(ЭлементЗначения.Значение[0], (СтрДлина(ЭлементЗначения.Значение[0]) - 1)) + """.",, СтрокаЗаголовкаОшибки);
				КонецЕсли; 
				ЗначениеПроверки = Ложь;
			КонецЕсли; 
		КонецЦикла; 
	КонецЦикла;
	
	Возврат ЗначениеПроверки;

КонецФункции // ПроверитьСтруктуруЗаполненияПараметровДляОтправкиСообщенияВОтделТехническойПоддержки()

// Процедура формирует таблицу значений со структурой для заполнения данными
// с информацией обращения в отдел технической поддержки
//
// Параметры:
//  ТаблицаДанных - таблица значений для заполнения
//  ФормаНастройкиПараметров - общая форма настройки параметров для отправки в отдел технической поддержки
//
Процедура ЗаполнитьСтруктуруДанныхНастройкиОбращенияВОтделТехподдержкиПоУмолчанию(ТаблицаДанных, ФормаНастройкиПараметров = Неопределено) Экспорт

	// Структура данных - таблица значений:
	//  Колонки:
	//   ИмяРездела
	//   ПредставлениеРаздела
	//   ДанныеРаздела
	
	// Структура данных раздела
	//  Ключ - Имя значения настройки, как оно задано в форме настройки параметров обращения
	//  Значение - Массив значений
	// 
	// Массив значений:
	//  [0] - Представление наименования параметра для печати
	//  [1] - Значение параметра

	Если ТипЗнч(ТаблицаДанных) <> Тип("ТаблицаЗначений") Тогда
		ТаблицаДанных = Новый ТаблицаЗначений;
	КонецЕсли;

	Если ТаблицаДанных.Колонки.Количество() = 0 Тогда

		ТаблицаДанных.Колонки.Добавить("ИндексСортировки"    , Новый ОписаниеТипов("Число"));
		ТаблицаДанных.Колонки.Добавить("ИмяРаздела"          , Новый ОписаниеТипов("Строка"));
		ТаблицаДанных.Колонки.Добавить("ПредставлениеРаздела", Новый ОписаниеТипов("Строка"));
		ТаблицаДанных.Колонки.Добавить("ДанныеРаздела"       , Новый ОписаниеТипов("Структура"));

		СтрокаРаздела = ТаблицаДанных.Добавить();
		СтрокаРаздела.ИмяРаздела = "ПараметрыОтправкиЭлектронногоСообщения";
		СтрокаРаздела.ПредставлениеРаздела = "Параметры отправки электронного сообщения";
		
		СтрокаРаздела = ТаблицаДанных.Добавить();
		СтрокаРаздела.ИмяРаздела = "ОсновныеДанные";
		СтрокаРаздела.ПредставлениеРаздела = "Основные данные по использованию 1С:Предприятие 8.0 и конфигурации";
		
		СтрокаРаздела = ТаблицаДанных.Добавить();
		СтрокаРаздела.ИмяРаздела = "Владелец";
		СтрокаРаздела.ПредставлениеРаздела = "Организация-пользователь";
		
		СтрокаРаздела = ТаблицаДанных.Добавить();
		СтрокаРаздела.ИмяРаздела = "РаспределенныеБД";
		СтрокаРаздела.ПредставлениеРаздела = "Распределенные информационные базы данных (ИБ)";
		
		СтрокаРаздела = ТаблицаДанных.Добавить();
		СтрокаРаздела.ИмяРаздела = "ФайлСервер";
		СтрокаРаздела.ПредставлениеРаздела = "Параметры компьютера (файл-сервер)";
		
		СтрокаРаздела = ТаблицаДанных.Добавить();
		СтрокаРаздела.ИмяРаздела = "SQLСервер";
		СтрокаРаздела.ПредставлениеРаздела = "Параметры компьютера (SQL-сервер)";
		
		СтрокаРаздела = ТаблицаДанных.Добавить();
		СтрокаРаздела.ИмяРаздела = "СерверПредприятия";
		СтрокаРаздела.ПредставлениеРаздела = "Параметры компьютера (сервер 1С:Предприятия)";
		
		СтрокаРаздела = ТаблицаДанных.Добавить();
		СтрокаРаздела.ИмяРаздела = "ТерминалСервер";
		СтрокаРаздела.ПредставлениеРаздела = "Параметры компьютера (терминал-сервер)";
		
		СтрокаРаздела = ТаблицаДанных.Добавить();
		СтрокаРаздела.ИмяРаздела = "WebРасширение";
		СтрокаРаздела.ПредставлениеРаздела = "Параметры компьютера (Web-расширение)";
		
		СтрокаРаздела = ТаблицаДанных.Добавить();
		СтрокаРаздела.ИмяРаздела = "Внедрение";
		СтрокаРаздела.ПредставлениеРаздела = "Сведения о внедрении";
		
	КонецЕсли;

	Если ФормаНастройкиПараметров = Неопределено Тогда
		ФормаНастройкиПараметров = ПолучитьОбщуюФорму("НастройкаПараметровОбращенияВОтделТехническойПоддержки");
	КонецЕсли;


	
	Для каждого ЭлементФормы Из ФормаНастройкиПараметров.ЭлементыФормы Цикл

		Если ТипЗнч(ЭлементФормы) <> Тип("ПолеВвода")
		   И ТипЗнч(ЭлементФормы) <> Тип("ПолеВыбора")
		   И ТипЗнч(ЭлементФормы) <> Тип("Флажок") Тогда
			Продолжить;
		КонецЕсли;

		ПозицияРазделителяРаздела = Найти(ЭлементФормы.Имя, "_");
		Если ПозицияРазделителяРаздела = 0 Тогда
			Продолжить;
		КонецЕсли;

		ИмяРаздела    = Сред(ЭлементФормы.Имя, 1, (ПозицияРазделителяРаздела - 1));
		СтрокаРаздела = ТаблицаДанных.Найти(ИмяРаздела, "ИмяРаздела");

		Если СтрокаРаздела = Неопределено Тогда

			СтрокаРаздела = ТаблицаДанных.Добавить();
			СтрокаРаздела.ИмяРаздела = ИмяРаздела;

			Попытка
				СтрокаРаздела.ПредставлениеРаздела = ФормаНастройкиПараметров.ЭлементыФормы.ОсновнаяПанель.Страницы[ИмяРаздела].Заголовок;
				СтрокаРаздела.ИндексСортировки     = ФормаНастройкиПараметров.ЭлементыФормы.ОсновнаяПанель.Страницы.Индекс(ФормаНастройкиПараметров.ЭлементыФормы.ОсновнаяПанель.Страницы[ИмяРаздела]);
			Исключение
				СтрокаРаздела.ПредставлениеРаздела = ИмяРаздела;
			КонецПопытки;

		КонецЕсли;

		МассивЗначений = Новый Массив;

		Попытка

			Если ТипЗнч(ЭлементФормы) = Тип("Флажок") Тогда
				МассивЗначений.Добавить((ЭлементФормы.Заголовок + ":"));
			Иначе
				МассивЗначений.Добавить(ФормаНастройкиПараметров.ЭлементыФормы["Надпись_" + ЭлементФормы.Имя].Заголовок);
			КонецЕсли;

		Исключение
			МассивЗначений.Добавить(ЭлементФормы.Имя);
		КонецПопытки;

		МассивЗначений.Добавить("");

		СтрокаРаздела.ДанныеРаздела.Вставить(ЭлементФормы.Имя, МассивЗначений);

	КонецЦикла;

	ТаблицаДанных.Сортировать("ИндексСортировки ВОЗР");

КонецПроцедуры

// Функция формирует текст сообщения на линию техподдержки
//
// Параметры
//  НЕТ
//
// Возвращаемое значение:
//   Текст сообщения
//
Функция ПолучитьТекстСообщенияВОтделТехническойПоддержки() Экспорт

	ТекстВозврата = "";
	
	ТекстВозврата = ТекстВозврата + Символы.ПС;
	ТекстВозврата = ТекстВозврата + Символы.ПС;
	ТекстВозврата = ТекстВозврата + Символы.ПС + "============ Сведения об использовании ПП 1С:Предприятие 8.0 ============";
	
	ТаблицаДанных = Константы.ПараметрыСообщенияПриОбращенииВОтделТехническойПоддержки.Получить().Получить();
	
	// Сформируем обязательный информационный раздел
	
	СистемИнфо = Новый СистемнаяИнформация;
	
	ТекстВозврата = ТекстВозврата + Символы.ПС;
	ТекстВозврата = ТекстВозврата + Символы.ПС + "1. ДАННЫЕ ТЕКУЩЕГО КОМПЬЮТЕРА И КОНФИГУРАЦИИ";
	ТекстВозврата = ТекстВозврата + Символы.ПС + "Версия 1С:Предприятия 8.0: " + СистемИнфо.ВерсияПриложения;
	ТекстВозврата = ТекстВозврата + Символы.ПС + "Конфигурация: "              + Метаданные.Синоним;
	ТекстВозврата = ТекстВозврата + Символы.ПС + "Версия конфигурации: "       + Метаданные.Версия;
	ТекстВозврата = ТекстВозврата + Символы.ПС + "Поставщик: "                 + Метаданные.Поставщик;
	ТекстВозврата = ТекстВозврата + Символы.ПС + "Операционная система: "      + СистемИнфо.ВерсияОС;
	ТекстВозврата = ТекстВозврата + Символы.ПС + "Оперативная память (МБ): "   + СистемИнфо.ОперативнаяПамять;
	ТекстВозврата = ТекстВозврата + Символы.ПС + "Процессор: "                 + СистемИнфо.Процессор;

	НомерСтрокиРаздела = 1;
	
	Если ТипЗнч(ТаблицаДанных) = Тип("ТаблицаЗначений") Тогда
		
		Для каждого СтрокаТаблицыРаздела Из ТаблицаДанных Цикл
			
			СтрокаРаздела = "";
			
			Если СтрокаТаблицыРаздела.ИмяРаздела = "ПараметрыОтправкиЭлектронногоСообщения" Тогда
				Продолжить;
			КонецЕсли;
			
			Для каждого ЭлементЗначения Из СтрокаТаблицыРаздела.ДанныеРаздела Цикл
				Если ЗначениеНеЗаполнено(ЭлементЗначения.Значение[1]) Тогда
					Продолжить;
				КонецЕсли; 
				СтрокаРаздела = СтрокаРаздела + Символы.ПС + ЭлементЗначения.Значение[0] + " " + ?(ТипЗнч(ЭлементЗначения.Значение[1]) = Тип("Булево"), ?(ЭлементЗначения.Значение[1], "Да", "Нет"), ЭлементЗначения.Значение[1]);
			КонецЦикла; 
			
			Если ЗначениеНеЗаполнено(СтрокаРаздела) Тогда
				Продолжить;
			КонецЕсли;
			
			НомерСтрокиРаздела = НомерСтрокиРаздела + 1;
			
			СтрокаРаздела = Строка(НомерСтрокиРаздела) + ". " + ВРег(СтрокаТаблицыРаздела.ПредставлениеРаздела) + СтрокаРаздела;
			
			ТекстВозврата = ТекстВозврата + Символы.ПС;
			ТекстВозврата = ТекстВозврата + Символы.ПС + СтрокаРаздела;
		
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат ТекстВозврата;

КонецФункции // ПолучитьТекстСообщенияВОтделТехническойПоддержки()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ТИПАМИ

// Служебная функция, предназначенная для получения описания типов строки, заданной длины.
// 
// Параметры:
//  ДлинаСтроки - число, длина строки.
//
// Возвращаемое значение:
//  Объект "ОписаниеТипов" для строки указанной длины.
//
Функция ПолучитьОписаниеТиповСтроки(ДлинаСтроки) Экспорт

	Массив = Новый Массив; 
	Массив.Добавить(Тип("Строка"));

	КвалификаторСтроки = Новый КвалификаторыСтроки(ДлинаСтроки, ДопустимаяДлина.Переменная);

	Возврат Новый ОписаниеТипов(Массив, , КвалификаторСтроки);

КонецФункции // ПолучитьОписаниеТиповСтроки()

// Служебная функция, предназначенная для получения описания типов числа, заданной разрядности.
// 
// Параметры:
//  Разрядность 			- число, разряд числа.
//  РазрядностьДробнойЧасти - число, разряд дробной части.
//
// Возвращаемое значение:
//  Объект "ОписаниеТипов" для числа указанной разрядности.
//
Функция ПолучитьОписаниеТиповЧисла(Разрядность,РазрядностьДробнойЧасти=0) Экспорт

	Массив = Новый Массив;

	Массив.Добавить(Тип("Число"));
	КвалификаторЧисла = Новый КвалификаторыЧисла(Разрядность,РазрядностьДробнойЧасти);

	Возврат Новый ОписаниеТипов(Массив, КвалификаторЧисла);

КонецФункции // ПолучитьОписаниеТиповЧисла() 

// Служебная функция, предназначенная для получения описания типов даты
// 
// Параметры:
//  ЧастиДаты - системное перечисление ЧастиДаты.
// 
Функция ПолучитьОписаниеТиповДаты(ЧастиДаты) Экспорт

	Массив = Новый Массив;
	Массив.Добавить(Тип("Дата"));

	КвалификаторДаты = Новый КвалификаторыДаты(ЧастиДаты);

	Возврат Новый ОписаниеТипов(Массив, , , КвалификаторДаты);

КонецФункции // ПолучитьОписаниеТиповДаты() 


////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ПЕРЕЧИСЛЕНИЯМИ


////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С МЕТАДАННЫМИ

// Функция возвращает имя табличной части, к которой принадлежит переданная строка
//
// Параметры
//  СтрокаТабличнойЧасти - ссылка на строку табличной части
//
// Возвращаемое значение:
//   Строка - имя табличной части, как оно задано в конфигураторе
//
Функция ПолучитьИмяТабличнойЧастиПоСсылкеНаСтроку(СтрокаТабличнойЧасти) Экспорт

	Возврат Метаданные.НайтиПоТипу(ТипЗнч(СтрокаТабличнойЧасти)).Имя;

КонецФункции // ПолучитьИмяТабличнойЧастиПоСсылкеНаСтроку()

// Функция возвращает метаданные документа, которому принадлежит переданная строка
//
// Параметры
//  СтрокаТабличнойЧасти - ссылка на строку табличной части
//
// Возвращаемое значение:
//   Метаданные - метаданные документа, как оно задано в конфигураторе
//
Функция ПолучитьМетаданныеДокументаПоСсылкеНаСтроку(СтрокаТабличнойЧасти) Экспорт

	Возврат Метаданные.НайтиПоТипу(ТипЗнч(СтрокаТабличнойЧасти)).Родитель();

КонецФункции // ПолучитьМетаданныеДокументаПоСсылкеНаСтроку()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ДВИЖЕНИЯМИ ДОКУМЕНТОВ

// Удаляет движения документа по указанному регистру либо по всем регистрам. 
//
// Параметры:
//  Движения	- коллекция движений документа.
//  ИмяРегистра - имя регистра, движения по которому будут удалены;
//				необязательный, если не указан - удаляются все движения.
//
Процедура УдалитьДвиженияДокумента(Движения,ИмяРегистра = "") Экспорт

	Если ИмяРегистра = "" Тогда
		Для Каждого ДвиженияРегистра Из Движения Цикл
			ДвиженияРегистра.Очистить();
		КонецЦикла;
	Иначе
		Движения[ИмяРегистра].Очистить();
	КонецЕсли;

КонецПроцедуры // УдалитьДвиженияДокумента()

// Выполняет движение по регистру.
//
// Параметры:
//  НаборДвижений   - набор движений регистра. 
//
Процедура ВыполнитьДвижениеПоРегистру(НаборДвижений, ВидДвижения = Неопределено) Экспорт

	ТаблицаДвижений = НаборДвижений.мТаблицаДвижений;
	Если ТаблицаДвижений.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
    Если ТаблицаДвижений.Колонки.Найти("Период") = Неопределено Тогда
		ТаблицаДвижений.Колонки.Добавить("Период", ПолучитьОписаниеТиповДаты(ЧастиДаты.ДатаВремя))
	КонецЕсли;
	
	МетаРег = НаборДвижений.Метаданные();
	ИзмеренияСостТипа = Новый Структура;

	Для Каждого МетаИзм Из МетаРег.Измерения Цикл
		Если МетаИзм.Тип.Типы().Количество() > 1 Тогда
			ИзмеренияСостТипа.Вставить(МетаИзм.Имя);
		КонецЕсли;
	КонецЦикла;

	Для Каждого МетаИзм Из МетаРег.Реквизиты Цикл
		Если МетаИзм.Тип.Типы().Количество() > 1 Тогда
			ИзмеренияСостТипа.Вставить(МетаИзм.Имя);
		КонецЕсли;
	КонецЦикла;

	Для Каждого МетаРес Из МетаРег.Ресурсы Цикл
		Если МетаРес.Тип.Типы().Количество() > 1 Тогда
			ИзмеренияСостТипа.Вставить(МетаРес.Имя);
		КонецЕсли;
	КонецЦикла;

	// Откопируем остальные колонки (структура таблиц совпадает).
	ПерваяКолонка = Истина;
	МассивСтрок   = Новый Массив(ТаблицаДвижений.Количество());

	Для каждого Колонка Из ТаблицаДвижений.Колонки Цикл

		ИмяКолонки = Колонка.Имя;

		Если ИмяКолонки <> "Период"
		   И ИмяКолонки <> "Активность"
		   И ИмяКолонки <> "НомерСтроки"
		   И ИмяКолонки <> ""
		   И ?(ИмяКолонки = "ВидДвижения", ВидДвижения = Неопределено, Истина)
		   И ИмяКолонки <> "МоментВремени" Тогда

			ФлагКолонкиСостТипа = (ИзмеренияСостТипа.Свойство(ИмяКолонки));

			Индекс = 0;

			Для каждого СтрокаТаблицы Из ТаблицаДвижений Цикл

				Если ПерваяКолонка Тогда

					Если ВидДвижения = ВидДвиженияНакопления.Приход Тогда
						СтрокаДвижения = НаборДвижений.ДобавитьПриход();
					ИначеЕсли ВидДвижения = ВидДвиженияНакопления.Расход Тогда
						СтрокаДвижения = НаборДвижений.ДобавитьРасход();
					Иначе
						СтрокаДвижения = НаборДвижений.Добавить(); // Для оборотных регистров
					КонецЕсли;

					МассивСтрок[Индекс] = СтрокаДвижения;
					Если СтрокаТаблицы.Период = '00010101' Тогда
						СтрокаДвижения.Период = НаборДвижений.мПериод;
					Иначе
						СтрокаДвижения.Период = СтрокаТаблицы.Период;
					КонецЕсли; 

				Иначе

					СтрокаДвижения = МассивСтрок[Индекс];

				КонецЕсли;

				Индекс = Индекс + 1;

				ЗначКолонки = СтрокаТаблицы[ИмяКолонки];
				Если ФлагКолонкиСостТипа Тогда
					Если ЗначКолонки = Неопределено ИЛИ ЗначКолонки.Пустая() Тогда
						СтрокаДвижения[ИмяКолонки] = Неопределено;
					Иначе
						СтрокаДвижения[ИмяКолонки] = ЗначКолонки;
					КонецЕсли;
				Иначе
					СтрокаДвижения[ИмяКолонки] = ЗначКолонки;
				КонецЕсли;

			КонецЦикла;

			ПерваяКолонка = Ложь;

		КонецЕсли;

	КонецЦикла;

КонецПроцедуры // ВыполнитьДвижениеПоРегистру()

// Формирует структуру, содержащую значения реквизитов шапки документа.
//
// Параметры: 
//  ДокументОбъект - объект документа для формирования структуры шапки, 
//
// Возвращаемое значение:
//  Сформированная структура.
//
Функция СформироватьСтруктуруШапкиДокумента(ДокументОбъект) Экспорт

	ВалютаРегламентированногоУчета = Константы.ВалютаРегламентированногоУчета.Получить();

	// Первоначальные данные о документе.
	СтруктураШапкиДокумента = Новый Структура;
	СтруктураШапкиДокумента.Вставить("Ссылка", ДокументОбъект.Ссылка);
	СтруктураШапкиДокумента.Вставить("Дата",   ДокументОбъект.Дата);
	СтруктураШапкиДокумента.Вставить("Номер",  ДокументОбъект.Номер);

	МетаданныеДокумента = ДокументОбъект.Метаданные();
	СтруктураШапкиДокумента.Вставить("ВидДокумента",  МетаданныеДокумента.Имя);
	СтруктураШапкиДокумента.Вставить("ПредставлениеВидаДокумента",  МетаданныеДокумента.Представление());
    
	Для каждого Реквизит из МетаданныеДокумента.Реквизиты Цикл
		СтруктураШапкиДокумента.Вставить(Реквизит.Имя, ДокументОбъект[Реквизит.Имя]);
	КонецЦикла;

	// Отображение данных о валютах.
	СтруктураШапкиДокумента.Вставить("ВалютаРегламентированногоУчета", ВалютаРегламентированногоУчета);	

	Если СтруктураШапкиДокумента.Свойство("ВалютаДокумента") Тогда
		СтруктураШапкиДокумента.Вставить("КурсДокумента",      КурсДокумента(ДокументОбъект, ВалютаРегламентированногоУчета));
		СтруктураШапкиДокумента.Вставить("КратностьДокумента", КратностьДокумента(ДокументОбъект, ВалютаРегламентированногоУчета));

	КонецЕсли;
	
	
		

	Возврат СтруктураШапкиДокумента;

КонецФункции // СформироватьСтруктуруШапкиДокумента()

// Формирует структуру дерева значений, содержащего имена полей, которые
// нужно заполнить в запросе по шапке документа.
//
// Параметры: 
//  Нет.
//
// Возвращаемое значение:
//  Дерево значений.
//
Функция СформироватьДеревоПолейЗапросаПоШапке()  Экспорт

	ДеревоПолейЗапросаПоШапке = Новый ДеревоЗначений;
	ОписаниеТиповСтрока       = ПолучитьОписаниеТиповСтроки(100);

	ДеревоПолейЗапросаПоШапке.Колонки.Добавить("Объект"   , ОписаниеТиповСтрока);
	ДеревоПолейЗапросаПоШапке.Колонки.Добавить("Поле"     , ОписаниеТиповСтрока);
	ДеревоПолейЗапросаПоШапке.Колонки.Добавить("Псевдоним", ОписаниеТиповСтрока);

	Возврат ДеревоПолейЗапросаПоШапке;

КонецФункции // СформироватьДеревоПолейЗапросаПоШапке()

// Вставляет строку в дерево полей запроса по шапке, если ее там еще нет,
// если есть, то ничего не делает.
//
// Параметры:
//  ДеревоПолейЗапросаПоШапке - дерево значений, содержащего имена полей, 
//                              которые нужно заполнить в запросе по шапке документа, 
//  ИмяОбъекта                - строка, имя объекта (справочник, регистр и т.д.), 
//  ИмяПоля                   - строка, имя поля объекта,
//  ИмяПсевдонима             - строка, имя псевдонима в запросе поля объекта (необязательный).
//
Процедура ДобавитьСтрокуВДеревоПолейЗапросаПоШапке(ДеревоПолейЗапросаПоШапке, ИмяОбъекта, ИмяПоля, ИмяПсевдонима = Неопределено) Экспорт

	// Поищем нужную строку.
	// Вначале ищем объект.
	СтрокаОбъекта = ДеревоПолейЗапросаПоШапке.Строки.Найти(ИмяОбъекта, "Объект");

	Если СтрокаОбъекта = Неопределено Тогда // нужно добавить.

		СтрокаОбъекта = ДеревоПолейЗапросаПоШапке.Строки.Добавить();

		СтрокаОбъекта.Объект    = ИмяОбъекта;
		СтрокаОбъекта.Поле      = ИмяПоля;
		СтрокаОбъекта.Псевдоним = ИмяПсевдонима;

	КонецЕсли;

	// Ищем поле.
	СтрокаПоля = СтрокаОбъекта.Строки. Найти(ИмяПоля,"Поле");

	Если СтрокаПоля = Неопределено Тогда // нужно добавить

		СтрокаПоля = СтрокаОбъекта.Строки.Добавить();

		СтрокаПоля.Поле      = ИмяПоля;
		СтрокаПоля.Псевдоним = ИмяПсевдонима;

	КонецЕсли;

	// Ищем псевдоним.
	СтрокаПоля = СтрокаОбъекта.Строки.Найти( ИмяПсевдонима, "Псевдоним");

	Если СтрокаПоля = Неопределено Тогда // нужно добавить

		СтрокаПоля = СтрокаОбъекта.Строки.Добавить();

		СтрокаПоля.Поле      = ИмяПоля;
		СтрокаПоля.Псевдоним = ИмяПсевдонима;

	КонецЕсли;

КонецПроцедуры // ДобавитьСтрокуВДеревоПолейЗапросаПоШапке()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ПОСЛЕДОВАТЕЛЬНОСТЯМИ

// Сдвиг ГП назад при необходимости.
//
Процедура СдвигПоследовательностиНазад(ИмяПоследовательности, Дата, Ссылка, Измерения = Неопределено) Экспорт

	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	ТекущаяПоследовательностьГраницы.МоментВремени
	|ИЗ
	|	Последовательность."+ИмяПоследовательности+".Границы КАК ТекущаяПоследовательностьГраницы
	| ";
	
	Если Не( Измерения = Неопределено ) Тогда
		Запрос.Текст = Запрос.Текст+"
		|ГДЕ";
		
		Для каждого Измерение из Измерения Цикл
			Запрос.Текст = Запрос.Текст+"
			|	ТекущаяПоследовательностьГраницы."+Измерение.Ключ +"  = &"+Измерение.Ключ;
			Запрос.УстановитьПараметр(Измерение.Ключ,Измерение.Значение);
		КонецЦикла;	
	КонецЕсли;
		
	Запрос.Текст = Запрос.Текст+"
	|ДЛЯ ИЗМЕНЕНИЯ";
		
	Выборка = Запрос.Выполнить().Выбрать();
		
	МоментВремениДокумента = Новый МоментВремени(Дата, Ссылка);
		
	Если Выборка.Следующий() Тогда
		// Граница переносится назад, если документ проводится задним числом
		Если МоментВремениДокумента.Сравнить(Выборка.МоментВремени) = -1 Тогда
			Последовательности[ИмяПоследовательности].УстановитьГраницу(МоментВремениДокумента, Измерения);
		КонецЕсли;
	КонецЕсли;

КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ ДОКУМЕНТАМИ

// Процедура предназначена для преобразования номера документа.
//
// Параметры:
//  Документ - (ДокументСсылка), документ, чей номер надо получить для печати.
//
// Возвращаемое значение.
//  Строка - номер документа для печати
//
Функция ПолучитьНомерНаПечать(Документ) Экспорт

	Если Документ = Неопределено Тогда 
		Возврат 0;
	КонецЕсли;

	Номер   = СокрЛП(Документ.Номер);
	Префикс = "";

	Если ТипЗнч(Документ) = Тип("ВыборкаИзРезультатаЗапроса") Тогда

		Если НЕ ЗначениеНеЗаполнено(Документ.Организация) Тогда
			Префикс = СокрЛП(Документ.Организация.Префикс);
		КонецЕсли;

	ИначеЕсли ТипЗнч(Документ) = Тип("Структура") Тогда

		Префикс = СокрЛП(Документ.Организация.Префикс);

	Иначе

		МетаданныеДокумента = Документ.Метаданные();

		Если ЕстьРеквизитДокумента("Организация", МетаданныеДокумента) Тогда

			Если НЕ ЗначениеНеЗаполнено(Документ.Организация) Тогда
				Префикс = СокрЛП(Документ.Организация.Префикс);
			КонецЕсли;

		КонецЕсли;

	КонецЕсли;
	
	ПрефиксУзла = "";
	ДобавитьПрефиксУзла(ПрефиксУзла);
	
	СписокПрефиксов = Новый СписокЗначений();
	Если ПрефиксУзла <> "" Тогда
		СписокПрефиксов.Добавить(ПрефиксУзла);
	КонецЕсли;	
	Если Префикс <> "" Тогда
		СписокПрефиксов.Добавить(Префикс);
	КонецЕсли;
	
	Для Каждого ЭлементСписка ИЗ СписокПрефиксов Цикл
		
		ТекущийПрефикс = ЭлементСписка.Значение;
		
		// удаление префикса из номера документа
		Если Найти(Номер, ТекущийПрефикс)=1 Тогда 
			Номер = Сред(Номер, СтрДлина(ТекущийПрефикс)+1);
		КонецЕсли;
		
		// так же, может остаться "минус" впереди
		Если Лев(Номер, 1) = "-" Тогда
			Номер = Сред(Номер, 2);
		КонецЕсли;
		
		// удаление ведущих нулей
		Пока Лев(Номер, 1)="0" Цикл
			Номер = Сред(Номер, 2);
		КонецЦикла;
	КонецЦикла;
	
	Если Лев(Номер, 1) = "-" Тогда
		Номер = Сред(Номер, 2);
	КонецЕсли;
	
	// удаление ведущих нулей
	Пока Лев(Номер, 1)="0" Цикл
		Номер = Сред(Номер, 2);
	КонецЦикла;
	
	Возврат Номер;

КонецФункции // ПолучитьНомерНаПечать()

// Функция производит поиск документа заданного вида, имеющего значение реквизита "ДокументОснование", равное
// переданной ссылке.
//
// Параметры:
//  ДокументСсылка  - ссылка на документ, для которого надо найти подчиненный документ,
//  ВидСчетаФактуры - строка, вид документа, по умолчанию "СчетФактураВыданный"
//
// Возвращаемое значение:
//  Если нашли, то возвращаем ссылку, не нашли - Неопределено
//
Функция НайтиПодчиненныйДокумент(ДокументСсылка, ВидДокумента = "СчетФактураВыданный", РазрешитьВыборСФНаАванс = Истина, РазрешитьВыборТолькоСФНаАванс = Ложь, СтавкаНДСсАванса = Неопределено) Экспорт

	НайденныйДокумент = Неопределено;

	Если НЕ ЗначениеНеЗаполнено(ДокументСсылка) Тогда

		Запрос = Новый Запрос;

		// Установим параметры запроса
		Запрос.УстановитьПараметр("ДокументСсылка", ДокументСсылка);

		Запрос.Текст = 
		"ВЫБРАТЬ РАЗРЕШЕННЫЕ
		|	Ссылка
		|ИЗ
		|	Документ." + ВидДокумента + " 
		|ГДЕ
		|	ДокументОснование = &ДокументСсылка";
		Если ВидДокумента = "СчетФактураВыданный" И Не РазрешитьВыборСФНаАванс Тогда
			Запрос.Текст = Запрос.Текст + " И Не НаАванс";
		ИначеЕсли ВидДокумента = "СчетФактураВыданный" И РазрешитьВыборСФНаАванс и РазрешитьВыборТолькоСФНаАванс Тогда
			Запрос.Текст = Запрос.Текст + " И НаАванс";
			Если не ЗначениеНеЗаполнено(СтавкаНДСсАванса) Тогда
				Запрос.Текст = Запрос.Текст + " И СтавкаНДС = &СтавкаНДСсАванса";
				Запрос.УстановитьПараметр("СтавкаНДСсАванса", СтавкаНДСсАванса);
			КонецЕсли; 
		КонецЕсли;
		
		ВыборкаИзЗапроса = Запрос.Выполнить().Выбрать();

		Если ВыборкаИзЗапроса.Следующий() Тогда
			НайденныйДокумент = ВыборкаИзЗапроса.Ссылка;
		КонецЕсли;

	КонецЕсли;

	Возврат НайденныйДокумент;

КонецФункции // НайтиПодчиненныйДокумент()

// Функция выполняет проверку необходимости проведения документа по разделам учета
Функция ПроводитьДокументПоРазделуУчета(Организация, РазделУчета, Дата) Экспорт
	
	Если ТипЗнч(РазделУчета) <> Тип("ПеречислениеСсылка.РазделыУчета") Тогда
		Возврат Ложь;
	КонецЕсли;
	
	ИмяПеречисления = "";
	Для Каждого ЗначениеПеречисления Из РазделУчета.Метаданные().ЗначенияПеречисления Цикл
		Если Перечисления.РазделыУчета[ЗначениеПеречисления.Имя] = РазделУчета Тогда
			ИмяПеречисления = ЗначениеПеречисления.Имя;
		КонецЕсли;
	КонецЦикла;
	
	Если ЗначениеНеЗаполнено(ИмяПеречисления) Тогда
		Возврат Ложь;
	КонецЕсли;

	Запрос = Новый Запрос;
	Запрос.Текст = "
	 |ВЫБРАТЬ
	 |	1 КАК ЗаписьРегистра
	 |ИЗ
	 |	РегистрСведений.ДатаАктуальностиУчета КАК ДатаАктуальностиУчета
	 |ГДЕ
	 |	ДатаАктуальностиУчета.Организация = &Организация
	 |	И КОНЕЦПЕРИОДА(ДатаАктуальностиУчета."+ИмяПеречисления+", ДЕНЬ) <= &ДатаДокумента
	 |	И ДатаАктуальностиУчета."+ИмяПеречисления+" <> ДАТАВРЕМЯ(1, 1, 1)";
	 Если РазделУчета = Перечисления.РазделыУчета Тогда
		 Запрос.Текст = Запрос.Текст + 	"ОБЪЕДИНИТЬ ВСЕ
		 								|ВЫБРАТЬ
		 								|	1
										|ИЗ
										|	Константы КАК Константы
										|ГДЕ
										|	Константы.ДатаНачалаАвтоматическогоОтраженияВУчетеУСН >= &ДатаДокумента";
	КонецЕсли;
	 
	Запрос.УстановитьПараметр("Организация", Организация);
	Запрос.УстановитьПараметр("ДатаДокумента", Дата);
	Возврат Запрос.Выполнить().Пустой() И ?(РазделУчета = Перечисления.РазделыУчета.НДС, ПроводитьПоРазделуУчетаНДС(Дата), Истина);
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ СО СТАВКАМИ НАЛОГОВ И ВЗНОСОВ

// Рассчитываем сумму документа со всеми налогами
//
// Параметры: 
//  ДокументОбъект    - объект документа, сумму которого надо рассчитать
//  ИмяТабличнойЧасти - строка, имя табличной части, сумму которой надо рассчитать.
//                      Если она не заполнена, считаем по всем табличным частям, в которых есть "Сумма"
//  НеУчитыватьТару   - булево, если Истина и ИмяТабличнойЧасти неопределено, то в расчете сумм тару не учитываем
//
// Возвращаемое значение:
//  Сумма документа со всеми налогами.
//
Функция ПолучитьСуммуДокументаСНДС(ДокументОбъект, ИмяТабличнойЧасти = Неопределено, НеУчитыватьТару = Истина) Экспорт

	МетаданныеДокумента = ДокументОбъект.Метаданные();

	СуммаДокумента = 0;
	Если ИмяТабличнойЧасти <> Неопределено Тогда
		СуммаДокумента = СуммаДокумента + ДокументОбъект[ИмяТабличнойЧасти].Итог("Сумма");
		Если ЕстьРеквизитДокумента("УчитыватьНДС", МетаданныеДокумента)
		   И ЕстьРеквизитДокумента("СуммаВключаетНДС", МетаданныеДокумента)
		   И ЕстьРеквизитТабЧастиДокумента("СуммаНДС", МетаданныеДокумента, ИмяТабличнойЧасти)
		   И ДокументОбъект.УчитыватьНДС
		   И Не ДокументОбъект.СуммаВключаетНДС Тогда
			СуммаДокумента = СуммаДокумента + ДокументОбъект[ИмяТабличнойЧасти].Итог("СуммаНДС");
		КонецЕсли; 
	Иначе
		Для каждого ТЧОбъекта Из ДокументОбъект.Метаданные().ТабличныеЧасти Цикл
			Если НеУчитыватьТару и ТЧОбъекта.Имя = "ВозвратнаяТара" Тогда
				Продолжить;
			КонецЕсли;
			Если ТЧОбъекта.Имя = "ВыданныеАвансы" Тогда
				Продолжить;
			КонецЕсли;
			Если ТЧОбъекта.Имя = "ДенежныеСредства" Тогда
				Продолжить;
			КонецЕсли;
			Если ЕстьРеквизитТабЧастиДокумента("Сумма", МетаданныеДокумента, ТЧОбъекта.Имя) Тогда
				СуммаДокумента = СуммаДокумента + ДокументОбъект[ТЧОбъекта.Имя].Итог("Сумма");
				Если ЕстьРеквизитДокумента("УчитыватьНДС", МетаданныеДокумента)
					И ЕстьРеквизитДокумента("СуммаВключаетНДС", МетаданныеДокумента)
					И ЕстьРеквизитТабЧастиДокумента("СуммаНДС", МетаданныеДокумента, ТЧОбъекта.Имя)
					И ДокументОбъект.УчитыватьНДС
					И Не ДокументОбъект.СуммаВключаетНДС Тогда
					СуммаДокумента = СуммаДокумента + ДокументОбъект[ТЧОбъекта.Имя].Итог("СуммаНДС");
				КонецЕсли; 
			КонецЕсли;
		КонецЦикла;
		Если ЕстьРеквизитДокумента("Сумма", МетаданныеДокумента) Тогда
			СуммаДокумента = СуммаДокумента + ДокументОбъект.Сумма;
			Если ЕстьРеквизитДокумента("УчитыватьНДС", МетаданныеДокумента)
				И ЕстьРеквизитДокумента("СуммаВключаетНДС", МетаданныеДокумента)
				И ЕстьРеквизитДокумента("СуммаНДС", МетаданныеДокумента)
				И ДокументОбъект.УчитыватьНДС
				И Не ДокументОбъект.СуммаВключаетНДС Тогда
				СуммаДокумента = СуммаДокумента + ДокументОбъект.СуммаНДС;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;

	Возврат СуммаДокумента;

КонецФункции // ПолучитьСуммуДокументаСНДС()

// Рассчитывает сумму НДС исходя из суммы и флагов налогообложения
//
// Параметры: 
//  Сумма            - число, сумма от которой надо рассчитывать налоги, 
//  УчитыватьНДС     - булево, признак учета НДС в сумме, 
//  СуммаВключаетНДС - булево, признак включения НДС в сумму ("внутри" или "сверху"),
//  СтавкаНДС        - число , процентная ставка НДС,
//
// Возвращаемое значение:
//  Число, полученная сумма НДС
//
Функция РассчитатьСуммуНДС(Сумма, УчитыватьНДС, СуммаВключаетНДС, СтавкаНДС) Экспорт

	Если (УчитыватьНДС) И (СуммаВключаетНДС) Тогда
		СуммаБезНДС = 100 * Сумма / (100 + СтавкаНДС);
		СуммаНДС = Сумма - СуммаБезНДС;
	Иначе
		СуммаБезНДС = Сумма;
	КонецЕсли;

	Если УчитыватьНДС Тогда 
		Если НЕ СуммаВключаетНДС Тогда
			СуммаНДС = СуммаБезНДС * СтавкаНДС / 100;
		КонецЕсли;
	Иначе
		СуммаНДС = 0;
	КонецЕсли;

	Возврат СуммаНДС;

КонецФункции // РассчитатьСуммуНДС()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ СО СЧЕТАМИ И СУБКОНТО

// Функция возвращает остаток по счету бухгалтерского учета
// Возвращаемое значение - таблица значений в развороте по аналитике с учетом фильтра
Функция ПолучитьОстатокПоСчету(Организация,Период,Счет,Валюта=Неопределено ,Субконто1=Неопределено, Субконто2=Неопределено,Субконто3=Неопределено,ЗнакФильтрПоОстаткам=0) Экспорт

	ВидПланаСчетов = Счет.Метаданные().Имя;

	Субконто    = Новый Массив(3);
	Субконто[0] = Субконто1;
	Субконто[1] = Субконто2;
	Субконто[2] = Субконто3;

	ФильтрПоСубконто = "";

	Для Каждого ТекВидСубконто из Счет.ВидыСубконто Цикл
		Если Не(ТекВидСубконто.ТолькоОбороты) Тогда
			Если Не(Субконто[ТекВидСубконто.НомерСтроки-1] = Неопределено) тогда
				ФильтрПоСубконто = ФильтрПоСубконто + ?(ФильтрПоСубконто = "", "", " И ") + "Субконто"+ТекВидСубконто.НомерСтроки + " = &Субконто" + ТекВидСубконто.НомерСтроки;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	ВыбиратьВалюту			= (не Счет.Метаданные().ПризнакиУчета.Найти("Валютный")= Неопределено);
	ВыбиратьВалютнуюСумму	= (не Метаданные.РегистрыБухгалтерии[ВидПланаСчетов].Ресурсы.Найти("ВалютнаяСумма")= Неопределено);
	ОтборПоОрганизации		= (не Метаданные.РегистрыБухгалтерии[ВидПланаСчетов].Измерения.Найти("Организация")= Неопределено);

	Запрос = Новый Запрос();
	Запрос.УстановитьПараметр("Период"     , Период);
	Запрос.УстановитьПараметр("Счет"       , Счет);
	Запрос.УстановитьПараметр("Организация", Организация);
	Запрос.УстановитьПараметр("Субконто1"  , Субконто[0]);
	Запрос.УстановитьПараметр("Субконто2"  , Субконто[1]);
	Запрос.УстановитьПараметр("Субконто3"  , Субконто[2]);
	Запрос.УстановитьПараметр("Валюта"     , Валюта);
	Запрос.Текст = "
	|ВЫБРАТЬ
	|	Счет,
	|	Субконто1,
	|	Субконто2,
	|	Субконто3,
	|	Выразить(СУММА((ВЫБОР 
	|			КОГДА СуммаОстаток ЕСТЬ Null 
	|			ТОГДА 0
	|		ИНАЧЕ
	|			СуммаОстаток
	|		КОНЕЦ)) как число) КАК СуммаОстаток
	|  "+?(ВыбиратьВалюту,",  ВЫБОР 
	|		КОГДА Счет.Валютный = Истина ТОГДА 
	|			Валюта
	|		ИНАЧЕ
	|			Неопределено
	|		КОНЕЦ Валюта","")+"
	|	"+?(ВыбиратьВалютнуюСумму,",  Выразить(СУММА(ВЫБОР 
	|			КОГДА ВалютнаяСуммаОстаток ЕСТЬ Null 
	|			ТОГДА 0
	|		ИНАЧЕ
	|			ВалютнаяСуммаОстаток
	|		КОНЕЦ)как Число) КАК ВалютнаяСуммаОстаток","")+"
	|ИЗ
	|	РегистрБухгалтерии."+ВидПланаСчетов+".Остатки(&Период, Счет = &Счет, , #Фильтр#) КАК Остатки
	|
	|
	|СГРУППИРОВАТЬ ПО
	|	Счет,
	|	Субконто1,
	|	Субконто2,
	|	Субконто3
	|  "+?(ВыбиратьВалюту," ,Валюта","")+"
	|УПОРЯДОЧИТЬ ПО
	|	Счет,
	|	Субконто1,
	|	Субконто2,
	|	Субконто3
	|  "+?(ВыбиратьВалюту," ,Валюта","")+"
	|";
		
	Фильтр = "";
	Если ОтборПоОрганизации Тогда
		Фильтр = Фильтр + "Организация = &Организация";
	КонецЕсли;
	ЕСли НЕ (ЗначениеНеЗаполнено(Валюта) ИЛИ НЕ Счет.Валютный) Тогда
		Фильтр = Фильтр + ?(Фильтр = "", "", " И ") + "Валюта = &Валюта";
	КонецЕсли;
	Если Не ПустаяСтрока(ФильтрПоСубконто) Тогда
		Фильтр = Фильтр + ?(Фильтр = "", "", " И ") + ФильтрПоСубконто;
	КонецЕсли;
	
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "#Фильтр#", Фильтр);	
	
	ВыборкаОстатков = Запрос.Выполнить();

	Остатки = ВыборкаОстатков.Выгрузить();
	Если Остатки.Колонки.Найти("ВалютнаяСуммаОстаток") = Неопределено Тогда
		Остатки.Колонки.Добавить("ВалютнаяСуммаОстаток", ПолучитьОписаниеТиповЧисла(15,2));
		Остатки.ЗагрузитьКолонку(Остатки.ВыгрузитьКолонку("СуммаОстаток"),"ВалютнаяСуммаОстаток");
	КонецЕсли; 
	

	Если Не(ЗнакФильтрПоОстаткам = 0) тогда

		КУдалению = Новый Массив;

		Для каждого Остаток из Остатки Цикл

			Если ((ЗнакФильтрПоОстаткам > 0) = (?(ЗначениеНеЗаполнено(Валюта),Остаток.СуммаОстаток,Остаток.ВалютнаяСуммаОстаток) > 0)) тогда

				Если ЗнакФильтрПоОстаткам < 0 тогда
					Остаток.СуммаОстаток         = -Остаток.СуммаОстаток;
					Остаток.ВалютнаяСуммаОстаток = -Остаток.ВалютнаяСуммаОстаток;
				КонецЕсли;

			Иначе
				КУдалению.Добавить(Остаток);

			КонецЕсли;

		КонецЦИкла;

		Для каждого Остаток из КУдалению цикл
			Остатки.Удалить(Остаток);
		КонецЦикла;

	КонецЕсли;

	Возврат Остатки;

КонецФункции // ПолучитьОстатокПоСчету()

// Процедура устанавливает субконто на счете. Если такое субконто на счете
// отсутствует, то ничего не делается.
//
// Параметры:
//		Счет - Счет, к которому относится субконто
//      Субконто - набор субконто
//		Номер или имя установливаемого субконто
//      Значение субконто - значение устанавливаемого субконто
//
Процедура УстановитьСубконто(Счет, Субконто, ИмяСубконто, ЗначениеСубконто, Сообщать = Ложь, Заголовок = "") Экспорт

	Если Счет = Неопределено ИЛИ Счет.Пустая() Тогда
		Возврат;
	КонецЕсли;

	Если ТипЗнч(ИмяСубконто) = Тип("Число") Тогда

		Если ИмяСубконто > Счет.ВидыСубконто.Количество() Тогда
			Возврат;
		КонецЕсли;

		ВидСубк = Счет.ВидыСубконто[ИмяСубконто - 1].ВидСубконто;

	Иначе

		ИмяПланаСчетов=Счет.Метаданные().Имя;
		ИмяВидовСубконто="";
		
		ИмяВидовСубконто="ВидыСубконтоХозрасчетные";
			
		ПланВидовХарактеристик=ПланыВидовХарактеристик[ИмяВидовСубконто];
		
		ВидСубк = ПланВидовХарактеристик[ИмяСубконто];

		Если Счет.ВидыСубконто.Найти(ВидСубк) = Неопределено Тогда
			Если Сообщать тогда
				СообщитьОбОшибке("Вид субконто <" + ВидСубк + "> для счета """+Счет.Код +" ("+Счет.Наименование+")"" не определен.",, Заголовок );
			КонецЕсли;
			Возврат;
		КонецЕсли;

	КонецЕсли;

	Если ВидСубк.ТипЗначения.СодержитТип(ТипЗнч(ЗначениеСубконто)) Тогда
		Субконто.Вставить(ВидСубк, ЗначениеСубконто);

	ИначеЕсли Сообщать тогда
		СообщитьОбОшибке("Неверное значение """ + ЗначениеСубконто + """ для вида субконто <" + ВидСубк + ">",, Заголовок);

	КонецЕсли;

КонецПроцедуры // УстановитьСубконто()

// Процедура устанавливает субконто на счете по виду субконто. Если такое субконто на счете
// отсутствует, то ничего не делается.
//
// Параметры:
//		Счет - Счет, к которому относится субконто
//      Субконто - набор субконто
//		Номер или имя установливаемого субконто
//      Значение субконто - значение устанавливаемого субконто
//
Процедура УстановитьСубконтоПоВидуСубконто(Счет, Субконто, ВидСубконто, ЗначениеСубконто, Сообщать = Ложь, Заголовок = "") Экспорт

	Если Счет = Неопределено ИЛИ Счет.Пустая() Тогда
		Возврат;
	КонецЕсли;

	Если Счет.ВидыСубконто.Найти(ВидСубконто) = Неопределено Тогда
		Возврат;
	КонецЕсли;

	Если ВидСубконто.ТипЗначения.СодержитТип(ТипЗнч(ЗначениеСубконто)) Тогда
		Субконто.Вставить(ВидСубконто, ЗначениеСубконто);

	ИначеЕсли Сообщать тогда
		СообщитьОбОшибке("Неверное значение """ + ЗначениеСубконто + """ для вида субконто <" + ВидСубконто + ">",, Заголовок);

	КонецЕсли;

КонецПроцедуры // УстановитьСубконто()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С МАССИВАМИ

// Сравнивает два массива однотипных значений (кроме коллекций значений)
//
// Параметры: 
//  ПервыйМассив,ВторойМассив - сравниваемые массивы
//
// Возвращаемое значение:
//  булево.
//
Функция МассивыИдентичны(ПервыйМассив,ВторойМассив) Экспорт

	ЭлементовМассива = ПервыйМассив.Количество();
	МассивыСовпадают = (ЭлементовМассива = ВторойМассив.Количество()); 

	Если МассивыСовпадают Тогда

		Для Сч = 1 По ЭлементовМассива Цикл

			Если ПервыйМассив[Сч-1] <> ВторойМассив[Сч-1] Тогда
				Возврат Ложь
			КонецЕсли;

		КонецЦикла;

	КонецЕсли;

	Возврат МассивыСовпадают

КонецФункции // МассивыИдентичны()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ОШИБКАМИ

// Функция убирает из текста сообщения служебную информацию
//
// Параметры
//  ТекстСообщения, Строка, исходный текст сообщения//
// Возвращаемое значение:
//   Строка
//
Функция СформироватьТекстСообщения(Знач ТекстСообщения) Экспорт

	НачалоСлужебногоСообщения    = Найти(ТекстСообщения, "{");
	ОкончаниеСлужебногоСообщения = Найти(ТекстСообщения, "}:");
	
	Если ОкончаниеСлужебногоСообщения > 0 
		И НачалоСлужебногоСообщения > 0 
		И НачалоСлужебногоСообщения < ОкончаниеСлужебногоСообщения Тогда
		
		ТекстСообщения = Лев(ТекстСообщения, (НачалоСлужебногоСообщения - 1)) +
		                 Сред(ТекстСообщения, (ОкончаниеСлужебногоСообщения + 2));
						 
	КонецЕсли;
	
	Возврат СокрЛП(ТекстСообщения);

КонецФункции // ()


// Выводит сообщение об ошибке и выставляет параметр Отказ в "Истина". 
// В случае работы на клиенте или на сервере выводит в окно сообщений,
// в случае внешнего соединения вызывает исключение.
//
// Параметры:
//  ТекстСообщения - строка, текст сообщения.
//  Отказ          - булево, признак отказа (необязательный).
//
Процедура СообщитьОбОшибке(Знач ТекстСообщения, Отказ = Ложь, Заголовок = "", Знач Статус = Неопределено) Экспорт

	Если Статус = Неопределено Тогда
		Статус = СтатусСообщения.Важное;
	КонецЕсли;
	
	ТекстСообщения = СформироватьТекстСообщения(ТекстСообщения);
	Отказ = Истина;
	
	#Если ВнешнееСоединение Тогда
		
		Если НЕ ЗначениеНеЗаполнено(Заголовок) Тогда
			ТекстСообщения = Заголовок + Символы.ПС + ТекстСообщения;
			Заголовок = "";
		КонецЕсли;
		
		ВызватьИсключение (ТекстСообщения);
		
	#Иначе
		
		Если НЕ ЗначениеНеЗаполнено(Заголовок) Тогда
			Сообщить(Заголовок);
			Заголовок = "";
		КонецЕсли;
		
		Сообщить(ТекстСообщения, Статус);
		
	#КонецЕсли
	
КонецПроцедуры // СообщитьОбОшибке()


// Формирует сообщение при ошибках проведения документов.
//
// Параметры: 
//  ТекстСообщения - Исходный текст, выводимого сообщения,
//  Отказ          - Флаг отказа в проведении докумета,
//  Заголовок      - Заголовок начала серии сообщений об ошибках проведения (не обязательный)
//
Процедура ОшибкаПриПроведении(ТекстСообщения, Отказ, Заголовок="") Экспорт

	СообщитьОбОшибке(ТекстСообщения, Отказ, Заголовок);

КонецПроцедуры // ОшибкаПриПроведении()

// Формирует строку представления документа для сообщений при проведении.
//
// Параметры
//  Документ - ссылка на проводимый документ.
//
// Возвращаемое значение
//  Строка с представлением документа.
//
Функция ПредставлениеДокументаПриПроведении(Документ) Экспорт

	МетаданныеДокумента = Документ.Метаданные();

	ВидОперацииСтр = "";

	Если ЕстьРеквизитДокумента("ВидОперации", МетаданныеДокумента) Тогда
		ВидОперацииСтр = " (" + Документ.ВидОперации + ")";
	КонецЕсли;

	Возврат "Проведение документа: " + СокрЛП(Документ) + ВидОперацииСтр;

КонецФункции // ПредставлениеДокументаПриПроведении()

// Проверяет правильность заполнения шапки документа.
// Если какой-то из реквизтов шапки, влияющий на проведение не заполнен или
// заполнен не корректно, то выставляется флаг отказа в проведении.
// Проверяется также правильность заполнения реквизитов ссылочных полей документа.
// Проверка выполняется по объекту и по выборке из результата запроса по шапке.
//
// Параметры: 
//  ДокументОбъект             - объект проводимого документа, 
//  СтруктураОбязательныхПолей - структура, содержащая имена полей, которые собственно и надо проверить.
//  Отказ                      - флаг отказа в проведении.
//  Заголовок                  - строка, заголовок сообщения об ошибке проведения.
//
Процедура ПроверитьЗаполнениеШапкиДокумента(ДокументОбъект, СтруктураОбязательныхПолей, Отказ, Заголовок) Экспорт

	ТипыПланыСчетов     = ПланыСчетов.ТипВсеСсылки();
	МетаданныеРеквизиты = ДокументОбъект.Метаданные().Реквизиты;

	Для каждого КлючЗначение Из СтруктураОбязательныхПолей Цикл

		Значение = ДокументОбъект[КлючЗначение.Ключ];
		ПредставлениеРеквизита = МетаданныеРеквизиты[КлючЗначение.Ключ].Представление();

		Если ЗначениеНеЗаполнено(Значение) Тогда 

			Если ЗначениеНеЗаполнено(КлючЗначение.Значение) Тогда //
				СтрокаСообщения = "Не заполнено значение реквизита """ + СокрЛП(ПредставлениеРеквизита) + """!";
			Иначе
				СтрокаСообщения = КлючЗначение.Значение;
			КонецЕсли;

			ОшибкаПриПроведении(СтрокаСообщения, Отказ, Заголовок);

		ИначеЕсли ТипыПланыСчетов.СодержитТип(ТипЗнч(Значение)) тогда

			Если Значение.ЗапретитьИспользоватьВПроводках Тогда
				СтрокаСообщения = "Реквизит """ + СокрЛП(ПредставлениеРеквизита) + """ : счет " + СокрЛП(Значение)+" """ + Значение.Наименование + """ нельзя использовать в проводках.";
				ОшибкаПриПроведении(СтрокаСообщения, Отказ, Заголовок);

			КонецЕсли;

		КонецЕсли;

	КонецЦикла;

	Если СтруктураОбязательныхПолей.Свойство("Организация") и СтруктураОбязательныхПолей.Свойство("ДоговорКонтрагента") тогда

		// Если в документе есть организация и договор - провести проверку на соответствие
		//Организация в документе должна совпадать с организацией, указанной в договоре взаиморасчетов.
		Организация = ДокументОбъект.Организация;
		ДоговорКонтрагента = ДокументОбъект.ДоговорКонтрагента;
		Если ТипЗнч(ДоговорКонтрагента) = Тип("СправочникСсылка.ДоговорыКонтрагентов") тогда
			ПроверитьСоответствиеОрганизацииДоговоруВзаиморасчетов(Организация, ДоговорКонтрагента, ДоговорКонтрагента.Организация, Отказ, Заголовок);
		КонецЕсли;

	КонецЕсли;

КонецПроцедуры // ПроверитьЗаполнениеШапкиДокумента()

// Проверяет правильность заполнения шапки документа.
// Если какой-то из реквизтов шапки, влияющий на проведение не заполнен или
// заполнен не корректно, то выставляется флаг отказа в проведении.
// Проверяется также правильность заполнения реквизитов ссылочных полей документа.
// Проверка выполняется по объекту и по выборке из результата запроса по шапке.
//
// Параметры: 
//  ДокументОбъект             - объект проводимого документа, 
//  СтруктураОбязательныхПолей - структура, содержащая имена полей, которые собственно и надо проверить.
//  Отказ                      - флаг отказа в проведении.
//  Заголовок                  - строка, заголовок сообщения об ошибке проведения.
//
Процедура ПроверитьЗаполнениеШапкиСправочника(СправочникОбъект, СтруктураОбязательныхПолей, Отказ, Заголовок="") Экспорт

	ТипыПланыСчетов     = ПланыСчетов.ТипВсеСсылки();
	МетаданныеРеквизиты = СправочникОбъект.Метаданные().Реквизиты;

	Для каждого КлючЗначение Из СтруктураОбязательныхПолей Цикл

		Значение = СправочникОбъект[КлючЗначение.Ключ];
		ПредставлениеРеквизита = МетаданныеРеквизиты[КлючЗначение.Ключ].Представление();

		Если ЗначениеНеЗаполнено(Значение) Тогда 

			Если ЗначениеНеЗаполнено(КлючЗначение.Значение) Тогда //
				СтрокаСообщения = "Не заполнено значение реквизита """ + СокрЛП(ПредставлениеРеквизита) + """!";
			Иначе
				СтрокаСообщения = КлючЗначение.Значение;
			КонецЕсли;

			ОшибкаПриПроведении(СтрокаСообщения, Отказ, Заголовок);

		КонецЕсли;

	КонецЦикла;

	//Если СтруктураОбязательныхПолей.Свойство("Организация") и СтруктураОбязательныхПолей.Свойство("ДоговорКонтрагента") тогда

	//	// Если в документе есть организация и договор - провести проверку на соответствие
	//	//Организация в документе должна совпадать с организацией, указанной в договоре взаиморасчетов.
	//	Организация = ДокументОбъект.Организация;
	//	ДоговорКонтрагента = ДокументОбъект.ДоговорКонтрагента;
	//	Если ТипЗнч(ДоговорКонтрагента) = Тип("СправочникСсылка.ДоговорыКонтрагентов") тогда
	//		ПроверитьСоответствиеОрганизацииДоговоруВзаиморасчетов(Организация, ДоговорКонтрагента, ДоговорКонтрагента.Организация, Отказ, Заголовок);
	//	КонецЕсли;

	//КонецЕсли;

КонецПроцедуры // ПроверитьЗаполнениеШапкиДокумента()

// Проверяет правильность заполнения строк табличной части документа.
// Если какой-то из реквизтов, влияющий на проведение не заполнен или
// заполнен не корректно, то выставляется флаг отказа в проведении.
//
// Параметры:
//  ДокументОбъект             - объект проводимого документа, 
//  ИмяТабличнойЧасти          - табличная часть документа,
//  СтруктураОбязательныхПолей - структура, содержащая имена полей, которые собственно и надо проверить.
//  Отказ                      - флаг отказа в проведении.
//  Заголовок                  - строка, заголовок сообщения об ошибке проведения.
//
Процедура ПроверитьЗаполнениеТабличнойЧасти(ДокументОбъект, ИмяТабличнойЧасти, СтруктураОбязательныхПолей, 
                                            Отказ, Заголовок) Экспорт

	ПредставлениеТабличнойЧасти = ДокументОбъект.Метаданные().ТабличныеЧасти[ИмяТабличнойЧасти].Представление();

	ТабличнаяЧасть      = ДокументОбъект[ИмяТабличнойЧасти];
	МетаданныеРеквизиты = ДокументОбъект.Метаданные().ТабличныеЧасти[ИмяТабличнойЧасти].Реквизиты;
	Если (НЕ МетаданныеРеквизиты.Найти("СчетДоходовБУ") = Неопределено)
		И (НЕ МетаданныеРеквизиты.Найти("СчетРасходовБУ") = Неопределено) Тогда
		ПроверятьВидДеятельности = Истина;
	Иначе
		ПроверятьВидДеятельности = Ложь;
	КонецЕсли;
	
	КэшСчетов = Новый Соответствие;
	
	// Цикл по строкам табличной части.
	Для каждого СтрокаТаблицы Из ТабличнаяЧасть Цикл

		СтрокаНачалаСообщенияОбОшибке = "В строке номер """+ СокрЛП(СтрокаТаблицы.НомерСтроки) +
		                               """ табличной части """ + ПредставлениеТабличнойЧасти + """: ";
			
		// Цикл по проверяемым полям
		Для каждого КлючЗначение Из СтруктураОбязательныхПолей Цикл

			Значение = СтрокаТаблицы[КлючЗначение.Ключ];
			Если ЗначениеНеЗаполнено(Значение) Тогда 

				Если ЗначениеНеЗаполнено(КлючЗначение.Значение) Тогда //
					ПредставлениеРеквизита = МетаданныеРеквизиты[КлючЗначение.Ключ].Представление();
					СтрокаСообщения = "Не заполнено значение реквизита """ + СокрЛП(ПредставлениеРеквизита) + """!";

				Иначе
					СтрокаСообщения = КлючЗначение.Значение;

				КонецЕсли;

				ОшибкаПриПроведении(СтрокаНачалаСообщенияОбОшибке + СтрокаСообщения, Отказ, Заголовок);

			КонецЕсли;

		КонецЦикла;
		
		Если ПроверятьВидДеятельности Тогда
			Если ЗначениеНеЗаполнено(СтрокаТаблицы["СчетДоходовБУ"]) ИЛИ ЗначениеНеЗаполнено(СтрокаТаблицы["СчетРасходовБУ"]) Тогда
				//Один из счетов не заполнен, соответствие не проверяется
			Иначе			
				СчетДоходовБУВСтроке = СтрокаТаблицы["СчетДоходовБУ"];
				СчетДоходовБУЕНВД = КэшСчетов[СчетДоходовБУВСтроке];
				Если СчетДоходовБУЕНВД = Неопределено Тогда
					//СчетДоходовБУЕНВД = ОтноситсяКДеятельностиЕНВД(СчетДоходовБУВСтроке);
					КэшСчетов[СчетДоходовБУВСтроке] = СчетДоходовБУЕНВД;					
				КонецЕсли;
				
				СчетРасходовБУВСтроке = СтрокаТаблицы["СчетРасходовБУ"];
				СчетРасходовБУЕНВД = КэшСчетов[СчетРасходовБУВСтроке];
				Если СчетРасходовБУЕНВД = Неопределено Тогда
					//СчетРасходовБУЕНВД = ОтноситсяКДеятельностиЕНВД(СчетРасходовБУВСтроке);
					КэшСчетов[СчетРасходовБУВСтроке] = СчетРасходовБУЕНВД;
				КонецЕсли;
				
				Если НЕ СчетДоходовБУЕНВД = СчетРасходовБУЕНВД Тогда
					СтрокаСообщения = "Счета доходов и расходов для бухгалтерского учета относятся к разным видам деятельности!"; 
					ОшибкаПриПроведении(СтрокаНачалаСообщенияОбОшибке + СтрокаСообщения, Отказ, Заголовок);
				КонецЕсли;
			КонецЕсли;
		Конецесли;

	КонецЦикла;

КонецПроцедуры // ПроверитьЗаполнениеТабличнойЧасти()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ТАБЛИЦАМИ

// Проверяет наличие требуемых данных в источнике и Формирует таблицу значений
//
// Параметры
//  Источник  – ТаблицаЗначений или ТабличнаяЧасть или КоллекцияСтрокДереваЗначений с исходными данными
//
//  Реквизиты – структура – Структура реквизитов. 
//							Ключ 		- Наименование колонки в источнике
//							Значение    - Наименование колонки в получаемой ТЗ
//							Если значение опущено - приравнивается ключу.
//	ПолучитьНомерСтрокиДокумента - булево
//	                        Используется только при выгрузке из табличной части документа.
//							В формируемой таблице создает новую колонку "НомерСтрокиДокумента"
//								и заполняет её реальными номерами строк
//
//  КоллекцияКолонокДереваЗначений - только для коллекции строк дерева значений.
// Возвращаемое значение:
//  Таблица значений или Неопределено (если не хватает реквизитов)
//
Функция СформироватьТаблицуЗначений(Источник,Реквизиты=Неопределено,ПолучитьНомерСтрокиДокумента = ложь,ФормироватьОтстутствующиеКолонки=Ложь,КоллекцияКолонокДереваЗначений=Неопределено) экспорт

	ЭтоТаблицаЗначений      = (ТипЗнч(Источник) = Тип("ТаблицаЗначений"));
	ЭтоСтрокиДереваЗначений = (ТипЗнч(Источник) = Тип("КоллекцияСтрокДереваЗначений"));

	Если ЭтоСтрокиДереваЗначений и КоллекцияКолонокДереваЗначений = Неопределено тогда
		Возврат Неопределено;
	Конецесли;

	Если ЗначениеНеЗаполнено(Реквизиты) тогда

		Если ЭтоТаблицаЗначений тогда

			НоваяТЗ = Источник.Скопировать();

			Возврат НоваяТЗ;

		ИначеЕсли ЭтоСтрокиДереваЗначений тогда

			Реквизиты = Новый Структура();

			Для каждого Колонка из КоллекцияКолонокДереваЗначений цикл
				Реквизиты.Вставить(Колонка.Имя);
			КонецЦикла;

		Иначе

			НоваяТЗ = Источник.Выгрузить();
			Возврат НоваяТЗ;

		КонецЕслИ;

	Конецесли;

	Если НЕ ЭтоТаблицаЗначений И НЕ ЭтоСтрокиДереваЗначений тогда
		РеквизитыТабличнойЧасти = Метаданные.НайтиПоТипу(ТипЗнч(Источник)).Реквизиты;
	Конецесли;

	НоваяТЗ = Новый ТаблицаЗначений();

	Если не ЭтоТаблицаЗначений и ПолучитьНомерСтрокиДокумента тогда
		НоваяТЗ.Колонки.Добавить("НомерСтрокиДокумента",ПолучитьОписаниеТиповЧисла(5,0));
	КонецЕсли;

	Пока НоваяТЗ.Количество()<Источник.Количество() Цикл

		Строка = НоваяТЗ.Добавить();

		Если не ЭтоТаблицаЗначений и ПолучитьНомерСтрокиДокумента тогда
			Строка.НомерСтрокиДокумента = НоваяТЗ.Количество();
		КонецЕсли;

	КонецЦикла;

	Для каждого ТекРеквизит из Реквизиты Цикл

		ИскомыйРеквизит = ТекРеквизит.Ключ;
		НовыйРеквизит   = ?(ТекРеквизит.Значение = Неопределено,ТекРеквизит.Ключ,ТекРеквизит.Значение);

		Если ЭтоТаблицаЗначений тогда
			ИсточникКолонка = Источник.Колонки.Найти(ИскомыйРеквизит);

		ИначеЕсли ЭтоСтрокиДереваЗначений тогда
			ИсточникКолонка = КоллекцияКолонокДереваЗначений.Найти(ИскомыйРеквизит);

		Иначе
			ИсточникКолонка = РеквизитыТабличнойЧасти.Найти(ИскомыйРеквизит);

		Конецесли;

		Если ИсточникКолонка= неопределено тогда

			//недостаточно реквизитов
			Если ФормироватьОтстутствующиеКолонки тогда
				НоваяТЗ.Колонки.Добавить(НовыйРеквизит);
			Иначе
				Возврат Неопределено;
			КонецЕсли;

		Иначе
			НоваяТЗ.Колонки.Добавить(НовыйРеквизит);
			НоваяТЗ.ЗагрузитьКолонку(Источник.ВыгрузитьКолонку(ИскомыйРеквизит),НовыйРеквизит);

		Конецесли;

	КонецЦикла;

	Возврат НоваяТЗ;

КонецФункции // СформироватьТаблицуЗначений()

Процедура ДополнитьКолонкиТаблицыЗначений(ТаблицаБазовая,ТаблицаДополнений) Экспорт

	Для каждого Колонка из ТаблицаДополнений.Колонки Цикл

		Если Не(ТаблицаБазовая.Колонки.Найти(Колонка.Имя) = Неопределено) тогда
			//Колонка уже есть
			Продолжить;
		КонецЕсли;

		ТаблицаБазовая.Колонки.Добавить(Колонка.Имя,Колонка.ТипЗначения,Колонка.Заголовок,Колонка.Ширина);

	КонецЦикла;

КонецПроцедуры

// Добавляет в таблицу значений строки из другой таблицы значений и 
// в них значения колонок с совпадающими наименованиями.
//
// Параметры:
//  ТаблицаИсточник - таблица значений, откуда берутся значения.
//  ТаблицаПриемник - таблица значений, куда добавляются строки.
//
Процедура ЗагрузитьВТаблицуЗначений(ТаблицаИсточник, ТаблицаПриемник) Экспорт

	Для каждого СтрокаТаблицыИсточника Из ТаблицаИсточник Цикл

		СтрокаТаблицыПриемника = ТаблицаПриемник.Добавить();
		ЗаполнитьЗначенияСвойств(СтрокаТаблицыПриемника, СтрокаТаблицыИсточника);

	КонецЦикла;

КонецПроцедуры // ЗагрузитьВТаблицуЗначений()

//Процедура для распределения записей из одной таблицы значений по базису (таблица значений или  набору записей)
//Источник 		: ТаблицаЗначений
//Базис 		: ТаблицаЗначений или НаборЗаписей
//Распределение : ключ - поля базиса, значение - поля источника
//Фильтр 		: ключ - поля базиса, значение - поля источника (если не укзан - по совпадающим колонкам)
//Игнорировать  : ключ - поля базиса, значение - поля источника
//Дополнить		: ключ - имя нового поля базиса, значение - значение для заполнения
Функция СформироватьКорректирующиеЗаписи(Источник,Базис,Распределение,Фильтр=неопределено,Игнорировать=Неопределено,Дополнить=Неопределено) Экспорт

	Если ТипЗнч(Базис) = Тип("ТаблицаЗначений") тогда
		Временный_Базис = Базис.Скопировать();

	Иначе
		Временный_Базис = Базис.Выгрузить();

	Конецесли;

	КолонкиИсточника = Новый Структура();

	Для Каждого Колонка Из источник.Колонки Цикл
		КолонкиИсточника.Вставить(Колонка.Имя);
	КонецЦикла;

	КолонкиБазиса = Новый Структура();

	Для Каждого Колонка Из Временный_Базис.Колонки Цикл

		Если Не(ЗначениеНеЗаполнено(Колонка.Имя)) тогда
			КолонкиБазиса.Вставить(Колонка.Имя);
		КонецЕсли;

	КонецЦикла;

	Если НЕ (ТипЗнч(Игнорировать) = Тип("Структура")) Тогда
		Игнорировать = Новый Структура();
	Иначе

		//Зачистим колонки источника и базиса на игнорируемые колонки
		Для Каждого Колонка Из Игнорировать Цикл

			Если КолонкиИсточника.Свойство(?(ЗначениеНеЗаполнено(Колонка.Значение),Колонка.Ключ,Колонка.Значение)) тогда
				КолонкиИсточника.Удалить(?(ЗначениеНеЗаполнено(Колонка.Значение),Колонка.Ключ,Колонка.Значение));
			Конецесли;

			Если КолонкиБазиса.Свойство(Колонка.Ключ) тогда
				КолонкиБазиса.Удалить(Колонка.Ключ);
			Конецесли;

		КонецЦикла;

	КонецЕсли;

	//Зачистим колонки источника на распределяемые колонки. Они учитываются отдельно.
	Для Каждого Колонка Из Распределение Цикл
		Если КолонкиИсточника.Свойство(?(ЗначениеНеЗаполнено(Колонка.Значение),Колонка.Ключ,Колонка.Значение)) тогда
			 КолонкиИсточника.Удалить(?(ЗначениеНеЗаполнено(Колонка.Значение),Колонка.Ключ,Колонка.Значение));
		Иначе
			 Если Источник.Колонки.Найти(?(ЗначениеНеЗаполнено(Колонка.Значение),Колонка.Ключ,Колонка.Значение))=Неопределено тогда
				 //Не хватает колонок к распределению
				 //Но одну и ту же колонку можно распределить дважды
				 Возврат ложь;
			 КонецЕсли;
		Конецесли;
		Если КолонкиБазиса.Свойство(Колонка.Ключ) тогда
			 КолонкиБазиса.Удалить(Колонка.Ключ);
		Иначе
			  //Не хватает колонок базиса распределения
			 Возврат ложь;
		Конецесли;
	КонецЦикла;
	
	Если (ТипЗнч(Дополнить) = Тип("Структура"))
	   И НЕ (Дополнить.Количество() = 0) Тогда
		//Проверим на отсутствие дополняемых колонок!
		Для Каждого Колонка Из Дополнить Цикл
			Если КолонкиБазиса.Свойство(Колонка.Ключ) тогда
				//Такая колонка уже есть, нельзя добавить новую
				Возврат Ложь;
			Конецесли;
		КонецЦикла;
 	КонецЕсли;
	
	//Если фильтр не задан - по всем совпадающим колонкам
	Если Фильтр=Неопределено тогда
		Фильтр = Новый Структура();
		Для каждого Колонка из КолонкиБазиса цикл
			Если КолонкиИсточника.Свойство(Колонка.Ключ)  и не(Игнорировать.Свойство(Колонка.Ключ)) тогда
				Фильтр.Вставить(Колонка.Ключ);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Если НЕ (ТипЗнч(Фильтр) = Тип("Структура") И НЕ (Фильтр.Количество() = 0)) Тогда
		//Должно быть хоть одно объединяющее поле!
		Возврат Ложь;
	КонецЕсли;
	
	Для Каждого Колонка Из Фильтр Цикл
		Если не КолонкиБазиса.Свойство(Колонка.Ключ) тогда
			  //Не хватает колонок базиса распределения
			 Возврат ложь;
		Конецесли;
	КонецЦикла;
	
	//Подготовить сворачивание для источника
	СтрокаСверткиИсточник = ВыгрузитьСтруктуруВСтроку(Фильтр,Истина,КолонкиИсточника);
	Если СтрокаСверткиИсточник = ложь Тогда
		//попытка фильтровать по полю, отсутствующему в источнике!
		Возврат ложь;
	КонецЕсли;
	КолонкиКРаспределениюИсточник = ВыгрузитьСтруктуруВСтроку(Распределение,Истина);
	Если КолонкиКРаспределениюИсточник = ложь Тогда
		//попытка распределить поле, отсутствующее в источнике!
		Возврат ложь;
	КонецЕсли;
	
	//Подготовить сворачивание для базиса
	СтрокаСверткиБазис = ВыгрузитьСтруктуруВСтроку(КолонкиБазиса,Ложь);
	Если СтрокаСверткиБазис = ложь Тогда
		//попытка фильтровать по полю, отсутствующему в базисе!
		Возврат ложь;
	КонецЕсли;
	КолонкиКРаспределениюБазис = ВыгрузитьСтруктуруВСтроку(Распределение,Ложь);
	Если КолонкиКРаспределениюБазис = ложь Тогда
		//попытка распределить поле, отсутствующее в базисе!
		Возврат ложь;
	КонецЕсли;
	
	Временный_Источник = Источник.Скопировать();
	
	Временный_Базис.Свернуть(СтрокаСверткиБазис,КолонкиКРаспределениюБазис);
	Временный_Источник.Свернуть(СтрокаСверткиИсточник,КолонкиКРаспределениюИсточник);
	
	НоваяТаблица = новый ТаблицаЗначений();
	Для каждого Колонка из Временный_Базис.Колонки Цикл
		НоваяТаблица.Колонки.Добавить(Колонка.Имя,Колонка.ТипЗначения,,10);
	КонецЦикла;
	
	ТаблицаБазисовРаспределения = Новый ТаблицаЗначений();
	Для каждого Колонка из Распределение Цикл
		ТаблицаБазисовРаспределения.Колонки.Добавить(Колонка.Ключ);
	КонецЦикла;
	
	Для каждого СтрокаИсточника из Временный_Источник цикл
		Отбор = новый структура();
		Для каждого Колонка из Фильтр цикл
			Отбор.Вставить(Колонка.Ключ,СтрокаИсточника[?(ЗначениеНеЗаполнено(Колонка.Значение),Колонка.Ключ,Колонка.Значение)]);
		КонецЦикла;
		СтрокиБазиса = Временный_Базис.НайтиСтроки(Отбор);
		ТаблицаБазисовРаспределения.Очистить();
		Для каждого Строка из СтрокиБазиса Цикл
			СтрокаТБР = ТаблицаБазисовРаспределения.Добавить();
			Для каждого Колонка из ТаблицаБазисовРаспределения.Колонки цикл
				СтрокаТБР[Колонка.Имя] = Строка[Колонка.Имя];
			КонецЦикла;
		КонецЦикла;
		Для каждого Колонка из Распределение цикл
			РаспределяемаяСумма =  СтрокаИсточника[?(ЗначениеНеЗаполнено(Колонка.Значение),Колонка.Ключ,Колонка.Значение)];
			МассивДляРаспределения = ТаблицаБазисовРаспределения.ВыгрузитьКолонку(Колонка.Ключ);
			МассивРезультата = РаспределитьПропорционально(РаспределяемаяСумма, МассивДляРаспределения);
			Если МассивРезультата = неопределено тогда
				ТаблицаБазисовРаспределения.ЗаполнитьЗначения(0,Колонка.Ключ);
			Иначе	
				ТаблицаБазисовРаспределения.ЗагрузитьКолонку(МассивРезультата,Колонка.Ключ);
			КонецЕсли;
			
		КонецЦикла;
		
		СтрокаРезультата = 0;
		Для каждого Строка из СтрокиБазиса Цикл
			СтрокаНовая = НоваяТаблица.Добавить();
			СрокаРекультатаРаспределения = ТаблицаБазисовРаспределения[СтрокаРезультата];
			СтрокаРезультата = СтрокаРезультата +1;
			Для каждого Колонка из Временный_Базис.Колонки цикл
				Если Распределение.Свойство(Колонка.Имя) тогда
					СтрокаНовая[Колонка.Имя] = СрокаРекультатаРаспределения[Колонка.Имя];
				Иначе
					СтрокаНовая[Колонка.Имя] = Строка[Колонка.Имя];
				КонецЕсли;
			КонецЦикла;
		КонецЦикла;
	КонецЦикла;
	
	Если (ТипЗнч(Дополнить) = Тип("Структура"))
	   И НЕ (Дополнить.Количество() = 0) Тогда
		Для Каждого Колонка Из Дополнить Цикл
			НоваяТаблица.Колонки.Добавить(Колонка.Ключ,,,10);
			НоваяТаблица.ЗаполнитьЗначения(Колонка.Значение,Колонка.Ключ);
		КонецЦикла;
	КонецЕсли;

	СтрокиС0Распределением = Новый Массив();

	Для каждого Строка из НоваяТаблица цикл

		СуммаРаспределений0 = Истина;

		Для каждого Колонка из распределение цикл
			Если не ЗначениеНеЗаполнено(Строка[Колонка.Ключ]) тогда
				СуммаРаспределений0=Ложь;
				Прервать;
			КонецЕсли;
		КонецЦикла;

		Если СуммаРаспределений0 тогда
			СтрокиС0Распределением.Добавить(Строка);
		Конецесли;

	КонецЦикла;

	Для каждого ПустаяСтрока из СтрокиС0Распределением Цикл 
		НоваяТаблица.Удалить(ПустаяСтрока);
	КонецЦикла;

	//Если не ЗначениеНеЗаполнено(ИсключитьПослеРаспределения) тогда
	//	КолонкиРезультата = Новый Структура();
	//	Для каждого Колонка из НоваяТаблица.Колонки Цикл
	//		Если ИсключитьПослеРаспределения.Свойство(Колонка.Имя) = Истина  или Распределение.Свойство(Колонка.Имя) = Истина Тогда
	//			Продолжить;
	//		Иначе
	//			КолонкиРезультата.Вставить(Колонка.Имя);
	//		КонецЕсли;
	//	КонецЦикла;
	//	КолонкиКСворачиванию = ВыгрузитьСтруктуруВСтроку(КолонкиРезультата,Ложь);
	//	НоваяТаблица.Свернуть(КолонкиКСворачиванию,КолонкиКРаспределениюБазис);
	//КонецЕсли;
	
	Возврат НоваяТаблица;

КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С СТРУКТУРАМИ

Функция ВыгрузитьСтруктуруВСтроку(Структура,ПоЗначениям = Ложь,СтруктураПроверки = Неопределено) Экспорт

	НеПроверять = (СтруктураПроверки = Неопределено);
	НоваяСтрока = "";

	Для каждого Колонка из Структура Цикл

		Если НеПроверять тогда
			НоваяСтрока = НоваяСтрока + ?(ЗначениеНеЗаполнено(Колонка.Значение)или не ПоЗначениям,Колонка.Ключ,Колонка.Значение)+",";

		ИначеЕсли СтруктураПроверки.Свойство(?(ЗначениеНеЗаполнено(Колонка.Значение) или не ПоЗначениям,Колонка.Ключ,Колонка.Значение)) тогда
			НоваяСтрока = НоваяСтрока + ?(ЗначениеНеЗаполнено(Колонка.Значение),Колонка.Ключ,Колонка.Значение)+",";

		Иначе
			//Нет в проверке!
			Возврат Ложь;

		КонецЕсли;

	КонецЦикла;

	Если не ЗначениеНеЗаполнено(НоваяСтрока) Тогда
		НоваяСтрока = Лев(НоваяСтрока,СтрДлина(НоваяСтрока)-1);
	КонецЕсли;

	Возврат НоваяСтрока;

КонецФункции // ВыгрузитьСтруктуруВСтроку

// Предназначена для получения пустого значения заданного типа:
//	примитивного, или ссылочного. Используется
//
// Параметры:
//	ЗаданныйТип   - тип, пустое значение которого нужно получить
//
Функция ПустоеЗначениеТипа(ЗаданныйТип) Экспорт

	Если ЗаданныйТип = Тип("Число") Тогда
		Возврат 0;

	ИначеЕсли ЗаданныйТип = Тип("Строка") Тогда
		Возврат "";

	ИначеЕсли ЗаданныйТип = Тип("Дата") Тогда
		Возврат '00010101000000';

	ИначеЕсли ЗаданныйТип = Тип("Булево") Тогда
		Возврат Ложь;

	Иначе
		Возврат Новый (ЗаданныйТип);

	КонецЕсли;

КонецФункции // ПустоеЗначениеТипа();

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ СО СТАВКАМИ НАЛОГОВ И ВЗНОСОВ

// Эта функция получает ставку взноса на страхование от несчастных случаев
//
// Параметры:      
//	Организация - СправочникСсылка.Организации - организация для которой нужно получить ставку
//	ДатаАктуальности - дата на которую нужно получить ставку
//
// Возвращаемое значение: 
//  Число - размер ставки, если ставка не задана - 0
//
Функция ПолучитьСтавкуВзносаНаСтрахованиеОтНесчастныхСлучаев(Организация, ДатаАктуальности) Экспорт

	Отбор = Новый Структура("Организация", Организация);

	Возврат РегистрыСведений.СтавкаВзносаНаСтрахованиеОтНесчастныхСлучаев.ПолучитьПоследнее(ДатаАктуальности, Отбор).Ставка/100;

КонецФункции // ПолучитьСтавкуВзносаНаСтрахованиеОтНесчастныхСлучаев

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ СО СЧЕТАМИ И СУБКОНТО

// Эта функция возвращает информацию о счете из переданного соответсвия
// Если в соответствии не найдена информация о счете - она подготавливается и 
// помещается в соответсвие
// Применяется для работы с формами в которых активно требуется получать 
// информащцию о счетах, например, при выводе строки табличного поля
//
// Параметры:      
//	СведенияОСчетах - соответсвие у котрого в качестве ключа - ПланСчетовСсылка, а 
//  				  в качестве значения - структура из 4-х элементов
//					  КоличествоСубконто - число
//                    ТипСубконто1 - описание типа
//                    ТипСубконто2 - описание типа
//                    ТипСубконто3 - описание типа
//					  ВидСубконто1Представление - представление вида субконто
//					  ВидСубконто2Представление - представление вида субконто
//					  ВидСубконто3Представление - представление вида субконто
//
//	Счет - ПланСчетовСсылка
//
// Возвращаемое значение:
//  Описанная выше структура
//
Функция ПолучитьСведенияОСчете(СведенияОСчетах, Счет) Экспорт

	СведенияОСчете = СведенияОСчетах[Счет];

	Если СведенияОСчете = Неопределено Тогда

		СведенияОСчете = Новый Структура("КоличествоСубконто, ВидСубконто1, ВидСубконто2, ВидСубконто3, ТипСубконто1, ТипСубконто2, ТипСубконто3, ВидСубконто1Представление, ВидСубконто2Представление, ВидСубконто3Представление");

		СведенияОСчете.КоличествоСубконто = Счет.ВидыСубконто.Количество();

		Если СведенияОСчете.КоличествоСубконто > 0 Тогда

			ВидСубконто = Счет.ВидыСубконто[0].ВидСубконто;

			СведенияОСчете.ВидСубконто1              = ВидСубконто;
			СведенияОСчете.ТипСубконто1              = ВидСубконто.ТипЗначения;
			СведенияОСчете.ВидСубконто1Представление = ВидСубконто.Наименование;

		КонецЕсли;

		Если СведенияОСчете.КоличествоСубконто > 1 Тогда

			ВидСубконто = Счет.ВидыСубконто[1].ВидСубконто;

			СведенияОСчете.ВидСубконто2              = ВидСубконто;
			СведенияОСчете.ТипСубконто2              = ВидСубконто.ТипЗначения;
			СведенияОСчете.ВидСубконто2Представление = ВидСубконто.Наименование;

		КонецЕсли;

		Если СведенияОСчете.КоличествоСубконто > 2 Тогда

			ВидСубконто = Счет.ВидыСубконто[2].ВидСубконто;

			СведенияОСчете.ВидСубконто3              = ВидСубконто;
			СведенияОСчете.ТипСубконто3              = ВидСубконто.ТипЗначения;
			СведенияОСчете.ВидСубконто3Представление = ВидСубконто.Наименование;

		КонецЕсли;

		СведенияОСчетах[Счет] = СведенияОСчете;

	КонецЕсли;

	Возврат СведенияОСчете;

КонецФункции  // ПолучитьСведенияОСчете

// Выполняет в табличном поле приведение значений субконто к типу, соответствующему счету
// сведения о счете передаются через параметр СведенияОСчете
// используется для табличных полей, содержащих колонки типа Счет и соответствующие ему субконто
//
// Параметры:
//	ТабличноеПоле 	- табличное поле 
//  ДтКт 			- строка "Дт", "Кт" или "" - часть имени колонки табличного поля
// 					для колонок табличного поля поддерживаются имена 
//					типа СубконтоДт1, СубконтоКт1, Субконто1...
//  СведенияОСчете 	- структура
//					  КоличествоСубконто - число
//                    ТипСубконто1 - описание типа
//                    ТипСубконто2 - описание типа
//                    ТипСубконто3 - описание типа
//					  ВидСубконто1Представление - представление вида субконто - в данной процедуре не используется
//					  ВидСубконто2Представление - представление вида субконто - в данной процедуре не используется
//					  ВидСубконто3Представление - представление вида субконто - в данной процедуре не используется
//
Процедура ПривестиЗначениеСубконто(ТабличноеПоле, ДтКт, СведенияОСчете) Экспорт

	Для СчетчикСубконто = 1 По 3 Цикл

		Если СведенияОСчете.КоличествоСубконто >= СчетчикСубконто Тогда
			ТабличноеПоле.ТекущиеДанные["Субконто"+ДтКт+СчетчикСубконто] = СведенияОСчете["ТипСубконто"+СчетчикСубконто].ПривестиЗначение(ТабличноеПоле.ТекущиеДанные["Субконто"+ДтКт+СчетчикСубконто]);

		Иначе
			ТабличноеПоле.ТекущиеДанные["Субконто"+ДтКт+СчетчикСубконто] = Неопределено;

		КонецЕсли;

	КонецЦикла;

КонецПроцедуры   // ПривестиЗначениеСубконто

// Назначает видимость ячейкам строки табличного поля, соответствующим субконто
// в зависимлсти от счета. Сведения о счете передаются через параметр СведенияОСчете
// Используется для табличных полей, содержащих колонки типа Счет и соответствующие ему субконто
// при выводе строки
//
// Параметры:
//	ОформлениеСтроки 	- оформление строки
//  ДтКт 				- строка "Дт", "Кт" или "" - часть имени колонки табличного поля
// 						для колонок табличного поля поддерживаются имена 
//						типа СубконтоДт1, СубконтоКт1, Субконто1...
//  СведенияОСчете 		- структура
//					  	КоличествоСубконто - число
//                    	ТипСубконто1 - описание типа
//                    	ТипСубконто2 - описание типа
//                    	ТипСубконто3 - описание типа
//					    ВидСубконто1Представление - представление вида субконто - в данной процедуре не используется
//					    ВидСубконто2Представление - представление вида субконто - в данной процедуре не используется
//					    ВидСубконто3Представление - представление вида субконто - в данной процедуре не используется
//
Процедура НазначитьВидимостьСубконто(ОформлениеСтроки, ДтКт, СведенияОСчете) Экспорт

	Для СчетчикСубконто = 1 По 3 Цикл
		ОформлениеСтроки.Ячейки["Субконто"+ДтКт+СчетчикСубконто].Видимость = СведенияОСчете.КоличествоСубконто >= СчетчикСубконто;
		ОформлениеСтроки.Ячейки["Субконто"+ДтКт+СчетчикСубконто].ТолькоПросмотр = НЕ СведенияОСчете.КоличествоСубконто >= СчетчикСубконто;
	КонецЦикла;

КонецПроцедуры

// Функция применяется при необходимости получить сведения об учетной политике организации.
//
// Параметры:
// Учет - строка. Определяет регистр сведений, из которого будут получены данные:
//    "БухгалтерскийУчет".
//
// Возвращаемое значение - таблица значений. Таблица, каждая строка которой 
//  соответствует записи регистра. 
//
Функция СоздатьКЭШУчетнойПолитики(Учет) Экспорт
	
	Запрос = Новый Запрос();
	
	Запрос.Текст = 
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	*
	|ИЗ
	|	РегистрСведений.УчетнаяПолитика" + Учет +" КАК УчетнаяПолитика" + Учет;
	
	УчетнаяПолитика = Запрос.Выполнить().Выгрузить();
	УчетнаяПолитика.Сортировать("Период");
	
	Возврат УчетнаяПолитика;
	
КонецФункции

// Функция возвращает структуру с параметрами учетной политики на заданную дату.
//
Функция ПолучитьПараметрыУчетнойПолитики(КонДата, Отказ, Организация) Экспорт
	
	СтруктураУчПолитика = Новый Структура;
			
	//Если ЗначениеНеЗаполнено(Организация) Тогда
	//	
	//Отказ = Истина;
	//Возврат СтруктураУчПолитика;	
	//	
	//КонецЕсли;
	//
	//Если ЗначениеНеЗаполнено(КонДата) Тогда
	//	
	//	Отказ = Истина;
	//	Возврат СтруктураУчПолитика;	
	//	
	//КонецЕсли;

	//УчетнаяПолитика = ПараметрыСеанса.УчетнаяПолитикаПоБухгалтерскомуУчету.Получить();
	//	
	//УчетнаяПолитикаОрганизации = УчетнаяПолитика.НайтиСтроки(Новый Структура("Организация", Организация));
	//	
	//Если УчетнаяПолитикаОрганизации.Количество() = 0 Тогда
	//	Отказ = Истина;
	//	СообщитьОбОшибке("Не указаны параметры учетной политики бухгалтерского учета ("+СокрЛП(Организация)+") на " + Формат(КонДата, "ДЛФ=DD"), Отказ);
	//	Возврат СтруктураУчПолитика;	
	//Иначе
	//		
	//	Номер = 0;
	//	ФлагОтказа = Истина;
	//	Для НомерСтроки = 1 По УчетнаяПолитикаОрганизации.Количество() Цикл
	//			
	//		Строка = УчетнаяПолитикаОрганизации.Получить(НомерСтроки - 1);
	//		Если Строка.Период <= КонДата Тогда
	//			Номер = НомерСтроки;
	//			ФлагОтказа = Ложь;
	//				
	//		Иначе 
	//			Прервать;
	//		КонецЕсли;
	//	КонецЦикла;
	//		
	//	Если Номер <> 0 Тогда
	//		Строка = УчетнаяПолитикаОрганизации.Получить(Номер - 1);
	//		Для Каждого Колонка Из УчетнаяПолитика.Колонки Цикл
	//			СтруктураУчПолитика.Вставить(Колонка.Имя, Строка[Колонка.Имя]);
	//		КонецЦикла;
	//		
	//		Если КонДата>= '20060101' и СтруктураУчПолитика.Свойство("МоментОпределенияНалоговойБазыНДС") и СтруктураУчПолитика.МоментОпределенияНалоговойБазыНДС = Перечисления.МоментыОпределенияНалоговойБазыНДС.ПоОплате Тогда			
	//			СтруктураУчПолитика.Вставить("МоментОпределенияНалоговойБазыНДС", Перечисления.МоментыОпределенияНалоговойБазыНДС.ПоОтгрузке);
	//		КонецЕсли; 
	//			
	//	КонецЕсли;
	//		
	//КонецЕсли;
	//	
	//Если  ФлагОтказа = Истина Тогда
	//		СообщитьОбОшибке("Не указаны параметры учетной политики бухгалтерского учета ("+СокрЛП(Организация)+") на " + Формат(КонДата, "ДЛФ=DD"), Отказ);
	//		Возврат СтруктураУчПолитика;	
	//	КонецЕсли; 
	//	
	Возврат СтруктураУчПолитика;
		
КонецФункции // ПолучитьПараметрыУчетнойПолитики()
////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ИНТЕРНЕТ-ПОДДЕРЖКИ ПОЛЬЗОВАТЕЛЕЙ

#Если Клиент Тогда
// Производит проверку наличия комплекта обновления и 
// открывает форму для просмотра результатов проверки
Процедура ПроверкаНаличияКомплектаОбновлений() Экспорт

	Обозреватель = Обработки.Обозреватель.Создать();
	Форма        = Обозреватель.ПолучитьФорму("ПроверкаНаличияОбновления");

	Обозреватель.Проверить(Форма.ЭлементыФормы);

	Форма.Открыть();

КонецПроцедуры
#КонецЕсли

// Получаем из полного номера версии конфигурации номер релиза без номера сборки.
//
// Параметры
//  НомерВерсии  – Строка – полный номер версии
//
// Возвращаемое значение:
//  Строка – номер релиза без номера сборки
//
Функция ПолучитьНомерРелиза(НомерВерсии) Экспорт

	КоличествоТочек = 0;
	ДлинаОписанияНомераРелиза = 0;

	Для х = 1 По СтрДлина(НомерВерсии) Цикл

		Если Сред(НомерВерсии, х, 1) = "." Тогда
			КоличествоТочек = КоличествоТочек + 1;
		КонецЕсли;

		Если КоличествоТочек = 3 Тогда
			ДлинаОписанияНомераРелиза = х - 1;
			Прервать;
		КонецЕсли;

	КонецЦикла;

	Возврат Лев(НомерВерсии, ДлинаОписанияНомераРелиза);

КонецФункции // ПолучитьНомерРелиза()

Функция ПрименениеПБУ18(Организация, Знач Дата) Экспорт

	Если ЗначениеНеЗаполнено(Организация) Тогда
		Возврат Ложь;
	КонецЕсли;
	Если ЗначениеНеЗаполнено(Дата) Тогда
		Дата = ТекущаяДата();
	КонецЕсли;

	УчетнаяПолитика = ПолучитьПараметрыУчетнойПолитики(Дата, Ложь, Организация);
	Если УчетнаяПолитика.Количество() = 0 Тогда
		Возврат Ложь;
	Иначе
		Возврат УчетнаяПолитика.ПоддержкаПБУ18;
	КонецЕсли;

КонецФункции

// Определяет, установлена ли поддержка ПБУ 18/02.
//
// Параметры:
//  Организация  - Справочник.Ссылка - Организация, по которой
//                 определяется поддержка ПБУ 18/02
//  Дата         - Дата - Дата, на которую получаются сведения
//
// Возвращаемое значение:
//  Булево.
//
Функция ПоддержкаПБУ18(Организация, Знач Дата) Экспорт

	Если ЗначениеНеЗаполнено(Организация) Тогда
		Возврат Ложь;
	КонецЕсли;
	Если ЗначениеНеЗаполнено(Дата) Тогда
		Дата = ТекущаяДата();
	КонецЕсли;

	УчетнаяПолитика = ПолучитьПараметрыУчетнойПолитики(Дата, Ложь, Организация);
	Если УчетнаяПолитика.Количество() = 0 Тогда
		Возврат Истина;
	Иначе
		Возврат УчетнаяПолитика.ПоддержкаПБУ18;
	КонецЕсли;

КонецФункции // ПоддержкаПБУ18()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ЗАПОЛНЕНИЯ РЕКВИЗИТОВ В ФОРМЕ

// Процедура предназначена для заполнения общих реквизитов документов,
// вызывается в обработчиках событий "ПриОткрытии" в модулех форм всех документов.
//
// Параметры:
//  ДокументОбъект                 - объект редактируемого документа,
//  ТекПользователь                - ссылка на справочник, определяет текущего пользователя  
//  ВалютаРегламентированногоУчета - валюта регламентированного учета
//  ТипОперации                    - необязаетельный, строка вида операции ("Покупка" или "Продажа"),
//                                   если не передан, то реквизиты, зависящие от вида операции, не заполняются
//
Процедура ЗаполнитьШапкуДокумента(ДокументОбъект, ТекПользователь, ВалютаРегламентированногоУчета = Неопределено, ТипОперации = "") Экспорт

	Перем ТипЦен;

	МетаданныеДокумента = ДокументОбъект.Метаданные();

	Если ЕстьРеквизитДокумента("ОтражатьПоБУ", МетаданныеДокумента) Тогда

		ДокументОбъект.ОтражатьПоБУ = истина;//НЕ ПолучитьЗначениеПоУмолчанию(ТекПользователь, "НеОтражатьДокументыВБухгалтерскомУчете");

	КонецЕсли;

	Если ЕстьРеквизитДокумента("Организация", МетаданныеДокумента) 
	  И (ЗначениеНеЗаполнено(ДокументОбъект.Организация)) Тогда
		ДокументОбъект.Организация = ПолучитьЗначениеПоУмолчанию(ТекПользователь, "ОсновнаяОрганизация");
	КонецЕсли;

	Если ЕстьРеквизитДокумента("БанковскийСчет", МетаданныеДокумента) 
	  И (ЗначениеНеЗаполнено(ДокументОбъект.БанковскийСчет)) Тогда
		ДокументОбъект.БанковскийСчет = ПолучитьЗначениеПоУмолчанию(ТекПользователь, "ОсновнаяОрганизация").ОсновнойБанковскийСчет;
	КонецЕсли;

	Если ЕстьРеквизитДокумента("ПодразделениеОрганизации", МетаданныеДокумента)
	   И (ЗначениеНеЗаполнено(ДокументОбъект.ПодразделениеОрганизации)) Тогда
		ДокументОбъект.ПодразделениеОрганизации = ПолучитьЗначениеПоУмолчанию(ТекПользователь, "ОсновноеПодразделениеОрганизации");
	КонецЕсли;
	
	Если ЕстьРеквизитДокумента("СтруктурнаяЕдиница", МетаданныеДокумента)
	   И ЗначениеНеЗаполнено(ДокументОбъект.СтруктурнаяЕдиница) 
	   И ЕстьРеквизитДокумента("Организация", МетаданныеДокумента) Тогда
		ДокументОбъект.СтруктурнаяЕдиница = ДокументОбъект.Организация.ОсновнойБанковскийСчет;
	КонецЕсли;

	Если ЕстьРеквизитДокумента("Ответственный", МетаданныеДокумента) Тогда
	  //ДокументОбъект.Ответственный = ПолучитьЗначениеПоУмолчанию(ТекПользователь, "ОсновнойОтветственный");
	  ДокументОбъект.Ответственный = ТекПользователь;
	КонецЕсли;

	Если ЕстьРеквизитДокумента("ВидОперации", МетаданныеДокумента)
	   И (ЗначениеНеЗаполнено(ДокументОбъект.ВидОперации)) Тогда
		ДокументОбъект.ВидОперации = Перечисления[ДокументОбъект.ВидОперации.Метаданные().Имя][0];
	КонецЕсли;

	Если ЕстьРеквизитДокумента("Склад", МетаданныеДокумента)
	   И (ЗначениеНеЗаполнено(ДокументОбъект.Склад)) Тогда
		ДокументОбъект.Склад = ПолучитьЗначениеПоУмолчанию(ТекПользователь, "ОсновнойСклад");
	КонецЕсли;

	Если ЕстьРеквизитДокумента("СкладОрдер", МетаданныеДокумента)
	   И ЗначениеНеЗаполнено(ДокументОбъект.СкладОрдер) Тогда
		ДокументОбъект.СкладОрдер = ПолучитьЗначениеПоУмолчанию(ТекПользователь, "ОсновнойСклад");
	КонецЕсли;

	Если ЕстьРеквизитДокумента("СтавкаНДС", МетаданныеДокумента)
	   И (ЗначениеНеЗаполнено(ДокументОбъект.СтавкаНДС)) Тогда
		ДокументОбъект.СтавкаНДС = ПолучитьЗначениеПоУмолчанию(ТекПользователь, "ОсновнаяСтавкаНДС");
	КонецЕсли;

	Если ЕстьРеквизитДокумента("БанковскийСчет", МетаданныеДокумента)
	   И ЗначениеНеЗаполнено(ДокументОбъект.БанковскийСчет) Тогда
		ДокументОбъект.БанковскийСчет = ДокументОбъект.Организация.ОсновнойБанковскийСчет;
		Если ЕстьРеквизитДокумента("ВалютаДокумента", МетаданныеДокумента) Тогда
			ДокументОбъект.ВалютаДокумента = ДокументОбъект.Организация.ОсновнойБанковскийСчет.ВалютаДенежныхСредств;
		КонецЕсли;
	КонецЕсли;

	Если ЕстьРеквизитДокумента("СчетОрганизации", МетаданныеДокумента)
	   И ЗначениеНеЗаполнено(ДокументОбъект.СчетОрганизации) Тогда
		ДокументОбъект.СчетОрганизации = ДокументОбъект.Организация.ОсновнойБанковскийСчет;
		ДокументОбъект.ВалютаДокумента = ДокументОбъект.Организация.ОсновнойБанковскийСчет.ВалютаДенежныхСредств;
	КонецЕсли;

	Если ЕстьРеквизитДокумента("ВалютаДокумента", МетаданныеДокумента)
	   И (ЗначениеНеЗаполнено(ДокументОбъект.ВалютаДокумента)) Тогда
		ДокументОбъект.ВалютаДокумента = ВалютаРегламентированногоУчета;
	КонецЕсли;

	Если ЕстьРеквизитДокумента("КурсДокумента", МетаданныеДокумента)
	   И (ЗначениеНеЗаполнено(ДокументОбъект.КурсДокумента)) Тогда
	    СтруктураКурсаДокумента      = ПолучитьКурсВалюты(ДокументОбъект.ВалютаДокумента, ДокументОбъект.Дата);
		ДокументОбъект.КурсДокумента = СтруктураКурсаДокумента.Курс;

		Если ЕстьРеквизитДокумента("КратностьДокумента", МетаданныеДокумента) Тогда
			ДокументОбъект.КратностьДокумента = СтруктураКурсаДокумента.Кратность;
		КонецЕсли;
	КонецЕсли;

	// Если тип цен оказался не заполненным, то берем его из установок пользователя
	Если ЕстьРеквизитДокумента("ТипЦен", МетаданныеДокумента)
	   И (ЗначениеНеЗаполнено(ДокументОбъект.ТипЦен)) Тогда
		Если ТипОперации = "Продажа" Тогда
			ДокументОбъект.ТипЦен = ПолучитьЗначениеПоУмолчанию(ТекПользователь, "ОсновнойТипЦенПродажи");
		КонецЕсли;
	КонецЕсли;

	Если (ЕстьРеквизитДокумента("ТипЦен", МетаданныеДокумента))
	   И (Не ЗначениеНеЗаполнено(ДокументОбъект.ТипЦен)) Тогда

		// Если ТипЦен - элемент справочника ТипыЦенНоменклатуры и цены выбранного типа расчетные, 
		// то флаги включения налогов надо брать из базовой цены
		ТипЦен = ДокументОбъект.ТипЦен;

		// Флаги учета налогов заполняем, только если флаг УчитыватьНДС не заполнен.
		Если ЕстьРеквизитДокумента("УчитыватьНДС", МетаданныеДокумента) 
		   И (Не ДокументОбъект.УчитыватьНДС) Тогда

			ДокументОбъект.УчитыватьНДС     = Истина;
			ДокументОбъект.СуммаВключаетНДС = ТипЦен.ЦенаВключаетНДС;

		КонецЕсли; 
		
	Иначе

		// Заполним значениями по умолчанию (нет, либо не заполнен ТипЦен).
		// Флаги учета налогов заполняем, только если флаг УчитыватьНДС не заполнен.
		Если ЕстьРеквизитДокумента("УчитыватьНДС", МетаданныеДокумента) 
		   И (Не ДокументОбъект.УчитыватьНДС) Тогда

			ДокументОбъект.УчитыватьНДС     = Истина;
			ДокументОбъект.СуммаВключаетНДС = Истина;
		КонецЕсли; 
	КонецЕсли;

	Если ЕстьРеквизитДокумента("ЗанимаемыхСтавок", МетаданныеДокумента)
	   И (ЗначениеНеЗаполнено(ДокументОбъект.ЗанимаемыхСтавок)) Тогда
		ДокументОбъект.ЗанимаемыхСтавок = 1;
	КонецЕсли;

	Если ЕстьРеквизитДокумента("ДатаС", МетаданныеДокумента)
	   И (ЗначениеНеЗаполнено(ДокументОбъект.ДатаС)) Тогда
		ДокументОбъект.ДатаС = ДокументОбъект.Дата;
	КонецЕсли;
	
	# Если Клиент Тогда

	Если ЕстьРеквизитДокумента("ПериодРегистрации", МетаданныеДокумента)
	   И (ЗначениеНеЗаполнено(ДокументОбъект.ПериодРегистрации)) Тогда
		ДокументОбъект.ПериодРегистрации = НачалоМесяца(РабочаяДата);
	КонецЕсли;

	#КонецЕсли

КонецПроцедуры // ЗаполнитьШапкуДокумента()

	
// Процедура предназначена для заполнения общих реквизитов документов по документу основанию,
//	вызывается в обработчиках событий "ОбработкаЗаполнения" в модулях документов.
//
// Параметры:
//  ДокументОбъект  - объект редактируемого документа,
//  ДокументОснование - объект документа основания
//
Процедура ЗаполнитьШапкуДокументаПоОснованию(ДокументОбъект, ДокументОснование) Экспорт

	МетаданныеДокумента          = ДокументОбъект.Метаданные();
	МетаданныеДокументаОснования = ДокументОснование.Метаданные();

	// Организация.
	Если ЕстьРеквизитДокумента("Организация", МетаданныеДокумента)
	   И ЕстьРеквизитДокумента("Организация", МетаданныеДокументаОснования) Тогда
		ДокументОбъект.Организация = ДокументОснование.Организация;
	КонецЕсли;

	// Склад.
	Если ЕстьРеквизитДокумента("Склад", МетаданныеДокумента)
	   И ЕстьРеквизитДокумента("Склад", МетаданныеДокументаОснования) Тогда
		ДокументОбъект.Склад = ДокументОснование.Склад;
	КонецЕсли;

	// Контрагент.
	Если ЕстьРеквизитДокумента("Контрагент", МетаданныеДокумента)
	   И ЕстьРеквизитДокумента("Контрагент", МетаданныеДокументаОснования) Тогда
		ДокументОбъект.Контрагент = ДокументОснование.Контрагент;
	КонецЕсли;

	// ДоговорКонтрагента.
	Если ЕстьРеквизитДокумента("ДоговорКонтрагента", МетаданныеДокумента)
	   И ЕстьРеквизитДокумента("ДоговорКонтрагента", МетаданныеДокументаОснования) 
	   И (НЕ ЕстьРеквизитДокумента("Организация", МетаданныеДокумента) 
	      ИЛИ ДокументОбъект.Организация = ДокументОснование.ДоговорКонтрагента.Организация) Тогда

		ДокументОбъект.ДоговорКонтрагента = ДокументОснование.ДоговорКонтрагента;

		// КурсВзаиморасчетов.
		Если ЕстьРеквизитДокумента("КурсВзаиморасчетов", МетаданныеДокумента) Тогда
			СтруктураКурсаВзаиморасчетов = ПолучитьКурсВалюты(ДокументОбъект.ДоговорКонтрагента.ВалютаВзаиморасчетов, ТекущаяДата());
			ДокументОбъект.КурсВзаиморасчетов = СтруктураКурсаВзаиморасчетов.Курс;

			// КратностьВзаиморасчетов.
			Если ЕстьРеквизитДокумента("КратностьВзаиморасчетов", МетаданныеДокумента) Тогда
				ДокументОбъект.КратностьВзаиморасчетов = СтруктураКурсаВзаиморасчетов.Кратность;
			КонецЕсли;
		КонецЕсли;

	КонецЕсли;

	// Банковский счет 
	Если ЕстьРеквизитДокумента("БанковскийСчет", МетаданныеДокумента) Тогда

		// Если в документе-основании есть структурная единица, то берем ее оттуда
		Если ЕстьРеквизитДокумента("СтруктурнаяЕдиница", МетаданныеДокументаОснования) Тогда
			Если Не ЗначениеНеЗаполнено(ДокументОснование.СтруктурнаяЕдиница) 
			   И ТипЗнч(ДокументОснование.СтруктурнаяЕдиница) = Тип("СправочникСсылка.БанковскиеСчета") Тогда
				ДокументОбъект.БанковскийСчет = ДокументОснование.СтруктурнаяЕдиница;
			КонецЕсли;
		ИначеЕсли ЕстьРеквизитДокумента("БанковскийСчет", МетаданныеДокументаОснования) Тогда
			Если Не ЗначениеНеЗаполнено(ДокументОснование.БанковскийСчет) Тогда
				ДокументОбъект.БанковскийСчет = ДокументОснование.БанковскийСчет;
			КонецЕсли;

		КонецЕсли;

	КонецЕсли;

	// ВалютаДокумента.
	Если ЕстьРеквизитДокумента("ВалютаДокумента", МетаданныеДокумента)
	   И ЕстьРеквизитДокумента("ВалютаДокумента", МетаданныеДокументаОснования) Тогда

		// Если есть касса или банковский счет, то валюта должна браться только оттуда
		Если ЕстьРеквизитДокумента("Касса", МетаданныеДокумента) Тогда
			Если Не ЗначениеНеЗаполнено(ДокументОбъект.Касса) Тогда
				ДокументОбъект.ВалютаДокумента = ДокументОбъект.Касса.ВалютаДенежныхСредств;
			КонецЕсли;
		ИначеЕсли ЕстьРеквизитДокумента("БанковскийСчет", МетаданныеДокумента) Тогда
			Если Не ЗначениеНеЗаполнено(ДокументОбъект.БанковскийСчет) Тогда
				ДокументОбъект.ВалютаДокумента = ДокументОбъект.БанковскийСчет.ВалютаДенежныхСредств;
		    КонецЕсли;
		Иначе
			ДокументОбъект.ВалютаДокумента = ДокументОснование.ВалютаДокумента;
		КонецЕсли;

		// КурсДокумента.
		Если ЕстьРеквизитДокумента("КурсДокумента", МетаданныеДокумента) Тогда
			СтруктураКурсаДокумента = ПолучитьКурсВалюты(ДокументОбъект.ВалютаДокумента, ТекущаяДата());
			ДокументОбъект.КурсДокумента = СтруктураКурсаДокумента.Курс;

			// КратностьДокумента.
			Если ЕстьРеквизитДокумента("КратностьДокумента", МетаданныеДокумента) Тогда
				ДокументОбъект.КратностьДокумента = СтруктураКурсаДокумента.Кратность;
			КонецЕсли;
		КонецЕсли;

	КонецЕсли;

	// ТипЦен.
	Если ЕстьРеквизитДокумента("ТипЦен", МетаданныеДокумента)
	   И ЕстьРеквизитДокумента("ТипЦен", МетаданныеДокументаОснования) Тогда
		ДокументОбъект.ТипЦен = ДокументОснование.ТипЦен;
	КонецЕсли;

	// УчитыватьНДС.
	Если ЕстьРеквизитДокумента("УчитыватьНДС", МетаданныеДокумента)
	   И ЕстьРеквизитДокумента("УчитыватьНДС", МетаданныеДокументаОснования) Тогда
		ДокументОбъект.УчитыватьНДС = ДокументОснование.УчитыватьНДС;
	КонецЕсли;

	// СуммаВключаетНДС.
	Если ЕстьРеквизитДокумента("СуммаВключаетНДС", МетаданныеДокумента)
	   И ЕстьРеквизитДокумента("СуммаВключаетНДС", МетаданныеДокументаОснования) Тогда
		ДокументОбъект.СуммаВключаетНДС = ДокументОснование.СуммаВключаетНДС;
	КонецЕсли;

КонецПроцедуры // ЗаполнитьШапкуДокументаПоОснованию()

// Функция формирует фамилию и инициалы
//
// Параметры
//  Фамилия  - фамилия физ. лица.
//  Имя      - имя физ. лица.
//  Отчество - отчество физ. лица.
//
// Возвращаемое значение 
//  Фамилия, имя, отчество одной строкой.
//
Функция ПолучитьФамилиюИмяОтчество(Фамилия = " ", Имя = " ", Отчество = " ") Экспорт

	Возврат ?(НЕ ПустаяСтрока(Фамилия), Фамилия + ?(НЕ ПустаяСтрока(Имя)," " + Лев(Имя,1) + "." + 
			?(НЕ ПустаяСтрока(Отчество) , 
			Лев(Отчество,1)+".", ""), ""), "");
КонецФункции // ПолучитьФамилиюИмяОтчество()
		
// <Описание функции>
//
// Параметры
//  <Параметр1>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>
//  <Параметр2>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>
//
// Возвращаемое значение:
//   <Тип.Вид>   – <описание возвращаемого значения>
//
Функция ПолучитьФИОСотрудника(Сотрудник,Дата)  Экспорт

	Запрос=новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	ФИОСотрудниковСрезПоследних.Фамилия,
	|	ФИОСотрудниковСрезПоследних.Имя,
	|	ФИОСотрудниковСрезПоследних.Отчество
	|ИЗ
	|	РегистрСведений.ФИОСотрудников.СрезПоследних(&Дата, Сотрудник = &Сотрудник) КАК ФИОСотрудниковСрезПоследних";
	
	Запрос.УстановитьПараметр("Сотрудник",Сотрудник);
	Запрос.УстановитьПараметр("Дата",Дата);
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	Если Выборка.Следующий() Тогда
		
		ФИО = Новый Структура("Фамилия, Имя, Отчество, Представление");
		Если НЕ (ЗначениеНеЗаполнено(Выборка.Фамилия) или Выборка.Фамилия = NULL) Тогда
			ФИО.Фамилия = Выборка.Фамилия;
		КонецЕсли;
		Если НЕ (ЗначениеНеЗаполнено(Выборка.Имя) или Выборка.Имя = NULL) Тогда
			ФИО.Имя = Выборка.Имя;
		КонецЕсли;
		Если НЕ (ЗначениеНеЗаполнено(Выборка.Отчество) или Выборка.Отчество = NULL) Тогда
			ФИО.Отчество = Выборка.Отчество;
		КонецЕсли;
		Возврат ПолучитьФамилиюИмяОтчество(ФИО.Фамилия, ФИО.Имя, ФИО.Отчество);
		
	КонецЕсли;
	
	Возврат "";


КонецФункции // ПолучитьФИОСотрудника()


Функция ПолучитьФИОФизЛица(ФизЛицо,Дата)  Экспорт

	Запрос=новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	ФИОФизЛицСрезПоследних.Фамилия,
	|	ФИОФизЛицСрезПоследних.Имя,
	|	ФИОФизЛицСрезПоследних.Отчество
	|ИЗ
	|	РегистрСведений.ФИОФизЛиц.СрезПоследних(&Дата, ФизЛицо = &ФизЛицо) КАК ФИОФизЛицСрезПоследних";
	
	Запрос.УстановитьПараметр("ФизЛицо",ФизЛицо);
	Запрос.УстановитьПараметр("Дата",Дата);
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	Если Выборка.Следующий() Тогда
		
		ФИО = Новый Структура("Фамилия, Имя, Отчество, Представление");
		Если НЕ (ЗначениеНеЗаполнено(Выборка.Фамилия) или Выборка.Фамилия = NULL) Тогда
			ФИО.Фамилия = Выборка.Фамилия;
		КонецЕсли;
		Если НЕ (ЗначениеНеЗаполнено(Выборка.Имя) или Выборка.Имя = NULL) Тогда
			ФИО.Имя = Выборка.Имя;
		КонецЕсли;
		Если НЕ (ЗначениеНеЗаполнено(Выборка.Отчество) или Выборка.Отчество = NULL) Тогда
			ФИО.Отчество = Выборка.Отчество;
		КонецЕсли;
		Возврат ПолучитьФамилиюИмяОтчество(ФИО.Фамилия, ФИО.Имя, ФИО.Отчество);
		
	КонецЕсли;
	
	Возврат "";


КонецФункции // 

// Функция собирает паспортные данные физ. лица на указанную дату
//
// Параметры: 
//  ФизЛицо.    - физ. лицо, для которго необходимо получить паспортные данные
//  ДатаПериода - дата получения сведений
//
// Возвращаемое значение:
//  Структура с паспортными данными.
//
Функция ПаспортныеДанные(ФизЛицо, ДатаПериода) Экспорт

	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("ПарФизЛицо",     ФизЛицо);
	Запрос.УстановитьПараметр("ПарДатаПериода", ДатаПериода);

	Запрос.Текст =
	"ВЫБРАТЬ
	|	ДокументВид        КАК Вид,
	|	ДокументСерия      КАК Серия,
	|	ДокументНомер      КАК Номер,
	|	ДокументДатаВыдачи КАК ДатаВыдачи,
	|	ДокументКемВыдан   КАК Выдан
	|ИЗ
	|	РегистрСведений.ПаспортныеДанныеФизЛиц.СрезПоследних(&ПарДатаПериода, ФизЛицо = &ПарФизЛицо)
	|ГДЕ
	|	ФизЛицо = &ПарФизЛицо";
	Шапка = Запрос.Выполнить().Выбрать();
	Если Шапка.Следующий() Тогда
		Результат = Новый Структура("Вид, Серия, Номер, ДатаВыдачи, Выдан");
		
		Результат.Вид        = Шапка.Вид;
		Результат.Серия      = Шапка.Серия;
		Результат.Номер      = Шапка.Номер;
		Результат.ДатаВыдачи = Шапка.ДатаВыдачи;
		Результат.Выдан      = Шапка.Выдан;
		
		Возврат Результат;
	Иначе
		Возврат Неопределено;
		
	КонецЕсли; 
	

КонецФункции // ПаспортныеДанные()

// Функция собирает сведения о 
//
// Параметры:
//  Организация - организация, для которой нужно определить руководящих лиц.
//
Функция ОтветственныеЛица(Организация, ДатаСреза) Экспорт

	
	СсылкаСотрудники=Справочники.Сотрудники.ПустаяСсылка();
	СсылкаДолжностиОрганизаций=Справочники.ДолжностиОрганизаций.ПустаяСсылка();
	
	Результат = Новый Структура("Руководитель, РуководительДолжность, РуководительФИО, РуководительПредставление, 
								|ГлавныйБухгалтер, ГлавныйБухгалтерФИО, ГлавныйБухгалтерПредставление, 
								|Кассир, КассирФИО, КассирПредставление,  
								|ОтветственныйЗаРегистры, ОтветственныйЗаРегистрыФИО, ОтветственныйЗаРегистрыПредставление,
								|ФинансовыйДиректор, ФинансовыйДиректорФИО, ФинансовыйДиректорПредставление,
								|НачальникЛогистики, НачальникЛогистикиФИО, НачальникЛогистикиПредставление,
								|ЗаместительРуководителяПоЭкономике, ЗаместительРуководителяПоЭкономикеФИО, ЗаместительРуководителяПоЭкономикеПредставление,
								|ЗаместительРуководителяПоКоммерческимВопросам, ЗаместительРуководителяПоКоммерческимВопросамФИО, ЗаместительРуководителяПоКоммерческимВопросамПредставление,
								|НачальникСнабжения, НачальникСнабженияФИО, НачальникСнабженияПредставление
								|,УправляющийДелами, УправляющийДеламиПредставление",
								СсылкаСотрудники,СсылкаДолжностиОрганизаций,,"",
								СсылкаСотрудники,,"",
								СсылкаСотрудники,,"",
								СсылкаСотрудники,,"",
								СсылкаСотрудники,,"",
								СсылкаСотрудники,,"",
								СсылкаСотрудники,,"",
								СсылкаСотрудники,,"",
								СсылкаСотрудники,,"",
								СсылкаСотрудники,"");

	Если Организация <> Неопределено тогда

		ЗапросПоЛицам = Новый Запрос();
		ЗапросПоЛицам.УстановитьПараметр("ДатаСреза",   ДатаСреза);
		ЗапросПоЛицам.УстановитьПараметр("Организация", Организация);
		ЗапросПоЛицам.УстановитьПараметр("ПризнакФизЛица",   Перечисления.ЮрФизЛицо.ФизЛицо);
		
		ЗапросПоЛицам.Текст = "ВЫБРАТЬ
		                      |	ФИОФизЛицСрезПоследних.Фамилия,
		                      |	ФИОФизЛицСрезПоследних.Имя,
		                      |	ФИОФизЛицСрезПоследних.Отчество,
		                      |	ФИОФизЛицСрезПоследних.ФизЛицо КАК ФизическоеЛицо
		                      |ИЗ
		                      |	РегистрСведений.ФИОФизЛиц.СрезПоследних(&ДатаСреза, ) КАК ФИОФизЛицСрезПоследних
		                      |		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.Организации КАК Организации
		                      |		ПО ФИОФизЛицСрезПоследних.ФизЛицо = Организации.ИндивидуальныйПредприниматель
		                      |			И (Организации.Ссылка = &Организация)
		                      |			И (Организации.ЮрФизЛицо = &ПризнакФизЛица)";
		
		Руководители = ЗапросПоЛицам.Выполнить().Выбрать();
		
		Пока Руководители.Следующий() Цикл
			
			ФИО = Новый Структура("Фамилия, Имя, Отчество, Представление");
			Если НЕ (ЗначениеНеЗаполнено(Руководители.Фамилия) или Руководители.Фамилия = NULL) Тогда
				ФИО.Фамилия = Руководители.Фамилия;
			КонецЕсли;
			Если НЕ (ЗначениеНеЗаполнено(Руководители.Имя) или Руководители.Имя = NULL) Тогда
				ФИО.Имя = Руководители.Имя;
			КонецЕсли;
			Если НЕ (ЗначениеНеЗаполнено(Руководители.Отчество) или Руководители.Отчество = NULL) Тогда
				ФИО.Отчество = Руководители.Отчество;
			КонецЕсли;
			Представление = ПолучитьФамилиюИмяОтчество(ФИО.Фамилия, ФИО.Имя, ФИО.Отчество);
			
			Результат.Руководитель               = Руководители.ФизическоеЛицо;
			Результат.РуководительДолжность      = "";
			Результат.РуководительФИО            = ФИО;
			Результат.РуководительПредставление  = Представление;
			
		КонецЦикла;
		
		ЗапросПоЛицам.Текст = 
		"ВЫБРАТЬ
		|	ОтветственныеЛицаОрганизацийСрезПоследних.ОтветственноеЛицо,
		|	ОтветственныеЛицаОрганизацийСрезПоследних.ФизическоеЛицо,
		|	ОтветственныеЛицаОрганизацийСрезПоследних.Должность,
		|	ФИОФизЛицСрезПоследних.Фамилия,
		|	ФИОФизЛицСрезПоследних.Имя,
		|	ФИОФизЛицСрезПоследних.Отчество,
		|	ФИОФизЛицСрезПоследних.ФизЛицо
		|ИЗ
		|	РегистрСведений.ОтветственныеЛицаОрганизаций.СрезПоследних(&ДатаСреза, СтруктурнаяЕдиница = &Организация) КАК ОтветственныеЛицаОрганизацийСрезПоследних
		|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.ФИОФизЛиц.СрезПоследних(&ДатаСреза, ) КАК ФИОФизЛицСрезПоследних
		|		ПО ОтветственныеЛицаОрганизацийСрезПоследних.ФизическоеЛицо.ФизическоеЛицо = ФИОФизЛицСрезПоследних.ФизЛицо";
		Руководители = ЗапросПоЛицам.Выполнить().Выбрать();

		Пока Руководители.Следующий() Цикл

			ФИО = Новый Структура("Фамилия, Имя, Отчество, Представление");
			Если НЕ (ЗначениеНеЗаполнено(Руководители.Фамилия) или Руководители.Фамилия = NULL) Тогда
				ФИО.Фамилия = Руководители.Фамилия;
			КонецЕсли;
			Если НЕ (ЗначениеНеЗаполнено(Руководители.Имя) или Руководители.Имя = NULL) Тогда
				ФИО.Имя = Руководители.Имя;
			КонецЕсли;
			Если НЕ (ЗначениеНеЗаполнено(Руководители.Отчество) или Руководители.Отчество = NULL) Тогда
				ФИО.Отчество = Руководители.Отчество;
			КонецЕсли;
			Представление = ПолучитьФамилиюИмяОтчество(ФИО.Фамилия, ФИО.Имя, ФИО.Отчество);
			
			Если Руководители.ОтветственноеЛицо      = Перечисления.ОтветственныеЛицаОрганизаций.Руководитель Тогда
				Результат.Руководитель               = Руководители.ФизическоеЛицо;
				Результат.РуководительДолжность      = Руководители.Должность;
				Результат.РуководительФИО            = ФИО;
				Результат.РуководительПредставление  = Представление;

			ИначеЕсли Руководители.ОтветственноеЛицо = Перечисления.ОтветственныеЛицаОрганизаций.ГлавныйБухгалтер Тогда
				Результат.ГлавныйБухгалтер           = Руководители.ФизическоеЛицо;
                Результат.ГлавныйБухгалтерФИО        = ФИО;
				Результат.ГлавныйБухгалтерПредставление  = Представление;
				
			ИначеЕсли Руководители.ОтветственноеЛицо = Перечисления.ОтветственныеЛицаОрганизаций.Кассир Тогда
				Результат.Кассир                     = Руководители.ФизическоеЛицо;
                Результат.КассирФИО            		 = ФИО;
				Результат.КассирПредставление  = Представление;
				
			ИначеЕсли Руководители.ОтветственноеЛицо = Перечисления.ОтветственныеЛицаОрганизаций.ОтветственныйЗаНалоговыеРегистры Тогда
				Результат.ОтветственныйЗаРегистры    = Руководители.ФизическоеЛицо;
				Результат.ОтветственныйЗаРегистрыФИО = ФИО;
				Результат.ОтветственныйЗаРегистрыПредставление  = Представление;
			ИначеЕсли Руководители.ОтветственноеЛицо = Перечисления.ОтветственныеЛицаОрганизаций.ФинансовыйДиректор Тогда
				Результат.ФинансовыйДиректор    = Руководители.ФизическоеЛицо;
				Результат.ФинансовыйДиректорФИО = ФИО;
				Результат.ФинансовыйДиректорПредставление  = Представление;
			ИначеЕсли Руководители.ОтветственноеЛицо = Перечисления.ОтветственныеЛицаОрганизаций.НачальникЛогистики Тогда
				Результат.НачальникЛогистики    = Руководители.ФизическоеЛицо;
				Результат.НачальникЛогистикиФИО = ФИО;
				Результат.НачальникЛогистикиПредставление  = Представление;
			ИначеЕсли Руководители.ОтветственноеЛицо = Перечисления.ОтветственныеЛицаОрганизаций.НачальникСнабжения Тогда
				Результат.НачальникСнабжения    = Руководители.ФизическоеЛицо;
				Результат.НачальникСнабженияФИО = ФИО;
				Результат.НачальникСнабженияПредставление  = Представление;
			ИначеЕсли Руководители.ОтветственноеЛицо = Перечисления.ОтветственныеЛицаОрганизаций.ЗаместительРуководителяПоЭкономике Тогда
				Результат.ЗаместительРуководителяПоЭкономике    = Руководители.ФизическоеЛицо;
				Результат.ЗаместительРуководителяПоЭкономикеФИО = ФИО;
				Результат.ЗаместительРуководителяПоЭкономикеПредставление  = Представление;
			ИначеЕсли Руководители.ОтветственноеЛицо = Перечисления.ОтветственныеЛицаОрганизаций.ЗаместительРуководителяПоКоммерческимВопросам Тогда
				Результат.ЗаместительРуководителяПоКоммерческимВопросам    = Руководители.ФизическоеЛицо;
				Результат.ЗаместительРуководителяПоКоммерческимВопросамФИО = ФИО;
				Результат.ЗаместительРуководителяПоКоммерческимВопросамПредставление  = Представление;
			ИначеЕсли Руководители.ОтветственноеЛицо = Перечисления.ОтветственныеЛицаОрганизаций.УправляющийДелами Тогда
				Результат.УправляющийДелами    = Руководители.ФизическоеЛицо;
				//Результат.УправляющийДеламиФИО = ФИО;
				Результат.УправляющийДеламиПредставление  = Представление;	
			КонецЕсли;

		КонецЦикла;

	КонецЕсли;
	
	
	Если не ЗначениеЗаполнено(Результат.ГлавныйБухгалтер) Тогда
		Результат.ГлавныйБухгалтерПредставление="не предусмотрен";
	КонецЕсли;
	
	Возврат Результат;

КонецФункции

// Функция возвращает совокупность данных о физическом лице в виде структуры, 
// В совокупность данных входит ФИО, должность в заданной организации, 
// паспортные данные и др.
//
// Параметры:
//  Организация  - СправочникСсылка.Организации - организация, по которой
//                 определяется должность и подразделение работника
//  ФизЛицо      - СправочникСсылка.ФизическиеЛица - физическое лицо,
//                 по которому возвращается совокупность данных
//  ДатаСреза    - Дата - дата, на которую считываются данные
//
// Возвращаемое значение:
//  Структура    - Структура с совокупностью данных о физическом лице:
//                 - Фамилия
//                 - Имя
//                 - Отчетсво
//                 - Представление (Фамилия И.О.)
//                 - Подразделение
//                 - ДокументВид
//                 - ДокументСерия
//                 - ДокументНомер
//                 - ДокументДатаВыдачи
//                 - ДокументКемВыдан
//                 - ДокументКодПодразделения
//
Функция ДанныеФизЛица(Организация, ФизЛицо, ДатаСреза) Экспорт
	
	Результат = Новый Структура("Фамилия, Имя, Отчество, Представление, 
								|ТабельныйНомер, Должность, ПодразделениеОрганизации, 
								|ДокументВид, ДокументСерия, ДокументНомер,  
								|ДокументДатаВыдачи, ДокументКемВыдан, ДокументКодПодразделения");

	ЗапросПоЛицам = Новый Запрос();
	ЗапросПоЛицам.УстановитьПараметр("ДатаСреза",   ДатаСреза);
	ЗапросПоЛицам.УстановитьПараметр("Организация", Организация);
	ЗапросПоЛицам.УстановитьПараметр("ФизЛицо", ФизЛицо);
	ЗапросПоЛицам.Текст =
	"ВЫБРАТЬ
	|	ФИОФизЛицСрезПоследних.Фамилия,
	|	ФИОФизЛицСрезПоследних.Имя,
	|	ФИОФизЛицСрезПоследних.Отчество,
	|	РаботникиОрганизацийСрезПоследних.ТабельныйНомер,
	|	РаботникиОрганизацийСрезПоследних.Должность,
	|	РаботникиОрганизацийСрезПоследних.ПодразделениеОрганизации,
	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументВид,
	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументСерия,
	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументНомер,
	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументДатаВыдачи,
	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументКемВыдан,
	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументКодПодразделения
	|ИЗ
	|	РегистрСведений.ФИОФизЛиц.СрезПоследних(&ДатаСреза, ФизЛицо = &ФизЛицо) КАК ФИОФизЛицСрезПоследних
	|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.ПаспортныеДанныеФизЛиц.СрезПоследних(&ДатаСреза, ФизЛицо = &ФизЛицо) КАК ПаспортныеДанныеФизЛицСрезПоследних
	|		ПО ФИОФизЛицСрезПоследних.ФизЛицо = ПаспортныеДанныеФизЛицСрезПоследних.ФизЛицо
	|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.РаботникиОрганизаций.СрезПоследних(
	|				&ДатаСреза,
	|				Сотрудник.ФизическоеЛицо = &ФизЛицо
	|					И Организация = &Организация) КАК РаботникиОрганизацийСрезПоследних
	|		ПО ФИОФизЛицСрезПоследних.ФизЛицо = РаботникиОрганизацийСрезПоследних.Сотрудник.ФизическоеЛицо";
	
	Данные = ЗапросПоЛицам.Выполнить().Выбрать();
	Данные.Следующий();

	Результат.Фамилия       			= Данные.Фамилия;
	Результат.Имя      					= Данные.Имя;
	Результат.Отчество      			= Данные.Отчество;
	Результат.Представление 			= ПолучитьФамилиюИмяОтчество(Данные.Фамилия, Данные.Имя, Данные.Отчество);
	
	Результат.ТабельныйНомер  			= Данные.ТабельныйНомер;
	Результат.Должность      			= Данные.Должность;
	Результат.ПодразделениеОрганизации  = Данные.ПодразделениеОрганизации;
	
	Результат.ДокументВид        		= Данные.ДокументВид;
	Результат.ДокументСерия      		= Данные.ДокументСерия;
	Результат.ДокументНомер      		= Данные.ДокументНомер;
	Результат.ДокументДатаВыдачи 		= Данные.ДокументДатаВыдачи;
	Результат.ДокументКемВыдан      	= Данные.ДокументКемВыдан;
	Результат.ДокументКодПодразделения	= Данные.ДокументКодПодразделения;

	Возврат Результат;
	
КонецФункции // ДанныеФизЛица

// Функция возвращает совокупность данных о физических лицах в виде таблицы
// значений. В совокупность данных входит ФИО, должность в заданной 
// организации, паспортные данные и др.
//
// Параметры:
//  Организация  - СправочникСсылка.Организации - организация, по которой
//                 определяется должность и подразделение работника(ов)
//  ФизЛицо      - СправочникСсылка.ФизическиеЛица или Массив - физическое лицо
//                 или список физ. лиц, по которым возвращается совокупность 
//                 данных
//  ДатаСреза    - Дата - дата, на которую считываются данные
//
// Возвращаемое значение:
//  ТаблицаЗначений - Таблица с совокупностью данных о физическом лице. 
//                  Колонки: возвращаемой таблицы:
//                  - Фамилия
//                  - Имя
//                  - Отчетсво
//                  - Представление (Фамилия И.О.)
//                  - Подразделение
//                  - ДокументВид
//                  - ДокументСерия
//                  - ДокументНомер
//                  - ДокументДатаВыдачи
//                  - ДокументКемВыдан
//                  - ДокументКодПодразделения
//
Функция ДанныеФизЛиц(Организация, ФизЛицо, ДатаСреза) Экспорт

	ТабРезультат = Новый ТаблицаЗначений();
	ТабРезультат.Колонки.Добавить("Фамилия");
	ТабРезультат.Колонки.Добавить("Имя");
	ТабРезультат.Колонки.Добавить("Отчество");
	ТабРезультат.Колонки.Добавить("Представление");
	ТабРезультат.Колонки.Добавить("ТабельныйНомер");
	ТабРезультат.Колонки.Добавить("Должность");
	ТабРезультат.Колонки.Добавить("ПодразделениеОрганизации");
	ТабРезультат.Колонки.Добавить("ДокументВид");
	ТабРезультат.Колонки.Добавить("ДокументСерия");
	ТабРезультат.Колонки.Добавить("ДокументНомер");
	ТабРезультат.Колонки.Добавить("ДокументДатаВыдачи");
	ТабРезультат.Колонки.Добавить("ДокументКемВыдан");
	ТабРезультат.Колонки.Добавить("ДокументКодПодразделения");
								
	ЗапросПоЛицам = Новый Запрос();
	ЗапросПоЛицам.УстановитьПараметр("ДатаСреза",   ДатаСреза);
	ЗапросПоЛицам.УстановитьПараметр("Организация", Организация);
	ЗапросПоЛицам.УстановитьПараметр("ФизЛицо", ФизЛицо);
	ЗапросПоЛицам.Текст =
	"ВЫБРАТЬ
	|	ФИОФизЛицСрезПоследних.Фамилия,
	|	ФИОФизЛицСрезПоследних.Имя,
	|	ФИОФизЛицСрезПоследних.Отчество,
	|	РаботникиОрганизацийСрезПоследних.ТабельныйНомер,
	|	РаботникиОрганизацийСрезПоследних.Должность,
	|	РаботникиОрганизацийСрезПоследних.ПодразделениеОрганизации,
	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументВид,
	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументСерия,
	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументНомер,
	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументДатаВыдачи,
	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументКемВыдан,
	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументКодПодразделения
	|ИЗ
	|	РегистрСведений.ФИОФизЛиц.СрезПоследних(&ДатаСреза, ФизЛицо В(&ФизЛицо)) КАК ФИОФизЛицСрезПоследних
	|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.ПаспортныеДанныеФизЛиц.СрезПоследних(&ДатаСреза, ФизЛицо В(&ФизЛицо)) КАК ПаспортныеДанныеФизЛицСрезПоследних
	|		ПО ФИОФизЛицСрезПоследних.ФизЛицо = ПаспортныеДанныеФизЛицСрезПоследних.ФизЛицо
	|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.РаботникиОрганизаций.СрезПоследних(&ДатаСреза, ФизЛицо В(&ФизЛицо) И Организация = &Организация) КАК РаботникиОрганизацийСрезПоследних
	|		ПО ФИОФизЛицСрезПоследних.ФизЛицо = РаботникиОрганизацийСрезПоследних.Физлицо";
	
	Данные = ЗапросПоЛицам.Выполнить().Выбрать();
	
	Пока Данные.Следующий() Цикл
		
		Результат = ТабРезультат.Добавить();

		Результат.Фамилия       			= Данные.Фамилия;
		Результат.Имя      					= Данные.Имя;
		Результат.Отчество      			= Данные.Отчество;
		Результат.Представление 			= ПолучитьФамилиюИмяОтчество(Данные.Фамилия, Данные.Имя, Данные.Отчество);
		
		Результат.ТабельныйНомер  			= Данные.ТабельныйНомер;
		Результат.Должность      			= Данные.Должность;
		Результат.ПодразделениеОрганизации  = Данные.ПодразделениеОрганизации;
		
		Результат.ДокументВид        		= Данные.ДокументВид;
		Результат.ДокументСерия      		= Данные.ДокументСерия;
		Результат.ДокументНомер      		= Данные.ДокументНомер;
		Результат.ДокументДатаВыдачи 		= Данные.ДокументДатаВыдачи;
		Результат.ДокументКемВыдан      	= Данные.ДокументКемВыдан;
		Результат.ДокументКодПодразделения	= Данные.ДокументКодПодразделения;
		
	КонецЦикла;

	Возврат ТабРезультат;
	
КонецФункции // ДанныеФизЛиц

////////////////////////////////////////////////////////////////////////////////
// МАТЕМАТИКА

// возвращает "количество полных и неполных рублей"
// Параметры:
//	Сумма - число
// Возвращаемое значение:
//  число, равное ближайшему целому "сверху"
Функция ЦелМаксимальное(Сумма) Экспорт
	Возврат ?(Цел(Сумма) = Сумма, Сумма, Цел(Сумма) + 1);
	
КонецФункции // ЦелМаксимальное()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ПАРАМЕТРОВ СЕАНСА

#Если НЕ Клиент И НЕ ВнешнееСоединение Тогда
	
// Функция возвращает значение экспортных переменных модуля приложений из параметра сеанса
// Необходмо для возможности создания объектов на сервере
Функция глЗначениеПеременной(ИмяПеременой) Экспорт
	ЗначениеИзПараметраСеанса = ПараметрыСеанса[Сред(ИмяПеременой, 3)];
	Если ТипЗнч(ЗначениеИзПараметраСеанса) = Тип("ХранилищеЗначения") Тогда
		 Возврат ЗначениеИзПараметраСеанса.Получить();
	 Иначе
		 Возврат ЗначениеИзПараметраСеанса;
	КонецЕсли;
КонецФункции

#КонецЕсли

// Функция дополняет структуру шапки документа положениями учетной политики.
Процедура ДополнитьПоложениямиУчетнойПолитики(СтруктураШапкиДокумента, КонДата, Отказ, Организация, СтруктураПолейУчетнойПолитикиНУ = Неопределено) Экспорт
	
	СтруктураУП = ПолучитьПараметрыУчетнойПолитики(КонДата, Отказ, Организация);
	
	Для Каждого ПараметрУП Из СтруктураУП Цикл
		
		Если (ТипЗнч(СтруктураПолейУчетнойПолитикиНУ) = Тип("Структура"))
		   И НЕ (СтруктураПолейУчетнойПолитикиНУ.Количество() = 0) Тогда
		   
			// Заполнение определенными полями
			Если СтруктураПолейУчетнойПолитикиНУ.Свойство(ПараметрУП.Ключ) Тогда
				
				Если ЗначениеНеЗаполнено(СтруктураПолейУчетнойПолитикиНУ[ПараметрУП.Ключ]) Тогда
					
					СтруктураШапкиДокумента.Вставить(ПараметрУП.Ключ,ПараметрУП.Значение);
					
				Иначе
					
					СтруктураШапкиДокумента.Вставить(СтруктураПолейУчетнойПолитикиНУ[ПараметрУП.Ключ],ПараметрУП.Значение);
					
				КонецЕсли; 
				
			КонецЕсли; 
			
		Иначе	
			
			// Дополняем всеми параметрами учетной политики
			СтруктураШапкиДокумента.Вставить(ПараметрУП.Ключ, ПараметрУП.Значение);  
			
		КонецЕсли; 
		
	КонецЦикла; 
	
КонецПроцедуры // ДополнитьПоложениямиУчетнойПолитики()

// Разворачивает таблицу  значений по вложенной таблице
//
// Параметры
//  ТаблицаЗначений  – <ТаблицаЗначений> – базовая таблица
//  КолонкаВложеннойТаблицы  – <Строка> – Наименование колонки влолженной таблицы
//  СписокРаспределяемыхКолонок  – <Структура> – Структура с именами колонок базовой таблицы, значения которых будут распределяться по колонке вложенной таблицы
//         						Ключ - Имя колонки базовой таблицы
//         						Значение - Имя колонки вложенной таблицы. Если во вложенной таблице колонка не обнаружена - обработка прекращается.
// Возвращаемое значение:
//   <ТаблицаЗначений>   – таблица значений, развернутая по значениям вложенной таблицы.
//
// При совпадении имен базовой и вложенной таблиц - если  
Функция РазвернутьПоВложеннойТаблице(ТаблицаЗначений, КолонкаВложеннойТаблицы,СписокРаспределяемыхКолонок, СписокИсключаемыхКолонок, СообщатьОбОшибке = Истина) Экспорт

	Если ТаблицаЗначений.Количество()=0 Тогда
		// Таблица не заполнена, софрмировать новую таблицу не представляется возможнным
		// Отсуттствует вложенная таблица, структуру данных выходной таблицы сформировать невозможно
		Если СообщатьОбОшибке Тогда
			СообщитьОбОшибке("Отстутствуют строки в базовой таблице, распределение по вложенной таблице невозможно.",,,СтатусСообщения.Внимание);
		КонецЕсли; 
		Возврат Неопределено;
	КонецЕсли; 
	
	КолонкиВложеннойТаблицы = ТаблицаЗначений[0][КолонкаВложеннойТаблицы].Колонки;
	//Заполним значения по тем колонкам, по которым не были заполены значения ранее
	Для каждого Колонка Из СписокРаспределяемыхКолонок Цикл
		Если ЗначениеНеЗаполнено(Колонка.Значение) Тогда
			СписокРаспределяемыхКолонок.Вставить(Колонка.Ключ,Колонка.Ключ);
		КонецЕсли;
		Если КолонкиВложеннойТаблицы.Найти(?(ЗначениеНеЗаполнено(Колонка.Значение),Колонка.Ключ,Колонка.Значение))=Неопределено Тогда
			// Во вложенной таблице не обнаружена колонка, по которой производится распределение.
			Если СообщатьОбОшибке Тогда
				СообщитьОбОшибке("Во вложенной таблице не обнаружена колонка ("+?(ЗначениеНеЗаполнено(Колонка.Значение),Колонка.Ключ,Колонка.Значение)+"), по которой производится распределение.",,,СтатусСообщения.Внимание);
			КонецЕсли; 
			Возврат Неопределено;
		КонецЕсли; 
	КонецЦикла;
	
	НоваяТаблицаЗначений = Новый ТаблицаЗначений();
	Для каждого Колонка Из ТаблицаЗначений.Колонки Цикл
	    Если Колонка.Имя = КолонкаВложеннойТаблицы Тогда
			Продолжить;
	    ИначеЕсли СписокИсключаемыхКолонок.Свойство(Колонка.Имя) Тогда
			Продолжить;
		КонецЕсли; 
		НоваяТаблицаЗначений.Колонки.Добавить(Колонка.Имя,Колонка.ТипЗначения);
	КонецЦикла; 
	
	Для каждого Колонка Из КолонкиВложеннойТаблицы Цикл
		Если не НоваяТаблицаЗначений.Колонки.Найти(Колонка.Имя) = неопределено Тогда
			Продолжить;
		ИначеЕсли СписокИсключаемыхКолонок.Свойство(Колонка.Имя) Тогда
			Продолжить;
		КонецЕсли; 
		НоваяТаблицаЗначений.Колонки.Добавить(Колонка.Имя,Колонка.ТипЗначения);
	КонецЦикла; 
	
	Для каждого СтрокаБазовойТаблицы Из ТаблицаЗначений Цикл 

		ТаблицаДляРаспределения = СтрокаБазовойТаблицы[КолонкаВложеннойТаблицы];

		Для каждого СтрокаТаблицыРаспределения из ТаблицаДляРаспределения Цикл

			СтрокаНовойТаблицы = НоваяТаблицаЗначений.Добавить();

			Для каждого Колонка из НоваяТаблицаЗначений.Колонки Цикл

				Если СписокРаспределяемыхКолонок.Свойство(Колонка.Имя) тогда
					СтрокаНовойТаблицы[Колонка.Имя]= СтрокаТаблицыРаспределения[СписокРаспределяемыхКолонок[Колонка.Имя]];

				ИначеЕсли не КолонкиВложеннойТаблицы.Найти(Колонка.Имя) = Неопределено тогда
					СтрокаНовойТаблицы[Колонка.Имя]= СтрокаТаблицыРаспределения[Колонка.Имя];

				ИначеЕсли Не(ТаблицаЗначений.Колонки.Найти(Колонка.Имя)=Неопределено) тогда
					СтрокаНовойТаблицы[Колонка.Имя] = СтрокаБазовойТаблицы[Колонка.Имя];

				Иначе
					// Колонка не найдена... Неизвестно, как такое может произойти
		  			Если СообщатьОбОшибке Тогда
						СообщитьОбОшибке("при распределении по вложенной таблице невозможно определить значение для колонки :"+Колонка.Имя+".",,,СтатусСообщения.Внимание);
					КонецЕсли; 

				КонецЕсли;

			КонецЦикла; // Для каждого Колонка из НоваяТаблицаЗначений.Колонки Цикл

		КонецЦикла; // Для каждого СтрокаТаблицыРаспределения из ТаблицаДляРаспределения Цикл

	КонецЦикла; // Для каждого СтрокаБазовойТаблицы Из ТаблицаЗначений Цикл 
	
	Для каждого Колонка Из СписокРаспределяемыхКолонок Цикл
		СписокРаспределяемыхКолонок.Вставить(Колонка.Ключ,Колонка.Ключ);
	КонецЦикла;
	
	// Распределение базовых данных по распределяемым колонкам
	НоваяТаблицаЗначений = СформироватьКорректирующиеЗаписи(ТаблицаЗначений,НоваяТаблицаЗначений,СписокРаспределяемыхКолонок);
	
	Возврат НоваяТаблицаЗначений;

КонецФункции // РазвернутьПоВложеннойТаблице()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ МЕХАНИЗМА РИБ

Процедура ДобавитьПрефиксУзла(Префикс) Экспорт
	
	//Если ПараметрыСеанса.ИспользованиеРИБ Тогда
	Если Не ПараметрыСеанса.ЭтоЦентральнаяБаза Тогда
		ПрефиксУзла = ПланыОбмена.Полный.ЭтотУзел().ПрефиксУзла;
		Префикс = ПрефиксУзла + Префикс;
	КонецЕсли;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ФАЙЛАМИ


// функция возвращает часть строки после последнего встреченного символа в строке
Функция ПолучитьЧастьСтрокиОтделеннойСимволом(Знач ИсходнаяСтрока, Знач СимволПоиска)
	
	ПозицияСимвола = СтрДлина(ИсходнаяСтрока);
	Пока ПозицияСимвола >= 1 Цикл
		
		Если Сред(ИсходнаяСтрока, ПозицияСимвола, 1) = СимволПоиска Тогда
						
			Возврат Сред(ИсходнаяСтрока, ПозицияСимвола + 1); 
			
		КонецЕсли;
		
		ПозицияСимвола = ПозицияСимвола - 1;	
	КонецЦикла;

	Возврат "";
  	
КонецФункции

// Выделяет из имени файла его расширение (набор символов после последней точки).
//
// Параметры
//  ИмяФайла     – Строка, содержащая имя файла, неважно с именем каталога или без.
//
// Возвращаемое значение:
//   Строка – расширение файла.
//
Функция ПолучитьРасширениеФайла(Знач ИмяФайла) Экспорт
	
	Расширение = ПолучитьЧастьСтрокиОтделеннойСимволом(ИмяФайла, ".");
	Возврат Расширение;
	
КонецФункции
