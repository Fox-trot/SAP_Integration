
Функция УстановитьКомпоненту(Знач ПутьККаталогу) Экспорт
	
	Если ПустаяСтрока(ПутьККаталогу) Тогда
		ПутьККаталогу = КаталогВременныхФайлов();
	КонецЕсли;
	
	ИмяФайлаУстановки 	= "Install.bat";
	ИмяФайлаУдаления 	= "Uninstall.bat";
	
	Если Не Прав(ПутьККаталогу, 1) = "\" Тогда
		ПутьККаталогу = ПутьККаталогу + "\";
	КонецЕсли;
	
	СоздатьBatФайлыУстановкиИУдаления(ПутьККаталогу, ИмяФайлаУстановки, ИмяФайлаУдаления);
	
	КомандаВыполненаУспешно = ЗапуститьBatФайл(ПутьККаталогу + ИмяФайлаУстановки);
	
	Возврат КомандаВыполненаУспешно;	
	
КонецФункции

Функция ПроверитьРегистрациюКомпонентыЭО() Экспорт
	
	Возврат DidoxEImzo_ПодключитьсяКСокетСерверу();
	
КонецФункции

Функция ПрочитатьДанныеЭЦП() Экспорт
	
	Перем DidoxEImzoDLL;
	ЭлектронныйКлюч = Новый Структура("Успешно", Ложь);
	СтатусПодключения = DidoxEImzo_ПодключитьсяКСокетСерверу(DidoxEImzoDLL);
	
	Если СтатусПодключения = 0 Тогда
		ОбработчикиDidoxEImzoСервер.ПодключитьФайлКомпонентыVenkonЭДО(СтатусПодключения, DidoxEImzoDLL);
	КонецЕсли;
	
	Если СтатусПодключения <> 2 Тогда
		ОбщегоНазначенияКлиентСервер.СообщитьПользователю("Не удалось подключиться к компоненте ЭЦП!");
		Возврат ЭлектронныйКлюч;
	КонецЕсли;

	МассивКлючей = Новый Массив;
	
	// Получем список сертификатов нового формата
	СписокКлючейСоответсвие = DidoxEImzo_ПолучитьСписокНовыхКлючей(DidoxEImzoDLL);
	Если СписокКлючейСоответсвие = Неопределено ИЛИ НЕ СписокКлючейСоответсвие.Получить("success") Тогда
		ОбщегоНазначенияКлиентСервер.СообщитьПользователю("Произошла ошибка при получении списка сертификатов.");
	Иначе	
		
		Certificates = СписокКлючейСоответсвие.Получить("certificates");
		Для каждого Certificate Из Certificates Цикл
			
			СоответствиеКлючей = Новый Соответствие;
			
			СоответствиеКлючей.Вставить("СтруктураКлюча", Новый Структура);
			СоответствиеКлючей.Вставить("ПараметрыКлюча", "");
			СоответствиеКлючей.Вставить("ПредставлениеКлюча", "");
			
			СоответствиеКлючей["ПараметрыКлюча"] = Certificate;   
			СоответствиеКлючей["СтруктураКлюча"] = ПолучитьСтруктуруИзСоответствия(Certificate);
			СоответствиеКлючей["СтруктураКлюча"].Вставить("file_name", СоответствиеКлючей["СтруктураКлюча"].name);
			СписокКлючей = ОбщегоНазначенияКлиентСервер.ПреобразоватьСписокВСписокЗначений(Certificate.Получить("alias"), ",");
			СоответствиеКлючей["СтруктураКлюча"] = ПолучитьСтруктуруИзСпискаЗначений(СписокКлючей, СоответствиеКлючей["СтруктураКлюча"]); 
			СоответствиеКлючей["СтруктураКлюча"].Вставить("active", Истина);
			СоответствиеКлючей["СтруктураКлюча"].Вставить("plugin", "pfx");
			СоответствиеКлючей["ПредставлениеКлюча"] = ПолучитьПредставлениеКлюча(Certificate); //Certificate.Получить("alias"); 
			Если СоответствиеКлючей["СтруктураКлюча"].Свойство("validfrom") Тогда
				СоответствиеКлючей["СтруктураКлюча"].Вставить("validFromDate", ПолучитьДатуИзСтроки(СоответствиеКлючей["СтруктураКлюча"].validfrom, 2)); 
				СоответствиеКлючей["СтруктураКлюча"].Вставить("validToDate", ПолучитьДатуИзСтроки(СоответствиеКлючей["СтруктураКлюча"].validto, 2));
				Если СоответствиеКлючей["СтруктураКлюча"].validToDate < ТекущаяДата()  Тогда
					СоответствиеКлючей["СтруктураКлюча"].Вставить("active", Ложь);
				КонецЕсли;
			Иначе
				СоответствиеКлючей["СтруктураКлюча"].Вставить("active", Ложь);
			КонецЕсли;
			// Получаем ID ключа в 10 системе счисления
			Если СоответствиеКлючей["СтруктураКлюча"].active Тогда
				СоответствиеКлючей["СтруктураКлюча"].Вставить("id", ПеревестиЧислоИзШестнадцатиричногоВДесятичное(СоответствиеКлючей["СтруктураКлюча"].serialnumber));
			КонецЕсли;
			
			МассивКлючей.Добавить(СоответствиеКлючей);
			
		КонецЦикла;
	КонецЕсли;
	
	ЭлектронныйКлюч.Вставить("Успешно", Истина);
	ЭлектронныйКлюч.Вставить("МассивКлючей", МассивКлючей);
	Возврат ЭлектронныйКлюч;
	
КонецФункции

Функция ЗашифроватьИПодписатьФайл(ИмяОсновногоФайла, СтруктураПараметров, ФайлРезультатКода) Экспорт
	
	СтруктураВозврата = Новый Структура;
	СтруктураВозврата.Вставить("Успешно", Ложь);
			
	// Считываем из файла
	темп = новый ТекстовыйДокумент;
	темп.Прочитать(ИмяОсновногоФайла);
	value = темп.ПолучитьТекст();
	
	// Получаем ID ключа
	ПараметрыЭЦП = СтруктураПараметров.ПараметрыЭЦП;
	IDКлючСоответствие = DidoxEImzo_ПолучитьIDКлюча(ПараметрыЭЦП);
	Если  IDКлючСоответствие = Неопределено ИЛИ Не IDКлючСоответствие.Получить("success") Тогда
		ОбщегоНазначенияКлиентСервер.СообщитьПользователю("Произошла ошибка при получении ИД ключа");
		Возврат СтруктураВозврата;
	КонецЕсли;
	IDКлючСтруктура = ПолучитьСтруктуруИзСоответствия(IDКлючСоответствие);
	
	// Подписываем
	ПодписаннаяСтрокаСтруктура = Новый Структура;
	ПодписаннаяСтрокаСоответствие = DidoxEImzo_Подписать(value, IDКлючСтруктура.keyId);
	Если ПодписаннаяСтрокаСоответствие = Неопределено ИЛИ НЕ ПодписаннаяСтрокаСоответствие.Получить("success") Тогда
		Возврат СтруктураВозврата;
	КонецЕсли;
	ПодписаннаяСтрокаСтруктура = ПолучитьСтруктуруИзСоответствия(ПодписаннаяСтрокаСоответствие);
	
	// Записываем в файл
	Текст = Новый ТекстовыйДокумент;
	Текст.УстановитьТекст(ПодписаннаяСтрокаСтруктура.pkcs7_64);
	Текст.Записать(ФайлРезультатКода, КодировкаТекста.ANSI);
	
	СтруктураВозврата.Вставить("Успешно", Истина);
	СтруктураВозврата.Вставить("ПодписаннаяСтрока", ПодписаннаяСтрокаСтруктура.pkcs7_64);
	
	Возврат СтруктураВозврата;
	
КонецФункции

Функция ПодписатьФайл(ИмяФайла, keyId, СертификатЭЦП = Неопределено, serialNumber = Неопределено) Экспорт
	
	ФайлРезультатКода = Неопределено;	
	
	// Считываем из файла
	темп = новый ТекстовыйДокумент;
	темп.Прочитать(ИмяФайла, КодировкаТекста.UTF8);
	value = темп.ПолучитьТекст();
	
	УдалитьФайлы(ИмяФайла);
	
    ПодписаннаяСтрокаСоответствие = DidoxEImzo_Подписать(value, keyId, СертификатЭЦП);
	
	Если  ПодписаннаяСтрокаСоответствие = Неопределено ИЛИ НЕ ПодписаннаяСтрокаСоответствие.Получить("success") Тогда
		Возврат ФайлРезультатКода;
	КонецЕсли;
	
	// Записываем в файл
	ФайлРезультатКода = ПолучитьИмяВременногоФайла();
	Текст = Новый ТекстовыйДокумент;
	Текст.УстановитьТекст(ПодписаннаяСтрокаСоответствие.Получить("pkcs7_64"));
	Текст.Записать(ФайлРезультатКода, КодировкаТекста.ANSI);
	
	serialNumber = ПодписаннаяСтрокаСоответствие.Получить("signer_serial_number");
	
	Возврат ФайлРезультатКода;
	
КонецФункции

Функция ПолучитьИнформациюОПодписи(ПодписаннаяСтрока) Экспорт
	
	ИнформацияОПодписиСоответствие = DidoxEImzo_ПолучитьИнформациюОПодписи(ПодписаннаяСтрока);
	Если ИнформацияОПодписиСоответствие = Неопределено ИЛИ НЕ ИнформацияОПодписиСоответствие.Получить("success")  Тогда
		ОбщегоНазначенияКлиентСервер.СообщитьПользователю("Произошла ошибка при получении информации о подписи");
		Возврат Неопределено;
	КонецЕсли;
	ИнформацияОПодписиСтруктура = ПолучитьСтруктуруИзСоответствия(ИнформацияОПодписиСоответствие);
	
	// Декодируем Base64-строку
	pkcs7Info = ИнформацияОПодписиСтруктура.pkcs7Info;
	documentBase64 = pkcs7Info.Получить("documentBase64");
	document = DecodeBase64(documentBase64, КодировкаТекста.UTF8);  //КодировкаТекста.ANSI
	ИнформацияОПодписиСтруктура.pkcs7Info.Вставить("document", document);
	
	Возврат ИнформацияОПодписиСтруктура;
	
КонецФункции

Функция ПолучитьЗагрузитьIDКлюча(СертификатЭЦП, ЗагрузитьID = Ложь) Экспорт
	
	IDКлюча = ОбработчикиDidoxEImzoСервер.ПолучитьIDКлючаИзРегистра(СертификатЭЦП);
	
	Если ПустаяСтрока(IDКлюча) ИЛИ ЗагрузитьID Тогда
				
		ПараметрыЭЦП = ОбщегоНазначенияВызовСервера.ЗначенияРеквизитовОбъекта(СертификатЭЦП, 
			"plugin, disk, path, name, file_name, serialNumber, alias");
		
		СоответствиеIDКлюча = DidoxEImzo_ПолучитьIDКлюча(ПараметрыЭЦП);
		
		Если Не СоответствиеIDКлюча.Получить("success") Тогда													
			ОбщегоНазначенияКлиентСервер.СообщитьПользователю("Не удалось загрузить сертфикат ЭЦП!");
			Возврат Неопределено;
		КонецЕсли;
		
		IDКлюча = СоответствиеIDКлюча.Получить("keyId");
		
		ОбработчикиDidoxEImzoСервер.СохранитьIDКлючаВРегистр(СертификатЭЦП, IDКлюча);
		
	КонецЕсли;
	
	Возврат IDКлюча;
	
КонецФункции

Функция ПолучитьДопПараметрыСертификата(ДанныеСертификата, ДополнитьДанные = Ложь) Экспорт
	
	ДопСвойства = Новый Структура;
	
	// Дополним реквизиты ключа
	// 1. Получим keyId ключа
	ОтветСоответствие = DidoxEImzo_ПолучитьIDКлюча(ДанныеСертификата);
	Если  ОтветСоответствие = Неопределено ИЛИ Не ОтветСоответствие.Получить("success") Тогда
		Возврат Неопределено;
	КонецЕсли;
	keyId = ОтветСоответствие.Получить("keyId");
	
	// 2. Проверка пароля
	ОтветСоответствие = DidoxEImzo_ВерификацияПароля(keyId);
	Если Не ОтветСоответствие.Получить("success") Тогда
		ОбщегоНазначенияКлиентСервер.СообщитьПользователю("Не верно указан пароль от ЭЦП.");
		Возврат Неопределено;
	КонецЕсли;
	
	// 3. Получаем цепочку сертификатов в кодировке BASE64
	ОтветСоответствие = DidoxEImzo_ПолучитьЦепочкуСертификатов(keyId);
	Если Не ОтветСоответствие.Получить("success") Тогда
		ОбщегоНазначенияКлиентСервер.СообщитьПользователю("Не удалось получить цепочку сертификатов ЭЦП.");
		Возврат Неопределено;
	КонецЕсли;
	
	// 4. Сертификаты всех уровней
	userCert  = Неопределено;
	caCert    = Неопределено;
	rootCert = Неопределено;
	certificates = ОтветСоответствие.Получить("certificates");
	userCert  = certificates[0];
	Если ДанныеСертификата.plugin = "pfx" Тогда
		caCert    = certificates[1];
		rootCert = certificates[2];
	КонецЕсли;
	
	// 4. Получаем информацию о сертификате
	Если userCert <> Неопределено Тогда
		ОтветСоответствие = DidoxEImzo_ПолучитьИнформациюОСертификате(userCert);
		Если Не ОтветСоответствие.Получить("success") Тогда
			Возврат Неопределено;
		КонецЕсли;
		// 5. Парсим результат
		certificate_info = ОтветСоответствие.Получить("certificate_info");
		subjectName = ВРег(certificate_info.Получить("subjectName"));
		// Имя
		НачалоName = Найти(subjectName, "NAME=") + 5;
		Name = Сред(subjectName, НачалоName);
		ПозицияЗапятой = Найти(Name, ",");
		Имя = Лев(Name, ПозицияЗапятой - 1);
		ДопСвойства.Вставить("Имя", Имя);
		// Фамилия
		НачалоSurname = Найти(subjectName, "SURNAME=") + 8;
		Surname = Сред(subjectName, НачалоSurname);
		ПозицияЗапятой = Найти(Surname, ",");
		Фамилия = Лев(Surname, ПозицияЗапятой - 1);
		ДопСвойства.Вставить("Фамилия", Фамилия);
		// Отчетство
		Отчество = "";
		ДопСвойства.Вставить("Отчество", Отчество);
		// Фирма
		НачалоФирма = Найти(subjectName, "O=") + 2;
		Фирма = Сред(subjectName, НачалоФирма);
		ПозицияЗапятой = Найти(Фирма, ",");
		Фирма = Лев(Фирма, ПозицияЗапятой - 1);
		ДопСвойства.Вставить("Фирма", Фирма);
		//Должность
		НачалоДолжность = Найти(subjectName, "OU=") + 3;
		Должность = Сред(subjectName, НачалоДолжность);
		ПозицияЗапятой = Найти(Должность, ",");
		Должность = Лев(Должность, ПозицияЗапятой - 1);
		ДопСвойства.Вставить("Должность", Должность);
		//КомуВыдан
		НачалоКомуВыдан = Найти(subjectName, "CN=") + 3;
		КомуВыдан = Сред(subjectName, НачалоКомуВыдан);
		ПозицияЗапятой = Найти(КомуВыдан, ",");
		КомуВыдан = Лев(КомуВыдан, ПозицияЗапятой - 1);
		ДопСвойства.Вставить("КомуВыдан", КомуВыдан);
		
		issuerName = ВРег(certificate_info.Получить("issuerName"));
		//КемВыдан
		НачалоКемВыдан = Найти(issuerName, "O=") + 2;
		КемВыдан = Сред(issuerName, НачалоКемВыдан);
		ПозицияЗапятой = Найти(КемВыдан, ",");
		КемВыдан = Лев(КемВыдан, ПозицияЗапятой - 1);
		ДопСвойства.Вставить("КемВыдан", КемВыдан);
		//ДействителенДо
		validTo = certificate_info.Получить("validTo");
		ДействителенДо = ПолучитьДатуИзСтроки(validTo, 2);
		ДопСвойства.Вставить("ДействителенДо", ДействителенДо);
		//Подписание
		Подписание = Истина;
		ДопСвойства.Вставить("Подписание", Подписание);
		//Шифрование
		Шифрование = Истина;
		ДопСвойства.Вставить("Шифрование", Шифрование);
		//ДанныеСертификата
	КонецЕсли;
	
	// Двоичные данные сертификата
	ИмяФайла = ДанныеСертификата.disk + ДанныеСертификата.path + "\" + ДанныеСертификата.file_name + ".pfx";
	ДвоичныеДанныеСертификата = Новый ДвоичныеДанные(ИмяФайла);
	ДанныеСертификата.Вставить("ДвоичныеДанныеСертификата", ДвоичныеДанныеСертификата);
	
	Если ДополнитьДанные Тогда
		Для каждого ДопСвойство Из ДопСвойства Цикл
			ДанныеСертификата.Вставить(ДопСвойство.Ключ, ДопСвойство.Значение);
		КонецЦикла;
	КонецЕсли;
	
	Возврат ДопСвойства;
	
КонецФункции

Функция ОпределитьВладельцаСертификата(Знач subjectName) Экспорт
	
	СтруктураВозврата = Новый Структура;
	СтруктураВозврата.Вставить("Имя");
	СтруктураВозврата.Вставить("Фамилия");
	СтруктураВозврата.Вставить("Отчествочество");
	СтруктураВозврата.Вставить("Фирма");
	СтруктураВозврата.Вставить("Должность");
	СтруктураВозврата.Вставить("КомуВыдан");
	
	Если ЗначениеЗаполнено(subjectName) Тогда
		// Имя
		НачалоName = Найти(subjectName, "NAME=") + 5;
		Name = Сред(subjectName, НачалоName);
		ПозицияЗапятой = Найти(Name, ",");
		Имя = Лев(Name, ПозицияЗапятой - 1);
		СтруктураВозврата.Вставить("Имя", Имя);
		// Фамилия
		НачалоSurname = Найти(subjectName, "SURNAME=") + 8;
		Surname = Сред(subjectName, НачалоSurname);
		ПозицияЗапятой = Найти(Surname, ",");
		Фамилия = Лев(Surname, ПозицияЗапятой - 1);
		СтруктураВозврата.Вставить("Фамилия", Фамилия);
		// Отчетство
		Отчество = "";
		СтруктураВозврата.Вставить("Отчество", Отчество);
		// Фирма
		НачалоФирма = Найти(subjectName, "O=") + 2;
		Фирма = Сред(subjectName, НачалоФирма);
		ПозицияЗапятой = Найти(Фирма, ",");
		Фирма = Лев(Фирма, ПозицияЗапятой - 1);
		СтруктураВозврата.Вставить("Фирма", Фирма);
		//Должность
		НачалоДолжность = Найти(subjectName, "OU=") + 3;
		Должность = Сред(subjectName, НачалоДолжность);
		ПозицияЗапятой = Найти(Должность, ",");
		Должность = Лев(Должность, ПозицияЗапятой - 1);
		СтруктураВозврата.Вставить("Должность", Должность);
		//КомуВыдан
		НачалоКомуВыдан = Найти(subjectName, "CN=") + 3;
		КомуВыдан = Сред(subjectName, НачалоКомуВыдан);
		ПозицияЗапятой = Найти(КомуВыдан, ",");
		КомуВыдан = Лев(КомуВыдан, ПозицияЗапятой - 1);
		СтруктураВозврата.Вставить("КомуВыдан", КомуВыдан);
	КонецЕсли;
	
	Возврат СтруктураВозврата;
	
КонецФункции

// Получает дату из строки
Функция ПолучитьДатуИзСтроки(Знач Строка, ФорматСтроки = 1) Экспорт
	Год = 1;
	Месяц = 1;
	День = 1;
	Час = 1;
	Минута = 1;
	Секунда = 1;
	
	Если ФорматСтроки = 1 Тогда
		Месяц = ПолучитьНомерМесяцаПоСокращенномуНаменованию(Лев(Строка, Найти(Строка, " ") - 1)); 
		День = Число(Сред(Строка, Найти(Строка, " ")+1, Найти(Строка, ",") - Найти(Строка, " ") - 1));
		Строка = Сред(Строка, Найти(Строка, ",") + 2);
		Год = Число(Лев(Строка, 4));
		Строка = Сред(Строка, Найти(Строка, " ") + 1);
		Час = Число(Лев(Строка, Найти(Строка, ":") - 1));
		Строка = Сред(Строка, Найти(Строка, ":") + 1);
		Минута = Число(Лев(Строка, Найти(Строка, ":") - 1));
		Строка = Сред(Строка, Найти(Строка, ":") + 1);
		Секунда = Число(Лев(Строка, Найти(Строка, " ") - 1));
		Строка = Сред(Строка, Найти(Строка, " ") + 1);
		
		Если Строка = "PM" Тогда
			Если Час = 12 Тогда
				Час = 0;
			Иначе 
				Час = Час + 12;
			КонецЕсли;
		КонецЕсли;
	Иначе
		Год = Число(Лев(Строка, Найти(Строка, ".") - 1));
		Строка = Сред(Строка, Найти(Строка, ".") + 1);
		Месяц = Число(Лев(Строка, Найти(Строка, ".") - 1));
		Строка = Сред(Строка, Найти(Строка, ".") + 1);
		День = Число(Лев(Строка, Найти(Строка, " ") - 1));
		Строка = Сред(Строка, Найти(Строка, " ") + 1);
		Час = Число(Лев(Строка, Найти(Строка, ":") - 1));
		Строка = Сред(Строка, Найти(Строка, ":") + 1);
		Минута = Число(Лев(Строка, Найти(Строка, ":") - 1));
		Строка = Сред(Строка, Найти(Строка, ":") + 1);
		Секунда = Число(Строка);
	КонецЕсли;
	
	
	Возврат Дата(Год, Месяц, День, Час, Минута, Секунда);

КонецФункции

Функция ПолучитьНомерМесяцаПоСокращенномуНаменованию(Строка)
	
	Если Строка = "Jan" Тогда
		Возврат 1;
	ИначеЕсли Строка = "Feb" Тогда
		Возврат 2;
	ИначеЕсли Строка = "Mar" Тогда
		Возврат 3;
	ИначеЕсли Строка = "Apr" Тогда
		Возврат 4;
	ИначеЕсли Строка = "May" Тогда
		Возврат 5;
	ИначеЕсли Строка = "Jun" Тогда
		Возврат 6;
	ИначеЕсли Строка = "Jul" Тогда
		Возврат 7;
	ИначеЕсли Строка = "Aug" Тогда
		Возврат 8;
	ИначеЕсли Строка = "Sept" Тогда
		Возврат 9;
	ИначеЕсли Строка = "Oct" Тогда
		Возврат 10;
	ИначеЕсли Строка = "Nov" Тогда
		Возврат 11;
	ИначеЕсли Строка = "Dec" Тогда
		Возврат 12;
	КонецЕсли;	
	
	Возврат "1";
	
КонецФункции

// ПРОЧИЕ ПРОЦЕДУРЫ И ФУНКЦИИ МОДУЛЯ //

// Из строк subjectName и alias собирает представление ключа
Функция ПолучитьПредставлениеКлюча(Certificate)
	Если Certificate.Получить("subjectName") <> Неопределено Тогда
		alias = Certificate.Получить("subjectName");
	ИначеЕсли Certificate.Получить("alias") <> Неопределено Тогда
		alias = Certificate.Получить("alias");
	Иначе
		Возврат "";
	КонецЕсли;
	Представление = "";
	Пока Истина Цикл
		Стр = "";
		ИндексРазделителя = Найти(alias, ",");
		Если ИндексРазделителя <> 0 Тогда
			Стр = Лев(alias, ИндексРазделителя - 1);
		Иначе
			Стр = alias;
		КонецЕсли;
		Стр = Сред(Стр, Найти(Стр, "=") + 1);
		Если Представление =  "" Тогда
			Представление = Стр;
		Иначе
			Представление = Представление + " " + Стр;
		КонецЕсли;
		Если ИндексРазделителя = 0 Тогда
			Прервать;
		КонецЕсли;
		alias = Сред(alias, ИндексРазделителя + 1) 
	КонецЦикла;
	Возврат Представление;
КонецФункции

Функция ПеревестиЧислоИзШестнадцатиричногоВДесятичное(СтрокаХекс)
	
	мСтрокаХекс = СокрЛП(СтрокаХекс);
	СтрДлинаХексЧисла = СтрДлина(мСтрокаХекс);
	ДесятичноеЧисло = 0;
	
	Для Сч = 0 По СтрДлинаХексЧисла-1 Цикл
		Множитель = Pow(16,Сч);
		НехЧисло1Байт = Сред(мСтрокаХекс,СтрДлинаХексЧисла-Сч,1);
		Если НехЧисло1Байт = "a" Тогда
			ДесятичноеЧисло = ДесятичноеЧисло + 10*Множитель;
		ИначеЕсли НехЧисло1Байт = "b" Тогда
			ДесятичноеЧисло = ДесятичноеЧисло + 11*Множитель;
		ИначеЕсли НехЧисло1Байт = "c" Тогда
			ДесятичноеЧисло = ДесятичноеЧисло + 12*Множитель;
		ИначеЕсли НехЧисло1Байт = "d" Тогда
			ДесятичноеЧисло = ДесятичноеЧисло + 13*Множитель;
		ИначеЕсли НехЧисло1Байт = "e" Тогда
			ДесятичноеЧисло = ДесятичноеЧисло + 14*Множитель;
		ИначеЕсли НехЧисло1Байт = "f" Тогда
			ДесятичноеЧисло = ДесятичноеЧисло + 15*Множитель;
		Иначе
			Попытка
				ДесятичноеЧисло = ДесятичноеЧисло + Число(НехЧисло1Байт)*Множитель;
			Исключение;
				//не число от 0 до 9
			КонецПопытки
		КонецЕсли;
	КонецЦикла;
	
	Возврат ДесятичноеЧисло;
	
КонецФункции

Процедура СоздатьBatФайлыУстановкиИУдаления(ПутьККаталогу, ИмяФайлаУстановки, ИмяФайлаУдаления)
	
	ТекстКоманды = 	ПолучитьСтрокуКодировки() + "
					|rem Run x32 installer
					|%SystemRoot%\Microsoft.NET\Framework\v4.0.30319\RegAsm.exe """ + ПутьККаталогу + "DidoxDLL_1_0.dll"" /codebase
					|if %processor_architecture%==AMD64 goto x64
					|exit
					|
					|:x64
					|rem Run x64 installer
					|%SystemRoot%\Microsoft.NET\Framework64\v4.0.30319\RegAsm.exe """ + ПутьККаталогу + "DidoxDLL_1_0.dll"" /codebase
					|exit";
	
	Запись = Новый ЗаписьТекста(ПутьККаталогу + ИмяФайлаУстановки, КодировкаТекста.ANSI);
	Запись.Записать(ТекстКоманды);
	Запись.Закрыть();
	
	ТекстКоманды = 	ПолучитьСтрокуКодировки() + "
					|rem Run x32 installer
					|%SystemRoot%\Microsoft.NET\Framework\v4.0.30319\RegAsm.exe """ + ПутьККаталогу + "DidoxDLL_1_0.dll"" /unregister
					|if %processor_architecture%==AMD64 goto x64
					|exit
					|
					|:x64
					|rem Run x64 installer
					|%SystemRoot%\Microsoft.NET\Framework64\v4.0.30319\RegAsm.exe """ + ПутьККаталогу + "DidoxDLL_1_0.dll"" /unregister
					|exit";
	
	Запись = Новый ЗаписьТекста(ПутьККаталогу + ИмяФайлаУдаления, КодировкаТекста.ANSI);
	Запись.Записать(ТекстКоманды);
	Запись.Закрыть();

КонецПроцедуры

Функция ПолучитьСтрокуКодировки()
	
	Возврат "@chcp 1251";	
	
КонецФункции

Функция ЗапуститьBatФайл(Путь)
	
	КомандаВыполненаУспешно = Ложь;
	
	Попытка
		WshShell = Новый COMОбъект("WScript.Shell");
		WshShell.Run(Путь, 2, 1);
		КомандаВыполненаУспешно = Истина;
	Исключение
		ОбщегоНазначенияКлиентСервер.СообщитьПользователю("Ошибка при установке компоненты Didox! Попробуйте запустить 1С от имени администратора!" +
			Символы.ПС + ОписаниеОшибки());
	КонецПопытки;
	
	Возврат КомандаВыполненаУспешно;
	
КонецФункции

Функция ПолучитьСтруктуруИзСоответствия(Соответствие)
	СтруктураВозврата = Новый Структура;
	Для каждого ЭлеменСоответствия Из Соответствие Цикл
		Попытка
			СтруктураВозврата.Вставить(ЭлеменСоответствия.Ключ, ЭлеменСоответствия.Значение);
		Исключение
		КонецПопытки
	КонецЦикла;
	Возврат СтруктураВозврата;
КонецФункции

Функция ПолучитьСтруктуруИзСпискаЗначений(СписокЗначений, СтруктураВозврата = Неопределено)
	Если Структуравозврата = Неопределено Тогда
		СтруктураВозврата = Новый Структура;
	КонецЕсли;
	Для каждого ЭлеменСпискаЗначений Из СписокЗначений Цикл
		Ключ = Лев(ЭлеменСпискаЗначений.Значение, Найти(ЭлеменСпискаЗначений.Значение, "=") - 1);
		Значение = Прав(ЭлеменСпискаЗначений.Значение, СтрДлина(ЭлеменСпискаЗначений.Значение) - Найти(ЭлеменСпискаЗначений.Значение, "="));
		Попытка
			СтруктураВозврата.Вставить(Ключ, Значение);
		Исключение
		КонецПопытки
	КонецЦикла;
	Возврат СтруктураВозврата;
КонецФункции

Функция DecodeBase64(СтрокаBase64, Кодировка)
	
	ДвоичныеДанные = Base64Значение(СтрокаBase64);
	Если ДвоичныеДанные = Неопределено Тогда
		// обработка исключения
	КонецЕсли;
	ВременныйФайл = ПолучитьИмяВременногоФайла();
	ДвоичныеДанные.Записать(ВременныйФайл);
	
	Чтение = Новый ЧтениеТекста(ВременныйФайл, Кодировка);
	Decoded = Чтение.Прочитать();
	Чтение.Закрыть();
	УдалитьФайлы(ВременныйФайл);
	
	Возврат Decoded;
	
КонецФункции

Функция ПолучитьТиповоеСоответствие()
	
	ТиповоеСоответствие = Новый Соответствие;
	ТиповоеСоответствие.Вставить("success", Ложь);
	
	Возврат ТиповоеСоответствие;
	
КонецФункции

Функция ПолучитьАктуальнуюВерсиюКомпоненты()
	
	Возврат "DidoxDLL_1_0";
	
КонецФункции

// <? DidoxEImzo

// ПРОЦЕДУРЫ И ФУНКЦИИ ДЛЯ ВЗАИМОДЕЙСТВИЯ С ДЛЛ-БИБЛИОТЕКОЙ

Функция DidoxEImzo_ПодключитьсяКСокетСерверу(DidoxEImzoDLL = Неопределено, ВыводитьСообщения = Ложь, БезПроверкиВерсии = Ложь)
	
	// Статусы подключения к компоненте ЭДО:
	// 0 - компонента не зарегистрирована
	// 1 - не запущено приложение E-Imzo
	// 2 - подключение установлено
	
	СтатусПодключения = 0;
	
	// ИНТЕГРАЦИЯ ГНК
	Если Не БезПроверкиВерсии 
		И Не ОбработчикиDidoxEImzoСервер.ВерсияКомпонентыАктуальна() Тогда
		Возврат СтатусПодключения;
	КонецЕсли;

	Попытка
		DidoxEImzoDLL 			= Новый COMОбъект("DidoxDLL_1_0" + ".WebSocketClient");
		ОтветВебСокетСервера 	= DidoxEImzoDLL.Connect();
	Исключение
		Если ВыводитьСообщения Тогда
			ОбщегоНазначенияКлиентСервер.СообщитьПользователю("Ошибка при подключении к компоненте ЭО! Возможно компонента не была зарегистрирована в системе.");
		КонецЕсли;
		Возврат СтатусПодключения;
	КонецПопытки;
	
	Если ОтветВебСокетСервера = "" Тогда
		ОбщегоНазначенияКлиентСервер.СообщитьПользователю("Ошибка при подключении к компоненте ЭО! Возможно не запущено приложение E-Imzo.");
		СтатусПодключения = 1;
	Иначе
		Соответствие = ЭлектронноеВзаимодействиеССерверомDidox.ПрочитатьСтрокуJSON(ОтветВебСокетСервера, Истина);
		Если Соответствие.Получить("success") Тогда
			СтатусПодключения = 2;
		КонецЕсли;
	КонецЕсли;
	
	Возврат СтатусПодключения;
	
КонецФункции

Функция DidoxEImzo_ПолучитьСписокНовыхКлючей(DidoxEImzoDLL)
	
	Соответствие = ПолучитьТиповоеСоответствие();
	
	Попытка
		ОтветВебСокетСервера = DidoxEImzoDLL.list_certificates_pfx();
	Исключение
		ОбщегоНазначенияКлиентСервер.СообщитьПользователю("Ошибка при получении списка новых ключей.");
		Возврат Соответствие;
	КонецПопытки;
	
	Если ОтветВебСокетСервера = Неопределено Тогда
		ОбщегоНазначенияКлиентСервер.СообщитьПользователю("Ошибка при подключении к компоненте ЭО! Возможно компонента не была зарегистрирована в системе.");
	Иначе
		Соответствие = ЭлектронноеВзаимодействиеССерверомDidox.ПрочитатьСтрокуJSON(ОтветВебСокетСервера, Истина);
	КонецЕсли;
	
	Возврат Соответствие;
	
КонецФункции

Функция DidoxEImzo_ПолучитьIDКлюча(ПараметрыЭЦП)
	
	Перем DidoxEImzoDLL;
	
	Соответствие = ПолучитьТиповоеСоответствие();
	СтатусПодключения = DidoxEImzo_ПодключитьсяКСокетСерверу(DidoxEImzoDLL);
	
	Если СтатусПодключения = 0 Тогда
		ОбработчикиDidoxEImzoСервер.ПодключитьФайлКомпонентыVenkonЭДО(СтатусПодключения, DidoxEImzoDLL);
	КонецЕсли;
	
	Если СтатусПодключения <> 2 Тогда
		Возврат Соответствие;
	КонецЕсли;
	
	Если ПараметрыЭЦП.plugin = "pfx" Тогда
				
		Попытка
			ОтветВебСокетСервера = DidoxEImzoDLL.load_key_pfx(Лев(ПараметрыЭЦП.disk, 2), ПараметрыЭЦП.path, ПараметрыЭЦП.file_name, ПараметрыЭЦП.alias);
		Исключение
			Возврат Соответствие;
		КонецПопытки;
		
		Если ОтветВебСокетСервера = Неопределено Тогда
			ОбщегоНазначенияКлиентСервер.СообщитьПользователю("Ошибка при загрузке ключа ЭЦП! Возможно компонента не была зарегистрирована в системе.");
		Иначе
			Соответствие = ЭлектронноеВзаимодействиеССерверомDidox.ПрочитатьСтрокуJSON(ОтветВебСокетСервера, Истина);
		КонецЕсли;
		
	Иначе
		ОбщегоНазначенияКлиентСервер.СообщитьПользователю("Не верный формат ключа ЭЦП!");
	КонецЕсли;
	
	Возврат Соответствие;
	
КонецФункции

Функция DidoxEImzo_Подписать(value, keyId, СертификатЭЦП = Неопределено)
	
	Перем DidoxEImzoDLL;
	Соответствие = ПолучитьТиповоеСоответствие();
	СтатусПодключения = DidoxEImzo_ПодключитьсяКСокетСерверу(DidoxEImzoDLL);
	
	Если СтатусПодключения = 0 Тогда
		ОбработчикиDidoxEImzoСервер.ПодключитьФайлКомпонентыVenkonЭДО(СтатусПодключения, DidoxEImzoDLL);
	КонецЕсли;
	
	Если СтатусПодключения <> 2 Тогда
		Возврат Соответствие;
	КонецЕсли;
	
	Попытка
		ОтветВебСокетСервера = DidoxEImzoDLL.create_pkcs7(value, keyId);
	Исключение
		ОбщегоНазначенияКлиентСервер.СообщитьПользователю("Произошли ошибки при подписании файла!");
		Возврат Неопределено;
	КонецПопытки;
	
	Если ОтветВебСокетСервера = Неопределено Тогда
		ОбщегоНазначенияКлиентСервер.СообщитьПользователю("Произошли ошибки при подписании файла!");
	Иначе
		Соответствие = ЭлектронноеВзаимодействиеССерверомDidox.ПрочитатьСтрокуJSON(ОтветВебСокетСервера, Истина);
		Если Соответствие.Получить("success") = Неопределено ИЛИ Соответствие.Получить("success") = Ложь Тогда
			// Еще раз загружаем IDКлюча 
			Если СертификатЭЦП <> Неопределено Тогда
				keyId = ПолучитьЗагрузитьIDКлюча(СертификатЭЦП, Истина);													
				Если keyId = Неопределено Тогда													
					Возврат Неопределено;
				КонецЕсли;
				
				Попытка
					ОтветВебСокетСервера = DidoxEImzoDLL.create_pkcs7(value, keyId);
				Исключение
					ОбщегоНазначенияКлиентСервер.СообщитьПользователю("Произошли ошибки при подписании файла!");
					Возврат Неопределено;
				КонецПопытки;
				
				Соответствие = ЭлектронноеВзаимодействиеССерверомDidox.ПрочитатьСтрокуJSON(ОтветВебСокетСервера, Истина);
				Если Соответствие.Получить("success") = Неопределено ИЛИ Соответствие.Получить("success") = Ложь Тогда
					ОбщегоНазначенияКлиентСервер.СообщитьПользователю("Введен неправильный пароль!");
					Возврат Неопределено;
				КонецЕсли;
			Иначе
				ОбщегоНазначенияКлиентСервер.СообщитьПользователю("Введен неправильный пароль!");
				Возврат Неопределено;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	Возврат Соответствие;
КонецФункции

Функция DidoxEImzo_ПолучитьИнформациюОПодписи(value)
	
	Перем DidoxEImzoDLL;
	Соответствие = ПолучитьТиповоеСоответствие();
	СтатусПодключения = DidoxEImzo_ПодключитьсяКСокетСерверу(DidoxEImzoDLL);
	
	Если СтатусПодключения = 0 Тогда
		ОбработчикиDidoxEImzoСервер.ПодключитьФайлКомпонентыVenkonЭДО(СтатусПодключения, DidoxEImzoDLL);
	КонецЕсли;
	
	Если СтатусПодключения <> 2 Тогда
		Возврат Соответствие;
	КонецЕсли;
	
	Попытка
		ОтветВебСокетСервера = DidoxEImzoDLL.get_pkcs7_attached_info(value);
	Исключение
	КонецПопытки;
	
	Если ОтветВебСокетСервера = Неопределено Тогда
		ОбщегоНазначенияКлиентСервер.СообщитьПользователю("Ошибка при подключении к компоненте ЭО! Возможно компонента не была зарегистрирована в системе.");
	Иначе
		Соответствие = ЭлектронноеВзаимодействиеССерверомDidox.ПрочитатьСтрокуJSON(ОтветВебСокетСервера, Истина);
	КонецЕсли;
	
	Возврат Соответствие;
	
КонецФункции

Функция DidoxEImzo_ВерификацияПароля(value)
	
	Перем DidoxEImzoDLL;
	Соответствие = ПолучитьТиповоеСоответствие();
	СтатусПодключения = DidoxEImzo_ПодключитьсяКСокетСерверу(DidoxEImzoDLL);
	
	Если СтатусПодключения = 0 Тогда
		ОбработчикиDidoxEImzoСервер.ПодключитьФайлКомпонентыVenkonЭДО(СтатусПодключения, DidoxEImzoDLL);
	КонецЕсли;
	
	Если СтатусПодключения <> 2 Тогда
		Возврат Соответствие;
	КонецЕсли;
	
	Попытка
		ОтветВебСокетСервера = DidoxEImzoDLL.verify_password(value);
	Исключение
	КонецПопытки;
	
	Если ОтветВебСокетСервера = Неопределено Тогда
		ОбщегоНазначенияКлиентСервер.СообщитьПользователю("Ошибка при подключении к компоненте ЭО! Возможно компонента не была зарегистрирована в системе.");
	Иначе
		Соответствие = ЭлектронноеВзаимодействиеССерверомDidox.ПрочитатьСтрокуJSON(ОтветВебСокетСервера, Истина);
	КонецЕсли;
	
	Возврат Соответствие;
	
КонецФункции

Функция DidoxEImzo_ПолучитьЦепочкуСертификатов(value)
	
	Перем DidoxEImzoDLL;
	Соответствие = ПолучитьТиповоеСоответствие();
	СтатусПодключения = DidoxEImzo_ПодключитьсяКСокетСерверу(DidoxEImzoDLL);
	
	Если СтатусПодключения = 0 Тогда
		ОбработчикиDidoxEImzoСервер.ПодключитьФайлКомпонентыVenkonЭДО(СтатусПодключения, DidoxEImzoDLL);
	КонецЕсли;
	
	Если СтатусПодключения <> 2 Тогда
		Возврат Соответствие;
	КонецЕсли;
	
	Попытка
		ОтветВебСокетСервера = DidoxEImzoDLL.get_certificate_chain(value);
	Исключение
	КонецПопытки;
	
	Если ОтветВебСокетСервера = Неопределено Тогда
		ОбщегоНазначенияКлиентСервер.СообщитьПользователю("Ошибка при подключении к компоненте ЭО! Возможно компонента не была зарегистрирована в системе.");
	Иначе
		Соответствие = ЭлектронноеВзаимодействиеССерверомDidox.ПрочитатьСтрокуJSON(ОтветВебСокетСервера, Истина);
	КонецЕсли;
	
	Возврат Соответствие;
	
КонецФункции

Функция DidoxEImzo_ПолучитьИнформациюОСертификате(value)
	
	Перем DidoxEImzoDLL;
	Соответствие = ПолучитьТиповоеСоответствие();
	СтатусПодключения = DidoxEImzo_ПодключитьсяКСокетСерверу(DidoxEImzoDLL);
	
	Если СтатусПодключения = 0 Тогда
		ОбработчикиDidoxEImzoСервер.ПодключитьФайлКомпонентыVenkonЭДО(СтатусПодключения, DidoxEImzoDLL);
	КонецЕсли;
	
	Если СтатусПодключения <> 2 Тогда
		Возврат Соответствие;
	КонецЕсли;

	Попытка
		ОтветВебСокетСервера = DidoxEImzoDLL.get_certificate_info(value);
	Исключение
	КонецПопытки;
	
	Если ОтветВебСокетСервера = Неопределено Тогда
		ОбщегоНазначенияКлиентСервер.СообщитьПользователю("Ошибка при подключении к компоненте ЭО! Возможно компонента не была зарегистрирована в системе.");
	Иначе
		Соответствие = ЭлектронноеВзаимодействиеССерверомDidox.ПрочитатьСтрокуJSON(ОтветВебСокетСервера, Истина);
	КонецЕсли;
	
	Возврат Соответствие;
	
КонецФункции

// DidoxEImzo ?>
