
Функция ПолучитьIDКлючаИзРегистра(СертификатЭЦП) Экспорт
	
	IDКлюча = Неопределено;
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	УникальныеИдентификаторыСертификатовЭЦПСрезПоследних.УникальныйИдентификатор
	|ИЗ
	|	РегистрСведений.УникальныеИдентификаторыСертификатовЭЦП.СрезПоследних(&Период, СертфикатЭЦП = &СертфикатЭЦП) КАК УникальныеИдентификаторыСертификатовЭЦПСрезПоследних";
	
	Запрос.УстановитьПараметр("Период", ТекущаяДата());
	Запрос.УстановитьПараметр("СертфикатЭЦП", СертификатЭЦП);
	
	УстановитьПривилегированныйРежим(Истина);
	
	РезультатЗапроса = Запрос.Выполнить();
	Если Не РезультатЗапроса.Пустой() Тогда
	
		ВыборкаДетальныеЗаписи = РезультатЗапроса.Выбрать();
		ВыборкаДетальныеЗаписи.Следующий();
		
		IDКлюча = ВыборкаДетальныеЗаписи.УникальныйИдентификатор;
		
	КонецЕсли;
	
	Возврат IDКлюча;
	
КонецФункции

Процедура СохранитьIDКлючаВРегистр(СертфикатЭЦП, IDКлюча) Экспорт
	
	МенеджерЗаписи = РегистрыСведений.УникальныеИдентификаторыСертификатовЭЦП.СоздатьМенеджерЗаписи();
	МенеджерЗаписи.Период = ТекущаяДата();
	МенеджерЗаписи.УникальныйИдентификатор = IDКлюча;
	МенеджерЗаписи.СертфикатЭЦП = СертфикатЭЦП;
	
	МенеджерЗаписи.Записать();
	
КонецПроцедуры

Функция ПолучитьДвоичныеДанныеКомпоненты() Экспорт
	
	Возврат ПолучитьОбщийМакет("DidoxDLL_1_0");

КонецФункции

Функция ПолучитьНеобходимыеРеквизитыИзСтруктурыСертификата(СтруктураСертификата, НеобходимыеРеквизиты) Экспорт
	 СтруктураВозврата = Новый Структура;
	 МассивНеобходимыхРеквизитов = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрокЭД(СтрЗаменить(НеобходимыеРеквизиты, " ", ""), ",", Истина);
	 Для каждого ИмяРеквизита Из МассивНеобходимыхРеквизитов Цикл
		 Если ИмяРеквизита = "КомуВыдан" Тогда
			 КомуВыдан = ТРег(СтруктураСертификата["cn"]);
			 СтруктураВозврата.Вставить("КомуВыдан", КомуВыдан);
		 ИначеЕсли ИмяРеквизита = "ДействителенДо" Тогда
			 validTo = ВРег(СтруктураСертификата["validTo"]);
			 ДействителенДо = ПолучитьДатуИзСтроки(validTo, 2);
			 СтруктураВозврата.Вставить("ДействителенДо", ДействителенДо);
		 КонецЕсли;
	 КонецЦикла;
	 
	 Возврат СтруктураВозврата;
	
КонецФункции

// Получает дату из строки
Функция ПолучитьДатуИзСтроки(Знач Строка, ФорматСтроки = 1) Экспорт
	Год = 1;
	Месяц = 1;
	День = 1;
	Час = 1;
	Минута = 1;
	Секунда = 1;
	
	Если ФорматСтроки = 1 Тогда
		Месяц = ПолучитьНомерМесяцаПоСокращенномуНаменованию(Лев(Строка, Найти(Строка, " ") - 1)); 
		День = Число(Сред(Строка, Найти(Строка, " ")+1, Найти(Строка, ",") - Найти(Строка, " ") - 1));
		Строка = Сред(Строка, Найти(Строка, ",") + 2);
		Год = Число(Лев(Строка, 4));
		Строка = Сред(Строка, Найти(Строка, " ") + 1);
		Час = Число(Лев(Строка, Найти(Строка, ":") - 1));
		Строка = Сред(Строка, Найти(Строка, ":") + 1);
		Минута = Число(Лев(Строка, Найти(Строка, ":") - 1));
		Строка = Сред(Строка, Найти(Строка, ":") + 1);
		Секунда = Число(Лев(Строка, Найти(Строка, " ") - 1));
		Строка = Сред(Строка, Найти(Строка, " ") + 1);
		
		Если Строка = "PM" Тогда
			Если Час = 12 Тогда
				Час = 0;
			Иначе 
				Час = Час + 12;
			КонецЕсли;
		КонецЕсли;
	Иначе
		Год = Число(Лев(Строка, Найти(Строка, ".") - 1));
		Строка = Сред(Строка, Найти(Строка, ".") + 1);
		Месяц = Число(Лев(Строка, Найти(Строка, ".") - 1));
		Строка = Сред(Строка, Найти(Строка, ".") + 1);
		День = Число(Лев(Строка, Найти(Строка, " ") - 1));
		Строка = Сред(Строка, Найти(Строка, " ") + 1);
		Час = Число(Лев(Строка, Найти(Строка, ":") - 1));
		Строка = Сред(Строка, Найти(Строка, ":") + 1);
		Минута = Число(Лев(Строка, Найти(Строка, ":") - 1));
		Строка = Сред(Строка, Найти(Строка, ":") + 1);
		Секунда = Число(Строка);
	КонецЕсли;
	
	
	Возврат Дата(Год, Месяц, День, Час, Минута, Секунда);

КонецФункции

Функция ПолучитьНомерМесяцаПоСокращенномуНаменованию(Строка)
	
	Если Строка = "Jan" Тогда
		Возврат 1;
	ИначеЕсли Строка = "Feb" Тогда
		Возврат 2;
	ИначеЕсли Строка = "Mar" Тогда
		Возврат 3;
	ИначеЕсли Строка = "Apr" Тогда
		Возврат 4;
	ИначеЕсли Строка = "May" Тогда
		Возврат 5;
	ИначеЕсли Строка = "Jun" Тогда
		Возврат 6;
	ИначеЕсли Строка = "Jul" Тогда
		Возврат 7;
	ИначеЕсли Строка = "Aug" Тогда
		Возврат 8;
	ИначеЕсли Строка = "Sept" Тогда
		Возврат 9;
	ИначеЕсли Строка = "Oct" Тогда
		Возврат 10;
	ИначеЕсли Строка = "Nov" Тогда
		Возврат 11;
	ИначеЕсли Строка = "Dec" Тогда
		Возврат 12;
	КонецЕсли;	
	
	Возврат "1";
	
КонецФункции

Функция ПолучитьИнформациюОПодписи(ПодписаннаяСтрока) Экспорт
	
	ИнформацияОПодписиСоответствие = DidoxEImzo_ПолучитьИнформациюОПодписи(ПодписаннаяСтрока);
	Если ИнформацияОПодписиСоответствие = Неопределено ИЛИ НЕ ИнформацияОПодписиСоответствие.Получить("success")  Тогда
		ОбщегоНазначенияКлиентСервер.СообщитьПользователю("Произошла ошибка при получении информации о подписи");
		Возврат Неопределено;
	КонецЕсли;
	ИнформацияОПодписиСтруктура = ПолучитьСтруктуруИзСоответствия(ИнформацияОПодписиСоответствие);
	
	// Декодируем Base64-строку
	pkcs7Info = ИнформацияОПодписиСтруктура.pkcs7Info;
	documentBase64 = pkcs7Info.Получить("documentBase64");
	document = DecodeBase64(documentBase64, КодировкаТекста.UTF8);  //КодировкаТекста.ANSI
	ИнформацияОПодписиСтруктура.pkcs7Info.Вставить("document", document);
	
	Возврат ИнформацияОПодписиСтруктура;
	
КонецФункции

Функция ОпределитьВладельцаСертификата(Знач subjectName) Экспорт
	
	СтруктураВозврата = Новый Структура;
	СтруктураВозврата.Вставить("Имя");
	СтруктураВозврата.Вставить("Фамилия");
	СтруктураВозврата.Вставить("Отчествочество");
	СтруктураВозврата.Вставить("Фирма");
	СтруктураВозврата.Вставить("Должность");
	СтруктураВозврата.Вставить("КомуВыдан");
	
	Если ЗначениеЗаполнено(subjectName) Тогда
		// Имя
		НачалоName = Найти(subjectName, "NAME=") + 5;
		Name = Сред(subjectName, НачалоName);
		ПозицияЗапятой = Найти(Name, ",");
		Имя = Лев(Name, ПозицияЗапятой - 1);
		СтруктураВозврата.Вставить("Имя", Имя);
		// Фамилия
		НачалоSurname = Найти(subjectName, "SURNAME=") + 8;
		Surname = Сред(subjectName, НачалоSurname);
		ПозицияЗапятой = Найти(Surname, ",");
		Фамилия = Лев(Surname, ПозицияЗапятой - 1);
		СтруктураВозврата.Вставить("Фамилия", Фамилия);
		// Отчетство
		Отчество = "";
		СтруктураВозврата.Вставить("Отчество", Отчество);
		// Фирма
		НачалоФирма = Найти(subjectName, "O=") + 2;
		Фирма = Сред(subjectName, НачалоФирма);
		ПозицияЗапятой = Найти(Фирма, ",");
		Фирма = Лев(Фирма, ПозицияЗапятой - 1);
		СтруктураВозврата.Вставить("Фирма", Фирма);
		//Должность
		НачалоДолжность = Найти(subjectName, "OU=") + 3;
		Должность = Сред(subjectName, НачалоДолжность);
		ПозицияЗапятой = Найти(Должность, ",");
		Должность = Лев(Должность, ПозицияЗапятой - 1);
		СтруктураВозврата.Вставить("Должность", Должность);
		//КомуВыдан
		НачалоКомуВыдан = Найти(subjectName, "CN=") + 3;
		КомуВыдан = Сред(subjectName, НачалоКомуВыдан);
		ПозицияЗапятой = Найти(КомуВыдан, ",");
		КомуВыдан = Лев(КомуВыдан, ПозицияЗапятой - 1);
		СтруктураВозврата.Вставить("КомуВыдан", КомуВыдан);
	КонецЕсли;
	
	Возврат СтруктураВозврата;
	
КонецФункции

Функция DidoxEImzo_ПолучитьИнформациюОПодписи(value)
	
	Перем DidoxEImzoDLL;
	Соответствие = ПолучитьТиповоеСоответствие();
	СтатусПодключения = DidoxEImzo_ПодключитьсяКСокетСерверу(DidoxEImzoDLL);
	
	Если СтатусПодключения = 0 Тогда
		ПодключитьФайлКомпонентыVenkonЭДО(СтатусПодключения, DidoxEImzoDLL);
	КонецЕсли;
	
	Если СтатусПодключения <> 2 Тогда
		Возврат Соответствие;
	КонецЕсли;
	
	Попытка
		ОтветВебСокетСервера = DidoxEImzoDLL.get_pkcs7_attached_info(value);
	Исключение
	КонецПопытки;
	
	Если ОтветВебСокетСервера = Неопределено Тогда
		ОбщегоНазначенияКлиентСервер.СообщитьПользователю("Ошибка при подключении к компоненте ЭО! Возможно компонента не была зарегистрирована в системе.");
	Иначе
		Соответствие = ЭлектронноеВзаимодействиеССерверомDidox.ПрочитатьСтрокуJSON(ОтветВебСокетСервера, Истина);
	КонецЕсли;
	
	Возврат Соответствие;
	
КонецФункции

Функция DecodeBase64(СтрокаBase64, Кодировка)
	
	ДвоичныеДанные = Base64Значение(СтрокаBase64);
	Если ДвоичныеДанные = Неопределено Тогда
		// обработка исключения
	КонецЕсли;
	ВременныйФайл = ПолучитьИмяВременногоФайла();
	ДвоичныеДанные.Записать(ВременныйФайл);
	
	Чтение = Новый ЧтениеТекста(ВременныйФайл, Кодировка);
	Decoded = Чтение.Прочитать();
	Чтение.Закрыть();
	УдалитьФайлы(ВременныйФайл);
	
	Возврат Decoded;
	
КонецФункции

Функция ПолучитьСтруктуруИзСоответствия(Соответствие)
	СтруктураВозврата = Новый Структура;
	Для каждого ЭлеменСоответствия Из Соответствие Цикл
		Попытка
			СтруктураВозврата.Вставить(ЭлеменСоответствия.Ключ, ЭлеменСоответствия.Значение);
		Исключение
		КонецПопытки
	КонецЦикла;
	Возврат СтруктураВозврата;
КонецФункции

Функция ПолучитьТиповоеСоответствие()
	
	ТиповоеСоответствие = Новый Соответствие;
	ТиповоеСоответствие.Вставить("success", Ложь);
	
	Возврат ТиповоеСоответствие;
	
КонецФункции

Функция DidoxEImzo_ПодключитьсяКСокетСерверу(DidoxEImzoDLL = Неопределено, ВыводитьСообщения = Ложь, БезПроверкиВерсии = Ложь)
	
	// Статусы подключения к компоненте ЭДО:
	// 0 - компонента не зарегистрирована
	// 1 - не запущено приложение E-Imzo
	// 2 - подключение установлено
	
	СтатусПодключения = 0;
	
	// ИНТЕГРАЦИЯ ГНК
	Если Не БезПроверкиВерсии 
		И Не ОбработчикиDidoxEImzoСервер.ВерсияКомпонентыАктуальна() Тогда
		Возврат СтатусПодключения;
	КонецЕсли;

	Попытка
		DidoxEImzoDLL 			= Новый COMОбъект("DidoxDLL_1_0" + ".WebSocketClient");
		ОтветВебСокетСервера 	= DidoxEImzoDLL.Connect();
	Исключение
		Если ВыводитьСообщения Тогда
			ОбщегоНазначенияКлиентСервер.СообщитьПользователю("Ошибка при подключении к компоненте ЭО! Возможно компонента не была зарегистрирована в системе.");
		КонецЕсли;
		Возврат СтатусПодключения;
	КонецПопытки;
	
	Если ОтветВебСокетСервера = "" Тогда
		ОбщегоНазначенияКлиентСервер.СообщитьПользователю("Ошибка при подключении к компоненте ЭО! Возможно не запущено приложение E-Imzo.");
		СтатусПодключения = 1;
	Иначе
		Соответствие = ЭлектронноеВзаимодействиеССерверомDidox.ПрочитатьСтрокуJSON(ОтветВебСокетСервера, Истина);
		Если Соответствие.Получить("success") Тогда
			СтатусПодключения = 2;
		КонецЕсли;
	КонецЕсли;
	
	Возврат СтатусПодключения;
	
КонецФункции

Процедура ПодключитьФайлКомпонентыVenkonЭДО(СтатусПодключения, DidoxEImzoDLL = Неопределено) Экспорт
	
	КаталогФайлов = КаталогВременныхФайлов() + "DidoxDLL";
	СоздатьКаталог(КаталогФайлов);
	
	ИмяZipАрхива = КаталогФайлов + "\DidoxDLL_1_0.zip";
	
	ДвоичныеДанные = ОбработчикиDidoxEImzoСервер.ПолучитьДвоичныеДанныеКомпоненты();
	ДвоичныеДанные.Записать(ИмяZipАрхива);
	
	ЧтениеZipФайла = Новый ЧтениеZipФайла(ИмяZipАрхива);
	ЧтениеZipФайла.ИзвлечьВсе(КаталогФайлов, РежимВосстановленияПутейФайловZIP.НеВосстанавливать);
	ЧтениеZipФайла.Закрыть();
	
	УдалитьФайлы(ИмяZipАрхива);
	
	УстановкаУспешна = УстановитьКомпоненту(КаталогФайлов);
	Если УстановкаУспешна Тогда
		СтатусПодключения = DidoxEImzo_ПодключитьсяКСокетСерверу(DidoxEImzoDLL, Истина, Истина);
		// Проверяем новые функции
		Если СтатусПодключения = 2 Тогда
			Ответ1 = Неопределено;
			Ответ2 = Неопределено;
			
			Попытка
				Ответ1 = DidoxEImzoDLL.append_pkcs7_attached("", "");
			Исключение
			КонецПопытки;
			
			Попытка
				Ответ2 = DidoxEImzoDLL.attach_timestamp_token_pkcs7("", "", "");
			Исключение
			КонецПопытки;
			
			Если Ответ1 <> Неопределено
				И Ответ2 <> Неопределено Тогда
				АктуальнаяВерсия = ПолучитьАктуальнуюВерсиюКомпоненты();
				Константы.ВерсияКомпонентыEImzo.Установить(АктуальнаяВерсия);
			Иначе
				СтатусПодключения = 0;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры // ПолучитьФайлЭФО20()

Функция ПолучитьАктуальнуюВерсиюКомпоненты()
	
	МакетВерсий = Обработки.ЭлектронныеДокументы.ПолучитьМакет("ВерсииКомпонентыEImzo");
	
	НомерСтолбца = 1;
	НомерСтроки = МакетВерсий.ВысотаТаблицы;
	Ячейка = МакетВерсий.Область(НомерСтроки, НомерСтолбца, НомерСтроки, НомерСтолбца);
	Если Ячейка.СодержитЗначение Тогда
		АктуальнаяВерсия = Ячейка.Значение;
	Иначе
		АктуальнаяВерсия = Ячейка.Текст;
	КонецЕсли;
	
	Возврат АктуальнаяВерсия;
	
КонецФункции

Функция УстановитьКомпоненту(Знач ПутьККаталогу) Экспорт
	
	Если ПустаяСтрока(ПутьККаталогу) Тогда
		ПутьККаталогу = КаталогВременныхФайлов();
	КонецЕсли;
	
	ИмяФайлаУстановки 	= "Install.bat";
	ИмяФайлаУдаления 	= "Uninstall.bat";
	
	Если Не Прав(ПутьККаталогу, 1) = "\" Тогда
		ПутьККаталогу = ПутьККаталогу + "\";
	КонецЕсли;
	
	СоздатьBatФайлыУстановкиИУдаления(ПутьККаталогу, ИмяФайлаУстановки, ИмяФайлаУдаления);
	
	КомандаВыполненаУспешно = ЗапуститьBatФайл(ПутьККаталогу + ИмяФайлаУстановки);
	
	Возврат КомандаВыполненаУспешно;	
	
КонецФункции

Процедура СоздатьBatФайлыУстановкиИУдаления(ПутьККаталогу, ИмяФайлаУстановки, ИмяФайлаУдаления)
	
	ТекстКоманды = 	ПолучитьСтрокуКодировки() + "
					|rem Run x32 installer
					|%SystemRoot%\Microsoft.NET\Framework\v4.0.30319\RegAsm.exe """ + ПутьККаталогу + "DidoxDLL_1_0.dll"" /codebase
					|if %processor_architecture%==AMD64 goto x64
					|exit
					|
					|:x64
					|rem Run x64 installer
					|%SystemRoot%\Microsoft.NET\Framework64\v4.0.30319\RegAsm.exe """ + ПутьККаталогу + "DidoxDLL_1_0.dll"" /codebase
					|exit";
	
	Запись = Новый ЗаписьТекста(ПутьККаталогу + ИмяФайлаУстановки, КодировкаТекста.ANSI);
	Запись.Записать(ТекстКоманды);
	Запись.Закрыть();
	
	ТекстКоманды = 	ПолучитьСтрокуКодировки() + "
					|rem Run x32 installer
					|%SystemRoot%\Microsoft.NET\Framework\v4.0.30319\RegAsm.exe """ + ПутьККаталогу + "DidoxDLL_1_0.dll"" /unregister
					|if %processor_architecture%==AMD64 goto x64
					|exit
					|
					|:x64
					|rem Run x64 installer
					|%SystemRoot%\Microsoft.NET\Framework64\v4.0.30319\RegAsm.exe """ + ПутьККаталогу + "DidoxDLL_1_0.dll"" /unregister
					|exit";
	
	Запись = Новый ЗаписьТекста(ПутьККаталогу + ИмяФайлаУдаления, КодировкаТекста.ANSI);
	Запись.Записать(ТекстКоманды);
	Запись.Закрыть();

КонецПроцедуры

Функция ЗапуститьBatФайл(Путь)
	
	КомандаВыполненаУспешно = Ложь;
	
	Попытка
		WshShell = Новый COMОбъект("WScript.Shell");
		WshShell.Run(Путь, 2, 1);
		КомандаВыполненаУспешно = Истина;
	Исключение
		ОбщегоНазначенияКлиентСервер.СообщитьПользователю("Ошибка при установке компоненты Didox! Попробуйте запустить 1С от имени администратора!" +
			Символы.ПС + ОписаниеОшибки());
	КонецПопытки;
	
	Возврат КомандаВыполненаУспешно;
	
КонецФункции

Функция ПолучитьСтрокуКодировки()
	
	Возврат "@chcp 1251";	
	
КонецФункции

Функция ВерсияКомпонентыАктуальна() Экспорт
	
	АктуальнаяВерсия = ПолучитьАктуальнуюВерсиюКомпоненты();
	
	УстановленнаяВерсия = Константы.ВерсияКомпонентыEImzo.Получить();
	
	Возврат АктуальнаяВерсия = УстановленнаяВерсия;
	
КонецФункции

Функция ПолучитьЗагрузитьIDКлюча(СертификатЭЦП, ЗагрузитьID = Ложь) Экспорт
	
	IDКлюча = ОбработчикиDidoxEImzoСервер.ПолучитьIDКлючаИзРегистра(СертификатЭЦП);
	
	Если ПустаяСтрока(IDКлюча) ИЛИ ЗагрузитьID Тогда
				
		ПараметрыЭЦП = ОбщегоНазначенияВызовСервера.ЗначенияРеквизитовОбъекта(СертификатЭЦП, 
			"plugin, disk, path, name, file_name, serialNumber, alias");
		
		СоответствиеIDКлюча = DidoxEImzo_ПолучитьIDКлюча(ПараметрыЭЦП);
		
		Если Не СоответствиеIDКлюча.Получить("success") Тогда													
			ОбщегоНазначенияКлиентСервер.СообщитьПользователю("Не удалось загрузить сертфикат ЭЦП!");
			Возврат Неопределено;
		КонецЕсли;
		
		IDКлюча = СоответствиеIDКлюча.Получить("keyId");
		
		ОбработчикиDidoxEImzoСервер.СохранитьIDКлючаВРегистр(СертификатЭЦП, IDКлюча);
		
	КонецЕсли;
	
	Возврат IDКлюча;
	
КонецФункции

Функция DidoxEImzo_ПолучитьIDКлюча(ПараметрыЭЦП)
	
	Перем DidoxEImzoDLL;
	
	Соответствие = ПолучитьТиповоеСоответствие();
	СтатусПодключения = DidoxEImzo_ПодключитьсяКСокетСерверу(DidoxEImzoDLL);
	
	Если СтатусПодключения = 0 Тогда
		ПодключитьФайлКомпонентыVenkonЭДО(СтатусПодключения, DidoxEImzoDLL);
	КонецЕсли;
	
	Если СтатусПодключения <> 2 Тогда
		Возврат Соответствие;
	КонецЕсли;
	
	Если ПараметрыЭЦП.plugin = "pfx" Тогда
				
		Попытка
			ОтветВебСокетСервера = DidoxEImzoDLL.load_key_pfx(Лев(ПараметрыЭЦП.disk, 2), ПараметрыЭЦП.path, ПараметрыЭЦП.file_name, ПараметрыЭЦП.alias);
		Исключение
			Возврат Соответствие;
		КонецПопытки;
		
		Если ОтветВебСокетСервера = Неопределено Тогда
			ОбщегоНазначенияКлиентСервер.СообщитьПользователю("Ошибка при загрузке ключа ЭЦП! Возможно компонента не была зарегистрирована в системе.");
		Иначе
			Соответствие = ЭлектронноеВзаимодействиеССерверомDidox.ПрочитатьСтрокуJSON(ОтветВебСокетСервера, Истина);
		КонецЕсли;
		
	Иначе
		ОбщегоНазначенияКлиентСервер.СообщитьПользователю("Не верный формат ключа ЭЦП!");
	КонецЕсли;
	
	Возврат Соответствие;
	
КонецФункции

// Подписывает строку и ответ возвращает строкой
Функция ПодписатьСтроку(СтрокаКПодписи, keyId, СертификатЭЦП, serialNumber = Неопределено, УстановитьШтампВремени = Ложь) Экспорт
	
    ПодписаннаяСтрокаСоответствие = DidoxEImzo_Подписать(СтрокаКПодписи, keyId, СертификатЭЦП);
	
	Если  ПодписаннаяСтрокаСоответствие = Неопределено ИЛИ НЕ ПодписаннаяСтрокаСоответствие.Получить("success") Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	pkcs7_64 = ПодписаннаяСтрокаСоответствие.Получить("pkcs7_64");
	serialNumber = ПодписаннаяСтрокаСоответствие.Получить("signer_serial_number");
	signature_hex = ПодписаннаяСтрокаСоответствие.Получить("signature_hex");
	
	// Устанавливаем штамп времени
	Если УстановитьШтампВремени Тогда
		
		pkcs7_64 = УстановитьШтампВремени(pkcs7_64, serialNumber, signature_hex);
		
	КонецЕсли;
	
	Возврат ПодписаннаяСтрокаСоответствие.Получить("pkcs7_64");
	
КонецФункции

Функция DidoxEImzo_Подписать(value, keyId, СертификатЭЦП = Неопределено)
	
	Перем DidoxEImzoDLL;
	Соответствие = ПолучитьТиповоеСоответствие();
	СтатусПодключения = DidoxEImzo_ПодключитьсяКСокетСерверу(DidoxEImzoDLL);
	
	Если СтатусПодключения = 0 Тогда
		ПодключитьФайлКомпонентыVenkonЭДО(СтатусПодключения, DidoxEImzoDLL);
	КонецЕсли;
	
	Если СтатусПодключения <> 2 Тогда
		Возврат Соответствие;
	КонецЕсли;
	
	Попытка
		ОтветВебСокетСервера = DidoxEImzoDLL.create_pkcs7(value, keyId);
	Исключение
		ОбщегоНазначенияКлиентСервер.СообщитьПользователю("Произошли ошибки при подписании файла!");
		Возврат Неопределено;
	КонецПопытки;
	
	Если ОтветВебСокетСервера = Неопределено Тогда
		ОбщегоНазначенияКлиентСервер.СообщитьПользователю("Произошли ошибки при подписании файла!");
	Иначе
		Соответствие = ЭлектронноеВзаимодействиеССерверомDidox.ПрочитатьСтрокуJSON(ОтветВебСокетСервера, Истина);
		Если Соответствие.Получить("success") = Неопределено ИЛИ Соответствие.Получить("success") = Ложь Тогда
			// Еще раз загружаем IDКлюча 
			Если СертификатЭЦП <> Неопределено Тогда
				keyId = ПолучитьЗагрузитьIDКлюча(СертификатЭЦП, Истина);													
				Если keyId = Неопределено Тогда													
					Возврат Неопределено;
				КонецЕсли;
				
				Попытка
					ОтветВебСокетСервера = DidoxEImzoDLL.create_pkcs7(value, keyId);
				Исключение
					ОбщегоНазначенияКлиентСервер.СообщитьПользователю("Произошли ошибки при подписании файла!");
					Возврат Неопределено;
				КонецПопытки;
				
				Соответствие = ЭлектронноеВзаимодействиеССерверомDidox.ПрочитатьСтрокуJSON(ОтветВебСокетСервера, Истина);
				Если Соответствие.Получить("success") = Неопределено ИЛИ Соответствие.Получить("success") = Ложь Тогда
					ОбщегоНазначенияКлиентСервер.СообщитьПользователю("Введен неправильный пароль!");
					Возврат Неопределено;
				КонецЕсли;
			Иначе
				ОбщегоНазначенияКлиентСервер.СообщитьПользователю("Введен неправильный пароль!");
				Возврат Неопределено;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	Возврат Соответствие;
КонецФункции

Функция УстановитьШтампВремени(pkcs7_64, sn, signature_hex)
	
	Попытка
		
		// Обращаемся через наш прокси к серверу ГНК
		HTTPСоединение = ПолучитьHTTPСоединение("gw.goodsign.biz", , , 30, Истина);
		
		АдресРесурса = ПолучитьАдресРесурса("ШтампВремени", signature_hex);
		HTTPЗапрос = Новый HTTPЗапрос(АдресРесурса);
		HTTPЗапрос.Заголовки.Вставить("content-type", "application/x-www-form-urlencoded");
		
		ОтветСервера = HTTPСоединение.Получить(HTTPЗапрос);
		Timestamp = "";
		Если ОтветСервера.КодСостояния = 200 Тогда
			Соответствие = ПолучитьТиповоеСоответствие();
			Соответствие = ПрочитатьСтрокуJSON(ОтветСервера.ПолучитьТелоКакСтроку(), Истина);
			Если Соответствие.Получить("success") = Истина Тогда
				Timestamp = Соответствие.Получить("data");
			КонецЕсли;
		Иначе
			// Обращаемся напрямую к серверу ГНК
			HTTPСоединение = ПолучитьHTTPСоединение("www.fresh.venkon.uz", "didox", "prov1test", 30, Истина);
			АдресРесурса = ПолучитьАдресРесурса("ШтампВремени", signature_hex);
			HTTPЗапрос = Новый HTTPЗапрос(АдресРесурса);
			HTTPЗапрос.Заголовки.Вставить("content-type", "application/x-www-form-urlencoded");
			
			ОтветСервера = HTTPСоединение.Получить(HTTPЗапрос);
			Если ОтветСервера.КодСостояния = 200 Тогда
				Соответствие = ПолучитьТиповоеСоответствие();
				Соответствие = ПрочитатьСтрокуJSON(ОтветСервера.ПолучитьТелоКакСтроку(), Истина);
				Если Соответствие.Получить("success") = Истина Тогда
					Timestamp = Соответствие.Получить("data");
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		
		Если НЕ ПустаяСтрока(Timestamp) Тогда
			
			ПодписаннаяСтрокаСШтампомВремениСоответствие = DidoxEImzo_ПрикрепитьШтампВремениPKCS7(pkcs7_64, sn, Timestamp);
			Если ПодписаннаяСтрокаСШтампомВремениСоответствие <> Неопределено
				И ПодписаннаяСтрокаСШтампомВремениСоответствие.Получить("success") = Истина Тогда 
				pkcs7_64 = ПодписаннаяСтрокаСШтампомВремениСоответствие.Получить("pkcs7_64");
			КонецЕсли;
			
		КонецЕсли;
		
	Исключение
	КонецПопытки;
	
	Возврат pkcs7_64;
	
КонецФункции

// 1.1
Функция DidoxEImzo_ПодписатьPKCS7(value, keyId, СертификатЭЦП = Неопределено)
	
	Перем DidoxEImzoDLL;
	
	// Проверка просроченности ключа
	Если СертификатЭЦП <> Неопределено 
		И НЕ СертификатДействителен(СертификатЭЦП) Тогда
		ОбщегоНазначенияКлиентСервер.СообщитьПользователю("Выбранный сертификат недействителен!");
		Возврат Неопределено;
	КонецЕсли;
	
	Соответствие = ПолучитьТиповоеСоответствие();
	СтатусПодключения = DidoxEImzo_ПодключитьсяКСокетСерверу(DidoxEImzoDLL);
	
	Если СтатусПодключения = 0 Тогда
		ПодключитьФайлКомпонентыVenkonЭДО(СтатусПодключения, DidoxEImzoDLL);
	КонецЕсли;
	
	Если СтатусПодключения <> 2 Тогда
		Возврат Соответствие;
	КонецЕсли;
	
	Попытка
		ОтветВебСокетСервера = DidoxEImzoDLL.append_pkcs7_attached(value, keyId);
	Исключение
		ОбщегоНазначенияКлиентСервер.СообщитьПользователю("Произошли ошибки при подписании файла!");
		Возврат Неопределено;
	КонецПопытки;
	
	Если ОтветВебСокетСервера = Неопределено Тогда
		ОбщегоНазначенияКлиентСервер.СообщитьПользователю("Произошли ошибки при подписании файла!");
	Иначе
		Соответствие = ПрочитатьСтрокуJSON(ОтветВебСокетСервера, Истина);
		Если Соответствие.Получить("success") = Неопределено ИЛИ Соответствие.Получить("success") = Ложь Тогда
			// Еще раз загружаем IDКлюча 
			Если СертификатЭЦП <> Неопределено Тогда
				keyId = ПолучитьЗагрузитьIDКлюча(СертификатЭЦП, Истина);													
				Если keyId = Неопределено Тогда													
					Возврат Неопределено;
				КонецЕсли;
				
				Попытка
					ОтветВебСокетСервера = DidoxEImzoDLL.append_pkcs7_attached(value, keyId);
				Исключение
					ОбщегоНазначенияКлиентСервер.СообщитьПользователю("Произошли ошибки при подписании файла!");
					Возврат Неопределено;
				КонецПопытки;
				
				Соответствие = ПрочитатьСтрокуJSON(ОтветВебСокетСервера, Истина);
				Если Соответствие.Получить("success") = Неопределено ИЛИ Соответствие.Получить("success") = Ложь Тогда
					ОбщегоНазначенияКлиентСервер.СообщитьПользователю("Введен неправильный пароль!");
					Возврат Неопределено;
				КонецЕсли;
			Иначе
				ОбщегоНазначенияКлиентСервер.СообщитьПользователю("Введен неправильный пароль!");
				Возврат Неопределено;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	Возврат Соответствие;
КонецФункции

// 1.2
Функция DidoxEImzo_ПрикрепитьШтампВремениPKCS7(value, keyId, Timestamp, ВыводитьСообщения = Ложь)
	
	Перем DidoxEImzoDLL;
	Соответствие = ПолучитьТиповоеСоответствие();
	СтатусПодключения = DidoxEImzo_ПодключитьсяКСокетСерверу(DidoxEImzoDLL);
	
	Если СтатусПодключения = 0 Тогда
		ПодключитьФайлКомпонентыVenkonЭДО(СтатусПодключения, DidoxEImzoDLL);
	КонецЕсли;
	
	Если СтатусПодключения <> 2 Тогда
		Возврат Соответствие;
	КонецЕсли;
	
	Попытка
		ОтветВебСокетСервера = DidoxEImzoDLL.attach_timestamp_token_pkcs7(value, keyId, Timestamp);
	Исключение
		Если ВыводитьСообщения Тогда
			ОбщегоНазначенияКлиентСервер.СообщитьПользователю("Произошли ошибки при подписании файла!");
		КонецЕсли;
		Возврат Неопределено;
	КонецПопытки;
	
	Если ОтветВебСокетСервера = Неопределено Тогда
		Если ВыводитьСообщения Тогда
			ОбщегоНазначенияКлиентСервер.СообщитьПользователю("Произошли ошибки при подписании файла!");
		КонецЕсли;
	Иначе
		Соответствие = ПрочитатьСтрокуJSON(ОтветВебСокетСервера, Истина);
	КонецЕсли;
	Возврат Соответствие;
КонецФункции

//ФУНКЦИИ ДЛЯ РАБОТЫ С JSON

Функция ЗаписатьВСтрокуJSON(КонвертируемыеДанные) Экспорт
	
	ПараметрыЗаписиJSON = Новый ПараметрыЗаписиJSON(ПереносСтрокJSON.Нет, "", Истина, ЭкранированиеСимволовJSON.СимволыВнеASCII);
	
	ЗаписьJSON = Новый ЗаписьJSON;
	ЗаписьJSON.УстановитьСтроку(ПараметрыЗаписиJSON);
	
	ЗаписатьJSON(ЗаписьJSON, КонвертируемыеДанные);
	
	СтрокаJSON = ЗаписьJSON.Закрыть();
	
	Возврат СтрокаJSON;
	
КонецФункции 

Функция ПрочитатьСтрокуJSON(СтрокаJSON, ВСоответствие = Ложь, ИменаСвойствСоЗначениямиДата = Неопределено) Экспорт
	
	Если ИменаСвойствСоЗначениямиДата = Неопределено Тогда
		ИменаСвойствСоЗначениямиДата = "";
	КонецЕсли;
	
	ЧтениеJSON = Новый ЧтениеJSON;
	ЧтениеJSON.УстановитьСтроку(СтрокаJSON);
	
	Возврат ПрочитатьJSON(ЧтениеJSON, ВСоответствие, ИменаСвойствСоЗначениямиДата, ФорматДатыJSON.ISO);
	
КонецФункции

//ФУНКЦИИ ДЛЯ РАБОТЫ С HTTP-ЗАПРСАМИ

Функция ПолучитьHTTPСоединение(URL, Пользователь, Пароль, Таймаут, ЗащищенноеСоединение = Истина)
	
	Если ЗащищенноеСоединение Тогда
		HTTPСоединение = Новый HTTPСоединение(URL, , Пользователь, Пароль, , Таймаут, Новый ЗащищенноеСоединениеOpenSSL);
	Иначе
		HTTPСоединение = Новый HTTPСоединение(URL, , Пользователь, Пароль, , Таймаут);
	КонецЕсли;
	
	Возврат HTTPСоединение;
	
КонецФункции

Функция ПолучитьАдресРесурса(Ресурс, Параметр1 = Неопределено) 
	
	АдресРесурса = "";
	
	Если ВРег(Ресурс) = "ШТАМПВРЕМЕНИ" Тогда
		
		АдресРесурса = "provider/api/ru/utils/timestamp?signatureHex=" + Параметр1;
		
	КонецЕсли;
	
	Возврат АдресРесурса;
	
КонецФункции

Функция ПроверитьРегистрациюКомпонентыЭО() Экспорт
	
	Возврат DidoxEImzo_ПодключитьсяКСокетСерверу();
	
КонецФункции

// Подписывает файл или строку и ответ возвращает внутри файла
Функция ПодписатьФайл(ИмяФайла = Неопределено, 
					СтрокаКПодписи = Неопределено, 
					keyId, 
					СертификатЭЦП, 
					serialNumber = Неопределено, 
					ЭтоПодтверждение = Ложь,
					УстановитьШтампВремени = Ложь) Экспорт
	
	Если ИмяФайла <> Неопределено Тогда
		ФайлРезультатКода = Неопределено;	
		
		// Считываем из файла
		темп = новый ТекстовыйДокумент;
		темп.Прочитать(ИмяФайла, КодировкаТекста.UTF8);
		value = темп.ПолучитьТекст();
		
		УдалитьФайлы(ИмяФайла);
	ИначеЕсли  СтрокаКПодписи <> Неопределено Тогда
		value = СтрокаКПодписи;
	Иначе
		Возврат ФайлРезультатКода;
	КонецЕсли;
	
	Если Не ЭтоПодтверждение Тогда
		ПодписаннаяСтрокаСоответствие = DidoxEImzo_Подписать(value, keyId, СертификатЭЦП);
	Иначе
		ПодписаннаяСтрокаСоответствие = DidoxEImzo_ПодписатьPKCS7(value, keyId, СертификатЭЦП);
	КонецЕсли;
	 
	Если  ПодписаннаяСтрокаСоответствие = Неопределено ИЛИ НЕ ПодписаннаяСтрокаСоответствие.Получить("success") Тогда
		Возврат ФайлРезультатКода;
	КонецЕсли;
	
	pkcs7_64 = ПодписаннаяСтрокаСоответствие.Получить("pkcs7_64");
	serialNumber = ПодписаннаяСтрокаСоответствие.Получить("signer_serial_number");
	signature_hex = ПодписаннаяСтрокаСоответствие.Получить("signature_hex");
	
	// Устанавливаем штамп времени
	Если УстановитьШтампВремени Тогда
		
		pkcs7_64 = УстановитьШтампВремени(pkcs7_64, serialNumber, signature_hex);
		
	КонецЕсли;
	
	// Записываем в файл
	ФайлРезультатКода = ПолучитьИмяВременногоФайла();
	Текст = Новый ТекстовыйДокумент;
	Текст.УстановитьТекст(pkcs7_64);
	Текст.Записать(ФайлРезультатКода, КодировкаТекста.ANSI);
	
	Возврат ФайлРезультатКода;
	
КонецФункции

Функция СертификатДействителен(СертификатЭЦП)
	
	Если СертификатЭЦП <> Неопределено Тогда
		Если СертификатЭЦП.ДатаОкончания >= ТекущаяДата() Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции

Функция DidoxEImzo_ПолучитьХэшСтроки(value) Экспорт
	
	Перем DidoxEImzoDLL;
	Соответствие = Новый Соответствие;
	
	СтатусПодключения = DidoxEImzo_ПодключитьсяКСокетСерверу(DidoxEImzoDLL);
	
	Если СтатусПодключения = 0 Тогда
		ПодключитьФайлКомпонентыVenkonЭДО(СтатусПодключения, DidoxEImzoDLL);
	КонецЕсли;
	
	Если СтатусПодключения <> 2 Тогда
		Возврат Соответствие;
	КонецЕсли;
	
	ОтветВебСокетСервера = "";
	Попытка
		ОтветВебСокетСервера = DidoxEImzoDLL.get_digest_hex(value);
	Исключение
	КонецПопытки;
	Если ОтветВебСокетСервера = Неопределено Тогда
		ОбщегоНазначенияКлиентСервер.СообщитьПользователю("Ошибка при подключении к компоненте ЭО! Возможно компонента не была зарегистрирована в системе.");
	Иначе
		Соответствие = ПрочитатьСтрокуJSON(ОтветВебСокетСервера, Истина);
	КонецЕсли;
	
	Возврат Соответствие;
	
КонецФункции
