// Этот модуль предназачен для реализации алгоритмов работы форм и 
// содержит процедуры и функции работы с формами и элементами форм,
// а также подготовки данных для представления информации в формах.
// Временно присутствует секция поддержки формирования печатных форм.

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ, ИСПОЛЬЗУЕМЫЕ ДЛЯ ВЫЗОВА ИЗ ИНТЕРФЕЙСОВ

//Процедура открывает список выбора внешних обработок
Процедура ОткрытьСписокВнешнихОбработок() Экспорт
	ВидПеречисления = Перечисления.ВидыДополнительныхВнешнихОбработок.Обработка;
	Форма = Справочники.ВнешниеОбработки.ПолучитьФорму("ФормаСписка",,ВидПеречисления);
	Форма.СправочникСписок.Отбор.ВидОбработки.Установить(ВидПеречисления);
	Форма.ЭлементыФормы.СправочникСписок.НастройкаОтбора.ВидОбработки.Доступность = Ложь;
	Форма.Открыть();
КонецПроцедуры // () 

//Процедура открывает список выбора внешних печатных форм
Процедура ОткрытьСписокВнешнихПечатныхФорм() Экспорт
	ВидПеречисления = Перечисления.ВидыДополнительныхВнешнихОбработок.ПечатнаяФорма;
	Форма = Справочники.ВнешниеОбработки.ПолучитьФорму("ФормаСписка",,ВидПеречисления);
	Форма.СправочникСписок.Отбор.ВидОбработки.Установить(ВидПеречисления);
	Форма.ЭлементыФормы.СправочникСписок.НастройкаОтбора.ВидОбработки.Доступность = Ложь;
	Форма.Открыть();
КонецПроцедуры // () 

//Процедура открывает список выбора внешних обработок заполнения табличных частей
Процедура ОткрытьСписокВнешнихОбработокЗаполненияТабличныхЧастей() Экспорт
	ВидПеречисления = Перечисления.ВидыДополнительныхВнешнихОбработок.ЗаполнениеТабличныхЧастей;
	Форма = Справочники.ВнешниеОбработки.ПолучитьФорму("ФормаСписка",,ВидПеречисления);
	Форма.СправочникСписок.Отбор.ВидОбработки.Установить(ВидПеречисления);
	Форма.ЭлементыФормы.СправочникСписок.НастройкаОтбора.ВидОбработки.Доступность = Ложь;
	Форма.Открыть();
КонецПроцедуры // () 

// Процедура вызывается из интерфейсов и служит для открытия формы 
// набора записей регистра сведений ДатаПроведенияПоРазделамУчета
//
// Параметры:
//  нет
//
Процедура ОткрытьФормуНастройкиПроведенияПоРазделамУчета() Экспорт
	
	РегистрыСведений.ДатаПроведенияПоРазделамУчета.ПолучитьФорму("ФормаНабораЗаписей").Открыть();
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ОБЕСПЕЧЕНИЯ ВВОДА ПО СТРОКЕ В ПОЛЕ ВВОДА

// Функция формирует список выбора значений, для события ОкончаниеВводаТекста.
//
// Параметры
//  РезультатЗапроса - РезультатЗапроса при вводе по строке
//  Текст - Строка, текст ввода по строке
//  ТипСправочника - Тип, тип справочника автоподбора текста
//
// Возвращаемое значение:
//   Список значений
//
Функция СформироватьСписокВыбораЗначенийТайпинга(РезультатЗапроса, Знач Текст, ТипСправочника)

	ПустаяСсылка = Новый(ТипСправочника);
	КоллекцияЗначенийПоискаПоПодстроке = ПустаяСсылка.Метаданные().ВводПоСтроке;
	
	СписокВозврата = Новый СписокЗначений;
	
	Текст = ВРег(Текст);
	ДлинаТекста = СтрДлина(Текст);
	
	ТаблицаЗапроса = РезультатЗапроса.Выгрузить();
	
	ЕстьНаименование = (ТаблицаЗапроса.Колонки.Найти("Наименование") <> Неопределено);
	ЕстьКод          = (ТаблицаЗапроса.Колонки.Найти("Код") <> Неопределено);
	
	Для каждого СтрокаТаблицы Из ТаблицаЗапроса Цикл
	
		Если ЕстьНаименование И КоллекцияЗначенийПоискаПоПодстроке.Найти("Наименование") <> Неопределено И ВРег(Лев(СтрокаТаблицы.Наименование, ДлинаТекста)) = Текст Тогда
			СписокВозврата.Добавить(СтрокаТаблицы.Ссылка, (СтрокаТаблицы.Наименование + ?(ЕстьКод, (" (" + Строка(СтрокаТаблицы.Код) + ")"), "")));
			Продолжить;
		КонецЕсли;
		
		Если ЕстьКод И КоллекцияЗначенийПоискаПоПодстроке.Найти("Код") <> Неопределено И ВРег(Лев(СтрокаТаблицы.Код, ДлинаТекста)) = Текст Тогда
			Если ЕстьНаименование Тогда
				СписокВозврата.Добавить(СтрокаТаблицы.Ссылка, (СтрокаТаблицы.Наименование + " (" + Строка(СтрокаТаблицы.Код) + ")"));
			Иначе
				СписокВозврата.Добавить(СтрокаТаблицы.Ссылка, Строка(СтрокаТаблицы.Код));
			КонецЕсли; 
			Продолжить;
		КонецЕсли;
		
		Для каждого Колонка Из ТаблицаЗапроса.Колонки Цикл
		
			Если Колонка.Имя = "Наименование" ИЛИ Колонка.Имя = "Код" ИЛИ Колонка.Имя = "Ссылка" Тогда
				Продолжить;
			КонецЕсли; 
		
			Если ВРег(Лев(СтрокаТаблицы[Колонка.Имя], ДлинаТекста)) = Текст Тогда
				СписокВозврата.Добавить(СтрокаТаблицы.Ссылка, (СтрокаТаблицы[Колонка.Имя] + ?(ЕстьНаименование, (" (" + Строка(СтрокаТаблицы.Наименование) + ")"), "")));
			КонецЕсли
			
		КонецЦикла; 
	
	КонецЦикла; 

	Возврат СписокВозврата;
	
КонецФункции

// Процедура обслуживает событие ОбновлениеОтображения в форме, где расположен ЭУ ввода по строке.
//
// Параметры
//  ЭтаФорма - Форма записи регистра сведений КонтактнаяИнформация
//  Элемент - элемент управления в котором происводится ввод по строке
//
Процедура ОбновлениеОтображенияВФормеПриТайпинге(ЭтаФорма, Элемент, ОбработкаТайпинга, ТекстТайпинга) Экспорт

	Если ОбработкаТайпинга Тогда
		ЭтаФорма.ТекущийЭлемент = Элемент;
		Элемент.ВыделенныйТекст = ТекстТайпинга;
		ОбработкаТайпинга = Ложь;
		ТекстТайпинга = "";
	КонецЕсли; 
	
	Если ТипЗнч(Элемент.Значение) = Тип("Строка") Тогда
		Элемент.ЦветТекстаПоля = ЦветаСтиля.ТекстИнформационнойНадписи;
	Иначе
		Элемент.ЦветТекстаПоля = Новый Цвет;
	КонецЕсли;

КонецПроцедуры

// Процедура обслуживает событие ОкончаниеВводаТекста элемента управления Вид в форме записи регистра
// сведений Контактная информация.
//
// Параметры
//  Элемент - поле ввода
//  Текст - текст введенный в поле ввода Вид
//  Значение - данные элемента управления поле ввода
//  СтандартнаяОбработка - булево, флаг стандартной обработки события автоподбора
//  СтруктураПараметров - Структура параметров запроса, ключ - имя параметра, значение - значение параметра.
//  ЭтаФорма - форма записи регистра сведений контактная информация
//  ТипСправочника - Тип, тип справочника автоподбора текста
//
Процедура ОкончаниеВводаТекстаВЭлементеУправления(Элемент, Текст, Значение, СтандартнаяОбработка, СтруктураПараметров, ЭтаФорма, ТипСправочника, ОбработкаТайпинга = Неопределено, ТекстТайпинга = Неопределено, ПоследнееЗначениеЭлементаТайпинга = Неопределено, ПриОтсутствииЗначенияОставлятьТекст = Истина) Экспорт

	Если ПустаяСтрока(Текст) Тогда
		Значение = Новый(ТипСправочника);
		СтандартнаяОбработка = Ложь;
		Возврат;
	КонецЕсли; 

	РезультатЗапроса = ПолучитьРезультатЗапросаАвтоподбора(Текст, СтруктураПараметров, ТипСправочника, 51);
	
	Если РезультатЗапроса = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	
	СтандартнаяОбработка = Ложь;
	
	Если РезультатЗапроса.Пустой() И ПриОтсутствииЗначенияОставлятьТекст Тогда
		Значение = Текст;
	Иначе
		Выборка = РезультатЗапроса.Выбрать();
		Если Выборка.Количество() = 1 Тогда
			Выборка.Следующий();
			Значение = Выборка.Ссылка;
		ИначеЕсли Выборка.Количество() > 50 Тогда
			Предупреждение("Найдено более 50-ти значений, удовлетворяющих условиям выбора.
						   |Задайте более длинную строку или воспользуйтесь командой выбора (F4).");
			Если ПоследнееЗначениеЭлементаТайпинга = Неопределено Тогда
				Значение = Текст;
			Иначе
				Значение = ПоследнееЗначениеЭлементаТайпинга;
			КонецЕсли; 
		Иначе
			Если Выборка.Количество() = 0 Тогда
				ВыбранныйЭлемент = Неопределено;
			Иначе
				СписокВыбора = СформироватьСписокВыбораЗначенийТайпинга(РезультатЗапроса, Текст, ТипСправочника);
				ВыбранныйЭлемент = ЭтаФорма.ВыбратьИзСписка(СписокВыбора, Элемент);
			КонецЕсли; 
			Если ВыбранныйЭлемент = Неопределено Тогда
				ОтветНаВопрос = Вопрос(("В элемент управления введены некорректные данные." + Символы.ПС + "Продолжить?"), РежимДиалогаВопрос.ДаНет, , КодВозвратаДиалога.Нет);
				Если ПоследнееЗначениеЭлементаТайпинга = Неопределено Тогда
					Значение = Текст;
				Иначе
					Значение = ПоследнееЗначениеЭлементаТайпинга;
				КонецЕсли; 
				Если ОтветНаВопрос <> КодВозвратаДиалога.Да Тогда
					ОбработкаТайпинга = Истина;
					ТекстТайпинга = Текст;
				КонецЕсли;
			Иначе
				Значение = ВыбранныйЭлемент.Значение;
			КонецЕсли; 
		КонецЕсли; 
	КонецЕсли;

КонецПроцедуры

// Процедура обслуживает событие АвтоПодборТекста элемента управления ПолеВвода для подмены автопоиска по тексту.
//
// Параметры
//  Элемент - поле ввода
//  Текст - текст введенный в поле ввода Вид
//  ТекстАвтоПодбора - текст автоподбора в поле Вид
//  СтандартнаяОбработка - булево, флаг стандартной обработки события автоподбора
//  СтруктураПараметров - Структура параметров запроса, ключ - имя параметра, значение - значение параметра.
//  ТипСправочника - Тип, тип справочника автоподбора текста
//
Процедура АвтоПодборТекстаВЭлементеУправления(Элемент, Текст, ТекстАвтоПодбора, СтандартнаяОбработка, СтруктураПараметров, ТипСправочника) Экспорт

	РезультатЗапроса = ПолучитьРезультатЗапросаАвтоподбора(Текст, СтруктураПараметров, ТипСправочника, 2);
	
	Если РезультатЗапроса = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	
	СтандартнаяОбработка = Ложь;
	
	Если НЕ РезультатЗапроса.Пустой() Тогда
		Выборка = РезультатЗапроса.Выбрать();
		Если Выборка.Количество() = 1 Тогда
			Выборка.Следующий();
			ПустаяСсылка = Новый(ТипСправочника);
			КоллекцияЭлементовПоиска = ПустаяСсылка.Метаданные().ВводПоСтроке;
			Для каждого ЭлементКоллекции Из КоллекцияЭлементовПоиска Цикл
				Если Лев(Врег(Выборка[ЭлементКоллекции.Имя]), СтрДлина(Текст)) = ВРег(Текст) Тогда
					Если Врег(Текст) <> Врег(Выборка[ЭлементКоллекции.Имя]) Тогда
						ТекстАвтоподбора = Выборка[ЭлементКоллекции.Имя];
					КонецЕсли;
					Прервать;
				КонецЕсли; 
			КонецЦикла; 
		КонецЕсли; 
	КонецЕсли;

КонецПроцедуры

// Функция выполняет запрос при автоподборе текста  и при окончании ввода текста в поле ввода.
//
// Параметры
//  Текст - Строка, текст введенный в поле ввода видв контактной информации, по которому необходимо строить поиск
//  СтруктураПараметров - Структура параметров запроса, ключ - имя параметра, значение - значение параметра.
//  ТипСправочника - Тип, тип справочника автоподбора текста
//  КоличествоЭлементов - Число, количество элементов в результирующей таблице запроса
//
// Возвращаемое значение
//  РезультатЗапроса
//
Функция ПолучитьРезультатЗапросаАвтоподбора(Знач Текст, СтруктураПараметров, ТипСправочника, КоличествоЭлементов) Экспорт

	ПустаяСсылкаТипа = Новый(ТипСправочника);
	
	КоллекцияПоискаПоПодстроке = ПустаяСсылкаТипа.Метаданные().ВводПоСтроке;
	Если КоллекцияПоискаПоПодстроке.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли; 
	
	ИмяТаблицыСправочника = ПустаяСсылкаТипа.Метаданные().Имя;
	
	Запрос = Новый Запрос;
	
	Текст = СтрЗаменить(Текст, "~", "~~");
	Текст = СтрЗаменить(Текст, "%", "~%");
	Текст = СтрЗаменить(Текст, "_", "~_");
	Текст = СтрЗаменить(Текст, "[", "~[");
	Текст = СтрЗаменить(Текст, "-", "~-");
	Запрос.УстановитьПараметр("ТекстАвтоПодбора", (Текст + "%"));
	
	СтрокаОтборовПоСтруктуре = "";
	Для каждого ЭлементСтруктуры Из СтруктураПараметров Цикл
		Запрос.УстановитьПараметр(ЭлементСтруктуры.Ключ, ЭлементСтруктуры.Значение);
		СтрокаОтборовПоСтруктуре = СтрокаОтборовПоСтруктуре + "
		|		И
		|		" + ?(КоллекцияПоискаПоПодстроке.Количество() = 1, "ТаблицаВложенногоЗапроса.", "ТаблицаСправочника.") + ЭлементСтруктуры.Ключ + " = &"+ ЭлементСтруктуры.Ключ;
	КонецЦикла; 
	
	СтрокаПолей = "
	|ВЫБРАТЬ РАЗРЕШЕННЫЕ РАЗЛИЧНЫЕ ПЕРВЫЕ " + Строка(КоличествоЭлементов) + "
	|	ТаблицаВложенногоЗапроса.Ссылка КАК Ссылка,
	|";
	
	Если ПустаяСсылкаТипа.Метаданные().ДлинаНаименования > 0 Тогда
		СтрокаПолей = СтрокаПолей + "
		|	ТаблицаВложенногоЗапроса.Ссылка.Наименование КАК Наименование,";
	КонецЕсли;
	
	Если ПустаяСсылкаТипа.Метаданные().ДлинаКода > 0 Тогда
		СтрокаПолей = СтрокаПолей + "
		|	ТаблицаВложенногоЗапроса.Ссылка.Код КАК Код,";
	КонецЕсли; 
	
	Если КоллекцияПоискаПоПодстроке.Количество() = 1 Тогда
		
		ЭлементКоллекции = КоллекцияПоискаПоПодстроке[0];
		
		Если ЭлементКоллекции.Имя <> "Наименование" И ЭлементКоллекции.Имя <> "Код" Тогда
			СтрокаПолей = СтрокаПолей + "
			|	ТаблицаВложенногоЗапроса.Ссылка." + ЭлементКоллекции.Имя + " КАК " + ЭлементКоллекции.Имя;
		КонецЕсли;
		
		Запрос.Текст = Лев(СтрокаПолей, (СтрДлина(СтрокаПолей) - 1)) + "
		|ИЗ
		|	Справочник." + ИмяТаблицыСправочника + " КАК ТаблицаВложенногоЗапроса
		|ГДЕ
		|	ТаблицаВложенногоЗапроса." + ЭлементКоллекции.Имя + " ПОДОБНО &ТекстАвтоПодбора СПЕЦСИМВОЛ ""~""" + СтрокаОтборовПоСтруктуре;
	
	Иначе
		
		ПервыйЭлемент = Истина;
		СтрокаТаблиц = "";
		Для каждого ЭлементКоллекции Из КоллекцияПоискаПоПодстроке Цикл
			
			Если ЭлементКоллекции.Имя <> "Наименование" И ЭлементКоллекции.Имя <> "Код" Тогда
				СтрокаПолей = СтрокаПолей + "
				|	ТаблицаВложенногоЗапроса.Ссылка." + ЭлементКоллекции.Имя + " КАК " + ЭлементКоллекции.Имя + ",";
			КонецЕсли;
			
			Если НЕ ПервыйЭлемент Тогда
				СтрокаТаблиц = СтрокаТаблиц + "
				|	ОБЪЕДИНИТЬ ВСЕ
				|";
			КонецЕсли; 
			ПервыйЭлемент = Ложь;
			
			СтрокаТаблиц = СтрокаТаблиц + "
			|	ВЫБРАТЬ
			|		ТаблицаСправочника.Ссылка КАК Ссылка
			|	ИЗ
			|		Справочник." + ИмяТаблицыСправочника + " КАК ТаблицаСправочника
			|	ГДЕ
			|		ТаблицаСправочника." + ЭлементКоллекции.Имя + " ПОДОБНО &ТекстАвтоПодбора СПЕЦСИМВОЛ ""~""" + СтрокаОтборовПоСтруктуре;
		
		КонецЦикла; 
		
		Запрос.Текст = Лев(СтрокаПолей, (СтрДлина(СтрокаПолей) - 1)) + "
		|ИЗ
		|
		|	(
		|" + СтрокаТаблиц + "
		|	) КАК ТаблицаВложенногоЗапроса";
	
	КонецЕсли; 
	
	Возврат Запрос.Выполнить();

КонецФункции

// Процедура вызывается из форм платежных документов при смене кассы или 
// банковского счета. Меняет валюту, курс документа и предлагает пересчитать сумму.
//
// Параметры:
//  ВалютаДокумента  - ссылка на справочник, валюта документа до изменения;
//  КурсДокумента    - число, курс документа до изменения; 
//  ДатаДокумента    - дата, дата на которую будем получать новый курс; 
//  СуммаДокумента   - число, сумма документа; 
//  ВалютаДенежныхСредств - ссылка на справочник, валюта выбранного счета или кассы 
//                     (новая валюта документа);
//
Процедура ПриИзмененииЗначенияКассыБанковскогоСчета(ВалютаДокумента, КурсДокумента, КратностьДокумента, ДатаДокумента, 
	                                        СуммаДокумента, ВалютаДенежныхСредств) Экспорт

	// Поменяем валюту до вопроса о пересчете, чтобы было видно, что она действительно поменялась.
	СтараяВалюта    = ВалютаДокумента; 
	СатрыйКурс      = КурсДокумента;
	СтараяКратность = КратностьДокумента;
	ВалютаДокумента = ВалютаДенежныхСредств; // должны строго совпадать

	СтруктураКурсаВалютаДокумента = ПолучитьКурсВалюты(ВалютаДокумента, ДатаДокумента);
	КурсДокумента        = СтруктураКурсаВалютаДокумента.Курс;
	КратностьДокумента   = СтруктураКурсаВалютаДокумента.Кратность;

	Если ВалютаДокумента <>  СтараяВалюта
	   И СуммаДокумента > 0 Тогда

		// Надо предложить пересчитать сумму.
		Ответ = Вопрос("Изменилась валюта документа. Пересчитать сумму документа?", 
		               РежимДиалогаВопрос.ДаНет, , КодВозвратаДиалога.Да);
		Если Ответ = КодВозвратаДиалога.Да Тогда
			СуммаДокумента = ПересчитатьИзВалютыВВалюту(СуммаДокумента, СтараяВалюта, ВалютаДокумента, СатрыйКурс,
									    КурсДокумента,СтараяКратность,КратностьДокумента);
		КонецЕсли; 

	КонецЕсли;

КонецПроцедуры // ПриИзмененииЗначенияКассыБанковскогоСчета()

//////////////////////////////////////////
// ПРОЦЕДУРЫ ОБРАБОТКИ ВЫБОРА

// Вызывается в обработчике события "Начало выбора" при выборе счета.
// используется для получения списка только балансовых или только
// забаланс
//
Процедура ВыборСчета(Элемент, СтандартнаяОбработка, Флаг) Экспорт

	СтандартнаяОбработка = Ложь;

	Запрос = Новый Запрос();
	Запрос.УстановитьПараметр("Флаг", Флаг);
	Запрос.Текст = "ВЫБРАТЬ
	|	Хозрасчетный.Ссылка КАК Счет
	|ИЗ
	|	ПланСчетов.Хозрасчетный КАК Хозрасчетный
	|
	|ГДЕ
	|	Хозрасчетный.Забалансовый = &Флаг";
	ВыборкаСчетов = Запрос.Выполнить().Выбрать();
	СписокСчетов  = Новый СписокЗначений;
	Пока ВыборкаСчетов.Следующий() Цикл
		СписокСчетов.Добавить(ВыборкаСчетов.Счет);
	КонецЦикла;

	ФормаВыбора = ПланыСчетов.Хозрасчетный.ПолучитьФормуВыбора("ФормаВыбора", Элемент, );

	ФормаВыбора.ПланСчетовСписок.Отбор.Ссылка.ВидСравнения  = ВидСравнения.ВСписке;
	ФормаВыбора.ПланСчетовСписок.Отбор.Ссылка.Использование = Истина;
	ФормаВыбора.ПланСчетовСписок.Отбор.Ссылка.Значение      = СписокСчетов;

	ФормаВыбора.ЭлементыФормы.Список.НастройкаОтбора.Ссылка.Доступность = Ложь;

	ФормаВыбора.ПараметрТекущаяСтрока = Элемент.Значение;

	ФормаВыбора.Открыть();

Конецпроцедуры // ВыборСчета

// Процедура выполняет стандартные действия при начале выбора договора контрагента в формах документов.
//
// Параметры:
//  ДокументОбъект                   - объект редактируемого документа;
//  ФормаДокумента                    - форма редактируемого документа;
//  ЭлементФормы                      - элемент формы документа, который надо заполнить; 
//  Контрагент                        - ссылка на справочник, определяет контрагента по договору;
//  ДоговорКонтрагента                - ссылка на справочник, определяет договор контрагента;
//  ВидДоговораВзаиморасчетов         - вид договора взаиморасчетов для отбора, значение перечисления ВидыДоговоровКонтрагентов;
//  СтандартнаяОбработка              - булево, признак выполнения стандартной (системной) обработки события,
//  СтруктураДополнительныхПараметров - структура, содержит дополнительные значения отбора, необязаетльный,
//                                      ключ - имя отбора, значение - структура, определяющая отбор с ключами:
//                                      ЗначениеОтбора (если не задан, то отбор не устанавливается), 
//                                      ВидСравненияОтбора (если не задан, то ВидСравнения.Равно), 
//                                      ДоступностьОтбора (если не задан, то Ложь).
//
Процедура НачалоВыбораЗначенияДоговораКонтрагента(ДокументОбъект, ФормаДокумента, ЭлементФормы, Контрагент, ДоговорКонтрагента,
                                                  ВидыДоговораВзаиморасчетов, СтандартнаяОбработка,
                                                  СтруктураДополнительныхПараметров = Неопределено) Экспорт

	СтандартнаяОбработка = Ложь;

	МетаданныеДокумента = ДокументОбъект.Метаданные();

	//// Тип выбираемого значения зависит от договора.
	//Если ЗначениеНеЗаполнено(Контрагент) Тогда
	//	Предупреждение("Не выбран контрагент!");
	//	ФормаДокумента.ТекущийЭлемент = ФормаДокумента.ЭлементыФормы.Контрагент;
	//	Возврат;
	//КонецЕсли;

	// В качестве владельца формы выбора устанавливаем данный элемент формы, чтобы выбранное
	// значение было присвоено стандартно.
	ФормаВыбора = Справочники.ДоговорыКонтрагентов.ПолучитьФормуВыбора(,ЭлементФормы,);

	// Владельца менять по умолчанию не даем.
	ФормаВыбора.ПараметрОтборПоВладельцу = Контрагент;
	ФормаВыбора.ЭлементыФормы.СправочникСписок.НастройкаОтбора.Владелец.Доступность = Ложь;

	Если ВидыДоговораВзаиморасчетов<>Неопределено Тогда

		// Оставим в выборе только "правильные" договоры
		Если ТипЗнч(ВидыДоговораВзаиморасчетов) = Тип("СписокЗначений") Тогда
			ФормаВыбора.СправочникСписок.Отбор.ВидДоговора.ВидСравнения                    = ВидСравнения.ВСписке;
		Иначе
			ФормаВыбора.СправочникСписок.Отбор.ВидДоговора.ВидСравнения                    = ВидСравнения.Равно;
		КонецЕсли;
		ФормаВыбора.СправочникСписок.Отбор.ВидДоговора.Значение                            = ВидыДоговораВзаиморасчетов;
		ФормаВыбора.СправочникСписок.Отбор.ВидДоговора.Использование                       = Истина;
		ФормаВыбора.ЭлементыФормы.СправочникСписок.НастройкаОтбора.ВидДоговора.Доступность = Ложь;
	КонецЕсли;

	// Еще надо фильтровать по организации, если она заполнена
	Если ЕстьРеквизитДокумента("Организация",МетаданныеДокумента)
	   И Не ЗначениеНеЗаполнено(ДокументОбъект.Организация) Тогда
		ФормаВыбора.СправочникСписок.Отбор.Организация.Значение                            = ДокументОбъект.Организация;
		ФормаВыбора.СправочникСписок.Отбор.Организация.Использование                       = Истина;
		ФормаВыбора.СправочникСписок.Отбор.Организация.ВидСравнения                        = ВидСравнения.Равно;
		ФормаВыбора.ЭлементыФормы.СправочникСписок.НастройкаОтбора.Организация.Доступность = Ложь;
	КонецЕсли;

	// Добавим фильтры по дополнительным параметрам отбора
	Если ТипЗнч(СтруктураДополнительныхПараметров) = Тип("Структура") Тогда
		Для каждого ЭлементСтруктуры Из СтруктураДополнительныхПараметров Цикл

			СтруктураОтбора = ЭлементСтруктуры.Значение;
			
			ЗначениеОтбора     = Неопределено;
			ВидСравненияОтбора = Неопределено;
			ДоступностьОтбора  = Неопределено;

			Если СтруктураОтбора.Свойство("ЗначениеОтбора", ЗначениеОтбора) Тогда

				Если СтруктураОтбора.Свойство("ВидСравненияОтбора", ВидСравненияОтбора) Тогда
					ФормаВыбора.СправочникСписок.Отбор[ЭлементСтруктуры.Ключ].ВидСравнения = ВидСравненияОтбора;
				Иначе
					ФормаВыбора.СправочникСписок.Отбор[ЭлементСтруктуры.Ключ].ВидСравнения = ВидСравнения.Равно;
				КонецЕсли;

				ФормаВыбора.СправочникСписок.Отбор[ЭлементСтруктуры.Ключ].Значение      = ЗначениеОтбора;
				ФормаВыбора.СправочникСписок.Отбор[ЭлементСтруктуры.Ключ].Использование = Истина;

				Если СтруктураОтбора.Свойство("ДоступностьОтбора", ДоступностьОтбора) Тогда
					ФормаВыбора.ЭлементыФормы.СправочникСписок.НастройкаОтбора[ЭлементСтруктуры.Ключ].Доступность = ДоступностьОтбора;
				Иначе
					ФормаВыбора.ЭлементыФормы.СправочникСписок.НастройкаОтбора[ЭлементСтруктуры.Ключ].Доступность = Ложь;
				КонецЕсли;

			КонецЕсли;

		КонецЦикла;

	КонецЕсли;

	ФормаВыбора.ЭлементыФормы.СправочникСписок.ТекущаяСтрока = ДоговорКонтрагента;

	ФормаВыбора.Открыть();

КонецПроцедуры // НачалоВыбораЗначенияДоговораКонтрагента()

// Процедура выполняет стандартные действия при начале выбора договора контрагента в формах документов.
//
// Параметры:
//  ДокументОбъект                   - объект редактируемого документа;
//  ФормаДокумента                    - форма редактируемого документа;
//  ЭлементФормы                      - элемент формы документа, который надо заполнить; 
//  Контрагент                        - ссылка на справочник, определяет контрагента по договору;
//  ДоговорКонтрагента                - ссылка на справочник, определяет договор контрагента;
//  ВидДоговораВзаиморасчетов         - вид договора взаиморасчетов для отбора, значение перечисления ВидыДоговоровКонтрагентов;
//  СтандартнаяОбработка              - булево, признак выполнения стандартной (системной) обработки события,
//  СтруктураДополнительныхПараметров - структура, содержит дополнительные значения отбора, необязаетльный,
//                                      ключ - имя отбора, значение - структура, определяющая отбор с ключами:
//                                      ЗначениеОтбора (если не задан, то отбор не устанавливается), 
//                                      ВидСравненияОтбора (если не задан, то ВидСравнения.Равно), 
//                                      ДоступностьОтбора (если не задан, то Ложь).
//
Процедура НачалоВыбораДоверенности(ДокументОбъект, ФормаДокумента, ЭлементФормы, Контрагент, ДоговорКонтрагента,СтандартнаяОбработка) Экспорт

	СтандартнаяОбработка = Ложь;

	МетаданныеДокумента = ДокументОбъект.Метаданные();

	ФормаВыбора = Документы.Доверенность.ПолучитьФормуВыбора(,ЭлементФормы,);

	ФормаВыбора.ДокументСписок.Отбор.Контрагент.Использование = Истина;
	ФормаВыбора.ДокументСписок.Отбор.ДоговорКонтрагента.Использование = Истина;
	
	ФормаВыбора.ДокументСписок.Отбор.Контрагент.Значение = Контрагент;
	ФормаВыбора.ДокументСписок.Отбор.ДоговорКонтрагента.Значение = ДоговорКонтрагента;
	
	ФормаВыбора.ЭлементыФормы.ДокументСписок.НастройкаОтбора.Контрагент.Доступность = Ложь;
	ФормаВыбора.ЭлементыФормы.ДокументСписок.НастройкаОтбора.ДоговорКонтрагента.Доступность = Ложь;
	
	ФормаВыбора.Открыть();

КонецПроцедуры // НачалоВыбораЗначенияДоговораКонтрагента()

Процедура НачалоВыбораСпецификации(ДокументОбъект, ФормаДокумента, ЭлементФормы, ГотоваяПродукция, СтандартнаяОбработка) Экспорт

	СтандартнаяОбработка = Ложь;

	МетаданныеДокумента = ДокументОбъект.Метаданные();

	ФормаВыбора = Документы.СпецификацииНоменклатурыПродаж.ПолучитьФормуВыбора(,ЭлементФормы,);

	ФормаВыбора.ДокументСписок.Отбор.ГотоваяПродукция.Использование = Истина;
	ФормаВыбора.ДокументСписок.Отбор.ГотоваяПродукция.Использование = Истина;
	
	ФормаВыбора.ДокументСписок.Отбор.ГотоваяПродукция.Значение = ГотоваяПродукция;
	
	ФормаВыбора.ЭлементыФормы.ДокументСписок.НастройкаОтбора.ГотоваяПродукция.Доступность = Ложь;
	
	ФормаВыбора.Открыть();

КонецПроцедуры // НачалоВыбораЗначенияДоговораКонтрагента()

// Процедура выполняет стандартные действия при начале выбора документа составного типа в формах документов.
//
// Параметры:
//  ДокументОбъект       - объект редактируемого документа;
//  ФормаДокумента       - форма редактируемого документа;
//  ЭлементФормы         - элемент формы документа, который надо заполнить; 
//  СтандартнаяОбработка - булево, признак выполнения стандартной (системной) обработки события 
//                         начала выбора для данного элемента формы документа.
//  СтруктураОтбора      - структура, содержащая имена и значения отборов в форме выбора.
//  ИмяТабличнойЧасти    - имя табличной части
//
Процедура НачалоВыбораЗначенияДокументаСоставногоТипа(ДокументОбъект, ФормаДокумента, ЭлементФормы, 
					   СтандартнаяОбработка, СтруктураОтбора, ИмяТабличнойЧасти,ОграничениеТипов = Неопределено) Экспорт

	СтандартнаяОбработка = Ложь;

	// Заполним возможный список типов документов, которые могут быть в этом реквизите.
	СписокТипов = Новый СписокЗначений;

	Если ПустаяСтрока(ИмяТабличнойЧасти) Тогда // Шапка документа
		МассивТипов = ДокументОбъект.Метаданные().Реквизиты[ЭлементФормы.Данные].Тип.Типы();
	Иначе // Табличная часть
		ИмяКолонки  = ФормаДокумента.ЭлементыФормы[ИмяТабличнойЧасти].ТекущаяКолонка.Имя;
		МассивТипов = ДокументОбъект.Метаданные().ТабличныеЧасти[ИмяТабличнойЧасти].Реквизиты[ИмяКолонки].Тип.Типы();
	КонецЕсли;
	
	Если не ОграничениеТипов = Неопределено Тогда
		СписокОграниченияТипов = Новый СписокЗначений();
		СписокОграниченияТипов.ЗагрузитьЗначения(ОграничениеТипов);
	КонецЕсли; 

	Если МассивТипов.Количество() = 1 Тогда
		ОбъектОписанияМетаданных = Метаданные.НайтиПоТипу(МассивТипов[0]);
		ВыбранныйТип = ОбъектОписанияМетаданных.Имя;
	Иначе

		Для каждого ЭлементМассива Из МассивТипов Цикл
            Если не ОграничениеТипов = Неопределено Тогда
			    Если СписокОграниченияТипов.НайтиПоЗначению(ЭлементМассива) = Неопределено Тогда
				 	// Тип не вписывается в полученные ограничения
					Продолжить;
				КонецЕсли; 
			КонецЕсли; 
			ПустоеЗначение = Новый(ЭлементМассива);
			ОбъектОписанияМетаданных = ПустоеЗначение.Метаданные();
			СписокТипов.Добавить(ОбъектОписанияМетаданных.Имя, ОбъектОписанияМетаданных.Представление());

		КонецЦикла; 

		ВыбранныйЭлемент = ФормаДокумента.ВыбратьИзСписка(СписокТипов, ЭлементФормы);

		Если ВыбранныйЭлемент = Неопределено Тогда // Отказ от выбора
			Возврат;
		КонецЕсли;
		ВыбранныйТип = ВыбранныйЭлемент.Значение;
	КонецЕсли;

	Если ТипЗнч(ЭлементФормы.Значение) <> Тип("ДокументСсылка." + ВыбранныйТип) Тогда
		ЭлементФормы.Значение = Документы[ВыбранныйТип].ПустаяСсылка();
	КонецЕсли;

	Если ТипЗнч(ЭлементФормы.Значение) = Тип("ДокументСсылка.ДокументРасчетовСКонтрагентом") Тогда

		МетаданныеДокумента = ДокументОбъект.Метаданные();
		
		СписокПараметров = Новый Структура;
		СписокПараметров.Вставить("Дата",               ДокументОбъект.Дата);
		
		Если ТипЗнч(СтруктураОтбора) = Тип("Структура") и СтруктураОтбора.Свойство("Контрагент") Тогда
			СписокПараметров.Вставить("Контрагент",         СтруктураОтбора.Контрагент);
		ИначеЕсли  ЕстьРеквизитДокумента("Контрагент", МетаданныеДокумента) тогда
			СписокПараметров.Вставить("Контрагент",     ДокументОбъект.Контрагент);
		КонецЕсли; 
		
		Если ТипЗнч(СтруктураОтбора) = Тип("Структура") и СтруктураОтбора.Свойство("ДоговорКонтрагента") Тогда
			СписокПараметров.Вставить("ДоговорКонтрагента",         СтруктураОтбора.ДоговорКонтрагента);
		ИначеЕсли  ЕстьРеквизитДокумента("ДоговорКонтрагента", МетаданныеДокумента) тогда
			СписокПараметров.Вставить("ДоговорКонтрагента",     ДокументОбъект.ДоговорКонтрагента);
		КонецЕсли; 
		
		Если ТипЗнч(СтруктураОтбора) = Тип("Структура") и СтруктураОтбора.Свойство("Организация") Тогда
			СписокПараметров.Вставить("Организация",         СтруктураОтбора.Организация);
		ИначеЕсли  ЕстьРеквизитДокумента("Организация", МетаданныеДокумента) тогда
			СписокПараметров.Вставить("Организация",     ДокументОбъект.Организация);
		КонецЕсли; 
		
		ОбработатьВыборСубконто(ЭлементФормы, Ложь, ДокументОбъект.Организация, СписокПараметров);
		Возврат;

	КонецЕсли;

	// В качестве владельца формы выбора устанавливаем данный элемент,
	// чтобы выбранное значение было присвоено стандартно.
	ФормаВыбора = Документы[ВыбранныйТип].ПолучитьФормуВыбора(,ЭлементФормы,);

	Попытка
		// Отфильруем список документов.
		Для каждого ЭлементСтруктуры Из СтруктураОтбора Цикл

			Если ТипЗнч(ЭлементСтруктуры.Значение) = Тип("СписокЗначений") Тогда
				ФормаВыбора.Отбор[ЭлементСтруктуры.Ключ].ВидСравнения = ВидСравнения.ВСписке;
			КонецЕсли;

			ФормаВыбора.Отбор[ЭлементСтруктуры.Ключ].Значение      = ЭлементСтруктуры.Значение;
			ФормаВыбора.Отбор[ЭлементСтруктуры.Ключ].Использование = Истина;

		КонецЦикла;

	Исключение
		// нет таких отборов как заявлено в структуре.
	КонецПопытки;

	Если Не ЗначениеНеЗаполнено(ЭлементФормы.Значение) Тогда
		ФормаВыбора.ПараметрТекущаяСтрока = ЭлементФормы.Значение;
	КонецЕсли;

	ФормаВыбора.Открыть();

КонецПроцедуры // НачалоВыбораЗначенияДокументаСоставногоТипа()

// Процедура выполняет стандартные действия при начале выбора документа составного типа в формах документов.
//
// Параметры:
//  Объект       - объект редактируемого документа;
//  ФормаОбъекта       	 - форма редактируемого объекта;
//  ЭлементФормы         - элемент формы документа, который надо заполнить; 
//  СтандартнаяОбработка - булево, признак выполнения стандартной (системной) обработки события 
//                         начала выбора для данного элемента формы документа.
//  СтруктураОтбора      - структура, содержащая имена и значения отборов в форме выбора.
//  ИмяТабличнойЧасти    - имя табличной части
//
Процедура НачалоВыбораЗначенияСправочникаСоставногоТипа(Объект, ФормаОбъекта, ЭлементФормы, 
					   СтандартнаяОбработка, СтруктураОтбора, ИмяТабличнойЧасти,ОграничениеТипов = Неопределено) Экспорт

	СтандартнаяОбработка = Ложь;

	// Заполним возможный список типов документов, которые могут быть в этом реквизите.
	СписокТипов = Новый СписокЗначений;

	Если ПустаяСтрока(ИмяТабличнойЧасти) Тогда // Шапка документа
		МассивТипов = Объект.Метаданные().Реквизиты[ЭлементФормы.Данные].Тип.Типы();
	Иначе // Табличная часть
		ИмяКолонки  = ФормаОбъекта.ЭлементыФормы[ИмяТабличнойЧасти].ТекущаяКолонка.Имя;
		МассивТипов = Объект.Метаданные().ТабличныеЧасти[ИмяТабличнойЧасти].Реквизиты[ИмяКолонки].Тип.Типы();
	КонецЕсли;
	
	Если не ОграничениеТипов = Неопределено Тогда
		СписокОграниченияТипов = Новый СписокЗначений();
		СписокОграниченияТипов.ЗагрузитьЗначения(ОграничениеТипов);
	КонецЕсли; 

	Если МассивТипов.Количество() = 1 Тогда
		ОбъектОписанияМетаданных = Метаданные.НайтиПоТипу(МассивТипов[0]);
		ВыбранныйТип = ОбъектОписанияМетаданных.Имя;
	Иначе

		Для каждого ЭлементМассива Из МассивТипов Цикл
            Если не ОграничениеТипов = Неопределено Тогда
			    Если СписокОграниченияТипов.НайтиПоЗначению(ЭлементМассива) = Неопределено Тогда
				 	// Тип не вписывается в полученные ограничения
					Продолжить;
				КонецЕсли; 
			КонецЕсли; 
			ПустоеЗначение = Новый(ЭлементМассива);
			ОбъектОписанияМетаданных = ПустоеЗначение.Метаданные();
			СписокТипов.Добавить(ОбъектОписанияМетаданных.Имя, ОбъектОписанияМетаданных.Представление());

		КонецЦикла; 

		ВыбранныйЭлемент = ФормаОбъекта.ВыбратьИзСписка(СписокТипов, ЭлементФормы);

		Если ВыбранныйЭлемент = Неопределено Тогда // Отказ от выбора
			Возврат;
		КонецЕсли;
		ВыбранныйТип = ВыбранныйЭлемент.Значение;
	КонецЕсли;

	Если ТипЗнч(ЭлементФормы.Значение) <> Тип("СправочникСсылка." + ВыбранныйТип) Тогда
		ЭлементФормы.Значение = Справочники[ВыбранныйТип].ПустаяСсылка();
	КонецЕсли;

	// В качестве владельца формы выбора устанавливаем данный элемент,
	// чтобы выбранное значение было присвоено стандартно.
	ФормаВыбора = Справочники[ВыбранныйТип].ПолучитьФормуВыбора(,ЭлементФормы,);

	Попытка
		// Отфильруем список документов.
		Для каждого ЭлементСтруктуры Из СтруктураОтбора Цикл

			Если ТипЗнч(ЭлементСтруктуры.Значение) = Тип("СписокЗначений") Тогда
				ФормаВыбора.Отбор[ЭлементСтруктуры.Ключ].ВидСравнения = ВидСравнения.ВСписке;
			КонецЕсли;

			ФормаВыбора.Отбор[ЭлементСтруктуры.Ключ].Значение      = ЭлементСтруктуры.Значение;
			ФормаВыбора.Отбор[ЭлементСтруктуры.Ключ].Использование = Истина;

		КонецЦикла;

	Исключение
		// нет таких отборов как заявлено в структуре.
	КонецПопытки;

	Если Не ЗначениеНеЗаполнено(ЭлементФормы.Значение) Тогда
		ФормаВыбора.ПараметрТекущаяСтрока = ЭлементФормы.Значение;
	КонецЕсли;

	ФормаВыбора.Открыть();

КонецПроцедуры // НачалоВыбораЗначенияДокументаСоставногоТипа()

// Процедура выполняет стандартные действия при начале выбора структурной единицы контрагента в формах документов.
//
// Параметры:
//  ВладелецБанковскогоСчета - ссылка на справочник, определяет владельца банковского счета;
//  ЭлементФормы             - элемент формы документа, который надо заполнить; 
//  СтандартнаяОбработка,    - булево, признак выполнения стандартной (системной) обработки события 
//                             начала выбора для данного элемента формы документа.
//  ВалютаБанковскогоСчета   - ссылка на справочник, определяет валюту банковского счета,
//                             если неп заполнено, то список банковских счетов не фильтруется по валюте;
//
Процедура НачалоВыбораЗначенияБанковскогоСчета(ВладелецБанковскогоСчета,ЭлементФормы, СтандартнаяОбработка, 
									   ВалютаБанковскогоСчета = Неопределено) Экспорт

	СтандартнаяОбработка = Ложь;

	ФормаВыбораБанковскогоСчета = Справочники.БанковскиеСчета.ПолучитьФормуСписка(, ЭлементФормы);
	ФормаВыбораБанковскогоСчета.ПараметрОтборПоВладельцу = ВладелецБанковскогоСчета;

	Если Не ЗначениеНеЗаполнено(ВалютаБанковскогоСчета) Тогда

		ФормаВыбораБанковскогоСчета.Отбор.ВалютаДенежныхСредств.Значение      = ВалютаБанковскогоСчета;
		ФормаВыбораБанковскогоСчета.Отбор.ВалютаДенежныхСредств.Использование = Истина;

	КонецЕсли;

	ФормаВыбораБанковскогоСчета.РежимВыбора = Истина;
	ФормаВыбораБанковскогоСчета.Открыть();


КонецПроцедуры // НачалоВыбораЗначенияБанковскогоСчета()

// Процедура выполняет стандартные действия при начале выбора склада в формах документов.
//
// Параметры:
//  ДокументОбъект        - объект редактируемого документа;
//  ФормаДокумента        - форма редактируемого документа;
//  ЭлементФормы          - элемент формы документа, который надо заполнить; 
//  Склад                 - текущий склад в форме;
//  ВидСравненияНТТ       - Вид сравнения - равно или не равно неавтоматизированной торговой точке;
//  СтандартнаяОбработка, - булево, признак выполнения стандартной (системной) обработки события 
//                          начала выбора для данного элемента формы документа;
//
//Процедура НачалоВыбораСкладаНТТ(ДокументОбъект, ФормаДокумента, ЭлементФормы, Склад, ВидСравненияНТТ,
//							  СтандартнаяОбработка) Экспорт

//	СтандартнаяОбработка = Ложь;

//	// В качестве владельца формы выбора устанавливаем данный элемент формы, чтобы выбранное
//	// значение было присвоено стандартно.
//	ФормаВыбора = Справочники.Склады.ПолучитьФормуВыбора(,ЭлементФормы,);

//	// уберем из выбора неавтоматизированные торговые точки
//	ФормаВыбора.СправочникСписок.Отбор.ВидСклада.Значение                            = Перечисления.ВидыСкладов.НеавтоматизированнаяТорговаяТочка;
//	ФормаВыбора.СправочникСписок.Отбор.ВидСклада.Использование                       = Истина;
//	ФормаВыбора.СправочникСписок.Отбор.ВидСклада.ВидСравнения                        = ВидСравненияНТТ;
//	ФормаВыбора.ЭлементыФормы.СправочникСписок.НастройкаОтбора.ВидСклада.Доступность = Ложь;
//	
//	ФормаВыбора.ЭлементыФормы.СправочникСписок.ТекущаяСтрока                         = Склад;

//	ФормаВыбора.Открыть();

//КонецПроцедуры // НачалоВыбораСкладаНТТ()

// Процедура вызывается в обработчике события "Начало выбора" в форме документов.
// Выполняет выбор даты курса и устанавливает курс взаиморасчетов по выбранной дате.
//
// Параметры:
//  ДокументОбъект - объект редактируемого документа,
//
Процедура ВыбратьКурсВзаиморасчетов(ДокументОбъект) Экспорт

	// Если не заполнен договор, то курс взаиморасчетов выбрать нельзя
	Если ЗначениеНеЗаполнено(ДокументОбъект.ДоговорКонтрагента) Тогда
		Предупреждение("Для выбора курса взаиморасчетов нужно выбрать договор контрагента."); 
		Возврат;
	КонецЕсли; 
	
	// Выберем курс.
	ВыбратьКурсВалюты(ДокументОбъект.КурсВзаиморасчетов,ДокументОбъект.КратностьВзаиморасчетов,
					   ДокументОбъект.ДоговорКонтрагента.ВалютаВзаиморасчетов, 
					   ДокументОбъект.Дата); //По умолчанию курс всегда на дату документа

КонецПроцедуры // ВыбратьКурсВзаиморасчетов()

// Процедура вызывается в обработчике события "Начало выбора" в форме документов.
// Выполняет выбор даты курса и устанавливает переданный курс по выбранной дате.
//
// Параметры:
//  Курс   - число, курс валюты, который надо установить;
//  Валюта - ссылка на справочник, определяет валюту чей курс надо выбрать;
//  Дата   - дата, дата курса по умолчанию.
//
Процедура ВыбратьКурсВалюты(Курс, Кратность, Валюта, Дата) Экспорт

	// Если не заполнена валюта, то курс выбрать нельзя.
	Если ЗначениеНеЗаполнено(Валюта) Тогда
		Предупреждение("Для выбора курса нужно выбрать валюту."); 
		Возврат;
	КонецЕсли; 
	
	// Выберем дату курса
	ДатаУстановкиКурса = Дата; 
	Если ВвестиДату(ДатаУстановкиКурса, "Выберите дату установки курса.", ЧастиДаты.Дата) Тогда
		
		// Если дата введена, заполним значение курса и кратности
		СтруктураВалюты = ПолучитьКурсВалюты(Валюта, ДатаУстановкиКурса);
		Курс            = СтруктураВалюты.Курс;
		Кратность       = СтруктураВалюты.Кратность;

	КонецЕсли; 

КонецПроцедуры // ВыбратьКурсВалюты()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ОФОРМЛЕНИЯ ФОРМЫ

// Формирует и устанавливает текст заголовка формы документа
//
// Параметры:
//  СтрокаВидаОперации - строка вида операции документа, 
//  ДокументОбъект     - объект документа, 
//  ФормаДокумента     - форма документа.
//
Процедура УстановитьЗаголовокФормыДокумента(СтрокаВидаОперации = "", ДокументОбъект, ФормаДокумента) Экспорт

	ФормаДокумента.АвтоЗаголовок = Ложь; // заголовок будем писать сами
	
	Если ПустаяСтрока(СтрокаВидаОперации) Тогда
		Заголовок = ДокументОбъект.Метаданные().Синоним + ": ";
	Иначе
		Заголовок = ДокументОбъект.Метаданные().Синоним + ": " + СтрокаВидаОперации + ". ";
	КонецЕсли;
		
	Если ДокументОбъект.ЭтоНовый() Тогда  
		Заголовок = Заголовок + "Новый";
	Иначе
		Если ДокументОбъект.Проведен Тогда
			Заголовок = Заголовок + "Проведен";
		ИначеЕсли ДокументОбъект.Метаданные().Проведение = Метаданные.СвойстваОбъектов.Проведение.Разрешить Тогда
			Заголовок = Заголовок + "Не проведен";
		Иначе
			Заголовок = Заголовок + "Записан";
		КонецЕсли;
	КонецЕсли;
	
	ФормаДокумента.Заголовок = Заголовок;

КонецПроцедуры // УстановитьЗаголовокФормыДокумента()

// Устанавливает видимость закладки "Возвратная тара" в форме документа
//
// Параметры:
//  ФормаДокумента - форма документа.
//
Процедура УстановитьВидимостьЗакладкиВозвратнаяТара(ФормаДокумента) Экспорт

	ИспользоватьВозвратнуюТару = ?(ФормаДокумента.ВозвратнаяТара.Количество() = 0, Константы.ИспользоватьВозвратнуюТару.Получить(), Истина);

	СтраницыПанели                  = ФормаДокумента.ЭлементыФормы.ОсновнаяПанель.Страницы;
	СтраницыПанели.Тара.Видимость   = ИспользоватьВозвратнуюТару;
	СтраницыПанели.Тара.Доступность = ИспользоватьВозвратнуюТару;

КонецПроцедуры // УстановитьВидимостьЗакладкиВозвратнаяТара()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ОБРАБОТКИ ИНФОРМАЦИИ В ФОРМЕ

//  Процедура определяет ситуацию, когда при изменении своей даты документ 
//  оказывается в другом периоде нумерации документов, и в это м случае
//  присваивает документу новый уникальный номер.
//
// Параметры:
//  ДокументОбъект         - контекст документа,из которого вызвана процедура 
//  НачальнаяДатаДокумента - начальная дата документа 
// 
Процедура ПроверитьНомерДокумента(ДокументОбъект, НачальнаяДатаДокумента) Экспорт   // в разработке

	// Определяем назначенную для данного вида документов периодичность смены номера
	ПериодСменыНомера = ДокументОбъект.Метаданные().ПериодичностьНомера;

	//В зависимости от установленной периодичности смены номеров,
	//определяем разность старой и новой датами документа.
	Если ПериодСменыНомера = Метаданные.СвойстваОбъектов.ПериодичностьНомераДокумента.Год Тогда
		РазностьДат = НачалоГода(НачальнаяДатаДокумента) - НачалоГода(ДокументОбъект.Дата);

	ИначеЕсли ПериодСменыНомера = Метаданные.СвойстваОбъектов.ПериодичностьНомераДокумента.Квартал Тогда
		РазностьДат = НачалоКвартала(НачальнаяДатаДокумента) - НачалоКвартала(ДокументОбъект.Дата);

	ИначеЕсли ПериодСменыНомера = Метаданные.СвойстваОбъектов.ПериодичностьНомераДокумента.Месяц Тогда
		РазностьДат = НачалоМесяца(НачальнаяДатаДокумента) - НачалоМесяца(ДокументОбъект.Дата);

	ИначеЕсли ПериодСменыНомера = Метаданные.СвойстваОбъектов.ПериодичностьНомераДокумента.День Тогда
		РазностьДат = НачальнаяДатаДокумента - ДокументОбъект.Дата;

	Иначе
		Возврат;

	КонецЕсли;

	Если РазностьДат <> 0 Тогда
		УстановитьНомерДокумента(ДокументОбъект);
	КонецЕсли;

КонецПроцедуры // ПроверитьНомерДокумента()

// Процедура выполняет общие действия при изменнении даты документа
//
// Параметры:
//  ДокументОбъект                 - объект редактируемого документа
//  ВалютаРегламентированногоУчета - валюта регламентированного учета
//  ФлагИзмененияКурса             - валюта регламентированного учета
//
Процедура ПриИзмененииЗначенияДатыДокумента(ДокументОбъект, ВалютаРегламентированногоУчета, ФлагИзмененияКурса = Неопределено) Экспорт

	МетаданныеДокумента            = ДокументОбъект.Метаданные();
	ЕстьВалютаДокумента            = ЕстьРеквизитДокумента("ВалютаДокумента",    МетаданныеДокумента);
	ЕстьДоговорКонтрагента         = ЕстьРеквизитДокумента("ДоговорКонтрагента", МетаданныеДокумента);
	ПроверкаПоВалютеВзаиморасчетов = Ложь;
	ФлагИзмененияКурса             = Ложь;

	// В некоторых документах нет валюты документа и договора.
	Если ЕстьВалютаДокумента Тогда
		Если ЕстьДоговорКонтрагента Тогда
			Договор = ДокументОбъект.ДоговорКонтрагента;

			Если НЕ ЗначениеНеЗаполнено(Договор) Тогда
				Валюта = Договор.ВалютаВзаиморасчетов;
				ПроверкаПоВалютеВзаиморасчетов = Истина;
			Иначе
				Возврат;
			КонецЕсли;
		Иначе
			Валюта = ДокументОбъект.ВалютаДокумента;
		КонецЕсли;
	Иначе
		Возврат;
	КонецЕсли;

	СтруктураНовогоКурсаВалюты  = ПолучитьКурсВалюты(Валюта, ДокументОбъект.Дата);
	НовыйКурс                   = СтруктураНовогоКурсаВалюты.Курс;
	НоваяКратность              = СтруктураНовогоКурсаВалюты.Кратность;

	ЕстьКурсДокумента           = ЕстьРеквизитДокумента("КурсДокумента",           МетаданныеДокумента);
	ЕстьКратностьДокумента      = ЕстьРеквизитДокумента("КратностьДокумента",      МетаданныеДокумента);
	ЕстьКурсВзаиморасчетов      = ЕстьРеквизитДокумента("КурсВзаиморасчетов",      МетаданныеДокумента);
	ЕстьКратностьВзаиморасчетов = ЕстьРеквизитДокумента("КратностьВзаиморасчетов", МетаданныеДокумента);

	// В некоторых документах курс и кратность документа отсутствуют
	Если ПроверкаПоВалютеВзаиморасчетов И ЕстьКурсВзаиморасчетов И ЕстьКратностьВзаиморасчетов Тогда
		СтарыйКурс      = ДокументОбъект.КурсВзаиморасчетов;
		СтараяКратность = ДокументОбъект.КратностьВзаиморасчетов;
	ИначеЕсли НЕ ПроверкаПоВалютеВзаиморасчетов И ЕстьКурсДокумента И ЕстьКратностьДокумента Тогда
		СтарыйКурс      = ДокументОбъект.КурсДокумента;
		СтараяКратность = ДокументОбъект.КратностьДокумента;
	Иначе
		Возврат;
	КонецЕсли;

	// Если курс и кратность неизменилась, то выход.
	Если НовыйКурс = СтарыйКурс И НоваяКратность = СтараяКратность Тогда
		Возврат;
	КонецЕсли;

	ТекстВалюты     = ?(ПроверкаПоВалютеВзаиморасчетов, "взаиморасчетов ", "документа ");
	ТекстНовыйКурс  = СокрЛП(ПолучитьИнформациюКурсаВалютыСтрокой(Валюта, НовыйКурс,  НоваяКратность,  ВалютаРегламентированногоУчета, Истина));
	ТекстСтарыйКурс = СокрЛП(ПолучитьИнформациюКурсаВалютыСтрокой(Валюта, СтарыйКурс, СтараяКратность, ВалютаРегламентированногоУчета, Истина));
	ТекстВопроса    = "На дату документа у валюты "  + ТекстВалюты+ ТекстСтарыйКурс + " был задан другой курс."
	                + Символы.ПС+ "Установить курс " + ТекстВалюты+ ТекстНовыйКурс + " в соответствии с курсом валюты?";
	Ответ           = Вопрос(ТекстВопроса, РежимДиалогаВопрос.ДаНет,, КодВозвратаДиалога.Да);

	Если Ответ = КодВозвратаДиалога.Да Тогда
		Если ЕстьКурсДокумента Тогда
			ДокументОбъект.КурсДокумента           = НовыйКурс;
		КонецЕсли;
		Если ЕстьКратностьДокумента Тогда
			ДокументОбъект.КратностьДокумента      = НоваяКратность;
		КонецЕсли;
		Если ЕстьКурсВзаиморасчетов Тогда
			ДокументОбъект.КурсВзаиморасчетов      = НовыйКурс;
		КонецЕсли;
		Если ЕстьКратностьВзаиморасчетов Тогда
			ДокументОбъект.КратностьВзаиморасчетов = НоваяКратность;
		КонецЕсли;

		ФлагИзмененияКурса = Истина;
	КонецЕсли;

КонецПроцедуры // ПриИзмененииЗначенияДатыДокумента()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ПОДГОТОВКИ ИНФОРМАЦИИ В ФОРМЕ

// Активизирует один из реквизитов при открытии документа.
//
// Параметры:
//  ДокументОбъект     - объект документа, 
//  ФормаДокумента     - форма документа.
//
Процедура АктивизироватьРеквизитВФорме(ДокументОбъект, ФормаДокумента) Экспорт

	// Структура - порядок актиизации реквизитов.
	// Активизируется первый не заполненный.
	СтруктураРеквизитов = Новый Структура();
	
	СтруктураРеквизитов.Вставить("Дата");
	СтруктураРеквизитов.Вставить("Номер");
	СтруктураРеквизитов.Вставить("Организация");
	СтруктураРеквизитов.Вставить("Касса");
	СтруктураРеквизитов.Вставить("СчетОрганизации");
	СтруктураРеквизитов.Вставить("БанковскийСчет");
	СтруктураРеквизитов.Вставить("Склад");
	СтруктураРеквизитов.Вставить("Контрагент");
	СтруктураРеквизитов.Вставить("Получатель");
	СтруктураРеквизитов.Вставить("Плательщик");
	СтруктураРеквизитов.Вставить("ФизЛицо");

	Для каждого Элемент Из СтруктураРеквизитов Цикл

		// Определим, есть ли ЭУ с таким именем.
		ЭлементУправления = ФормаДокумента.ЭлементыФормы.Найти(Элемент.Ключ);
		Если ЭлементУправления <> Неопределено Тогда // есть такой
			Если ЗначениеНеЗаполнено(ЭлементУправления.Значение) Тогда 

				// Нашли не заполненный ЭУ. Делаем его текущим и прекращаем цикл.
				ФормаДокумента.ТекущийЭлемент = ЭлементУправления;
				Прервать;
			КонецЕсли; 
		КонецЕсли;
	КонецЦикла; 

КонецПроцедуры // АктивизироватьРеквизитВФорме()

// Процедура устанавливает видимость приказа в документе
//
Процедура УстановитьВидимостьПриказа(ЗаполняемаяФорма,Организация,УчетнаяПолитикаПоВнутреннимСовместителям) Экспорт	
	
	ПоддержкаВнутреннегоСовместительства = УчетнаяПолитикаПоВнутреннимСовместителям[Организация].ПоддержкаВнутреннегоСовместительства;
	Элементы	=	ЗаполняемаяФорма.ЭлементыФормы;
	Для каждого Элемент из	Элементы	Цикл
		Если Строка(ТипЗнч(Элемент)) = "Табличное поле" Тогда
			Колонки	= Элемент.Колонки;
			Для Каждого Колонка Из Колонки Цикл
				Если Колонка.Имя = "Приказ" Тогда
					Колонка.Видимость			= Колонка.Видимость И ПоддержкаВнутреннегоСовместительства;
					Колонка.ИзменятьВидимость	= ПоддержкаВнутреннегоСовместительства;		
				КонецЕсли;
			КонецЦикла;
		Иначе
			Если (Элемент.Имя = "Приказ") или (Элемент.Имя = "НадписьПриказОПриеме") Тогда
				Элемент.Видимость			= ПоддержкаВнутреннегоСовместительства;
			КонецЕсли;
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

Процедура ЗаполнениеОтбораПоОрганизацииПоУмолчанию(Форма, ЭлементОтбора, ЭлементФормы, ПараметрОтборПоРегистратору, ИспользоватьГоловнуюОрганизацию = Истина, ТекущийПользователь, ТекстЗаголовка = Неопределено) Экспорт
	
	ЭлементФормы.ТолькоПросмотр = Ложь;
	
	Если Не ЗначениеНеЗаполнено(ПараметрОтборПоРегистратору) Тогда
		
		МетаданныеДокумента = ПараметрОтборПоРегистратору.Метаданные();
		
		Если МетаданныеДокумента.Реквизиты.Найти("СторнируемыйДокумент") <> Неопределено Тогда
			
			МетаданныеДокумента 		= ПараметрОтборПоРегистратору.СторнируемыйДокумент.Метаданные();
			ПараметрОтборПоРегистратору = ПараметрОтборПоРегистратору.СторнируемыйДокумент;
			
		КонецЕсли;
		
		Если МетаданныеДокумента.Реквизиты.Найти("Организация") <> Неопределено Тогда
			
			Если ИспользоватьГоловнуюОрганизацию Тогда
				Организация = ГоловнаяОрганизация(ПараметрОтборПоРегистратору.Организация);
			Иначе
				Организация = ПараметрОтборПоРегистратору.Организация;
			КонецЕсли;
			
			ЭлементОтбора.Значение = Организация;
			ЭлементФормы.ТолькоПросмотр = Истина;
			Если ТекстЗаголовка <> Неопределено Тогда
				Форма.Заголовок = ТекстЗаголовка + Организация.Наименование;
			КонецЕсли; 
			
		КонецЕсли;
		
		ЭлементОтбора.Использование = Истина;
		
	Иначе
		
		Если ИспользоватьГоловнуюОрганизацию Тогда 
			Организация = ГоловнаяОрганизация(ПолучитьЗначениеПоУмолчанию(ТекущийПользователь,"ОсновнаяОрганизация"));
		Иначе
			Организация = ПолучитьЗначениеПоУмолчанию(ТекущийПользователь,"ОсновнаяОрганизация");
		КонецЕсли;
		
		ЭлементОтбора.Значение = Организация;
		ЭлементОтбора.Использование = Не Организация.Пустая();
		Если ТекстЗаголовка <> Неопределено Тогда
			Если Организация.Пустая() Тогда
				Форма.Заголовок = СтрЗаменить(ТекстЗаголовка,"организации","организаций");
			Иначе 
				Форма.Заголовок = ТекстЗаголовка + Организация.Наименование;
			КонецЕсли;
		КонецЕсли; 
		
	КонецЕсли;
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ЗАПОЛНЕНИЯ РЕКВИЗИТОВ В ФОРМЕ

// Процедура предназначена для заполнения реквизитов формы,
// вызывается в обработчиках событий "ПриОткрытии" в модулях форм обработок.
//
// Параметры:
//  ЗаполняемаяФорма  - форма, реквизиты которой следует заполнить,
//  ТекПользователь - ссылка на справочник, определяет текущего пользователя  
//
Процедура ЗаполнитьРеквизитыФормы(ЗаполняемаяФорма, ТекПользователь) Экспорт

	Элементы = ЗаполняемаяФорма.ЭлементыФормы;

	Для каждого Элемент из Элементы Цикл

		Если	Элемент.Имя = "Организация" тогда
			Элемент.Значение = ПолучитьЗначениеПоУмолчанию(ТекПользователь, "ОсновнаяОрганизация");
		КонецЕсли;

	КонецЦикла;

КонецПроцедуры // ЗаполнитьРеквизитыФормы()

// Процедура установки типа и доступности субконто в зависимости от  выбранного счета
//
//     Параметры:
//          Счет - выбранный счет
//          Форма - форма(или табличное поле) на которой расположены счет и субконто
//          Префикс - префекс наименования субконто. к префиксу добавляется номер субконто на счете
//                    для подписи с наименованием субконто предпологается имя
//                    вида "Надпись" + Префикс + НомерСубконто
//                    в случае если форма - это таб.поле, то надписи не устанавливаются
//
Процедура ПриВыбореСчета(Счет, Субконто1, НадписьСубконто1, Субконто2, НадписьСубконто2, Субконто3, НадписьСубконто3, ПолеСчет = НЕОПРЕДЕЛЕНО, ТолькоПросмотр = ЛОЖЬ) Экспорт
	
	ЭлементыСубконто = Новый Структура("Субконто1,НадписьСубконто1,Субконто2,НадписьСубконто2,Субконто3,НадписьСубконто3", Субконто1, НадписьСубконто1, Субконто2, НадписьСубконто2, Субконто3, НадписьСубконто3);
	
	ЧислоАктивныхСубконто = Счет.ВидыСубконто.Количество();
	
	ЧислоАктивныхСубконто=Мин(ЧислоАктивныхСубконто,3);
	
	Для Сч = 1 По ЧислоАктивныхСубконто Цикл
		
		ТипСубк = Счет.ВидыСубконто[Сч - 1].ВидСубконто.ТипЗначения;
		
		ЭлементыСубконто["Субконто" + Сч].Видимость = НЕ ТолькоПросмотр;
		ЭлементыСубконто["Субконто" + Сч].ВыбиратьТип = Ложь;
		
		// Чтобы не устанавливался флаг модифицированности при открытии формы
		Если ТипСубк.ПривестиЗначение(ЭлементыСубконто["Субконто" + Сч].Значение) <> ЭлементыСубконто["Субконто" + Сч].Значение Тогда
			ЭлементыСубконто["Субконто" + Сч].Значение = ТипСубк.ПривестиЗначение(ЭлементыСубконто["Субконто" + Сч].Значение);
		КонецЕсли;

		ЭлементыСубконто["НадписьСубконто" + Сч].Заголовок = Счет.ВидыСубконто[Сч - 1].ВидСубконто.Наименование + ":";
		ЭлементыСубконто["НадписьСубконто" + Сч].Видимость = НЕ ТолькоПросмотр;
		
	КонецЦикла;
	
	Для Сч = (ЧислоАктивныхСубконто + 1) По 3 Цикл
		
		Если Не ЭлементыСубконто["Субконто" + Сч].Значение = Неопределено Тогда
			ЭлементыСубконто["Субконто" + Сч].Значение = Неопределено;
		КонецЕсли;
		
		ЭлементыСубконто["Субконто" + Сч].Видимость = Ложь;
		ЭлементыСубконто["НадписьСубконто" + Сч].Видимость = Ложь;
		
	КонецЦикла;
	
	Если ПолеСчет <> НЕОПРЕДЕЛЕНО Тогда
		ПолеСчет.ТолькоПросмотр = ТолькоПросмотр;
	КонецЕсли;
	
КонецПроцедуры // ПриВыбореСчета()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ФОРМИРОВАНИЯ И ОБРАБОТКИ МЕНЮ

// Заполняет список пунктов подменю выбора вида операции значениями переданной коллекции объектов метаданных,
// соответствующей перечислению видов операций для данного документа.
// Всем кнопкам назначается одно переданное действие.
// Обычно используется для заполнения пунктов подменю "ПодменюВидаОперации" командной панели
// формы документа значениями перечисления "Вид операции" для данного вида документа
//
// Параметры:
//  ЭлементМеню                   - кнопка командной панели формы, соответствующая подменю, которое надо заполнить, 
//  ОбъектЗаполнения              - коллекция для заполнения пунктов подменю, 
//  ОбъектОбработкиВыбораОперации - действие, которое надо выполнить при выборе любого пункта подменю.
//
Процедура УстановитьПодменюВыбораВидаОперации(ЭлементМеню, ОбъектЗаполнения, ОбъектОбработкиВыбораОперации) Экспорт

	Для каждого ЭлементЗаполнения Из ОбъектЗаполнения Цикл
		ЭлементМеню.Кнопки.Добавить(ЭлементЗаполнения.Имя, ТипКнопкиКоманднойПанели.Действие, 
		                            ЭлементЗаполнения.Синоним, ОбъектОбработкиВыбораОперации);
	КонецЦикла;

КонецПроцедуры // УстановитьПодменюВыбораВидаОперации()

//настройка подменю Клиент-Банк
Процедура УстановкаПодменюКлиентБанк(Кнопка, Объект) Экспорт

	Если Объект.РеквизитыКонтрагента.Количество() = 0 Тогда
		Кнопка.СоздатьКонтрагента.Доступность =Ложь;
	Иначе
		Кнопка.СоздатьКонтрагента.Доступность =Истина;
	КонецЕсли; 

КонецПроцедуры // УстановкаПодменюКлиентБанк()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ВЫПОЛНЕНИЯ ДЕЙСТВИЙ В ФОРМЕ

// Процедура вызывает сервисный механизм для изменения общих для
// всей табличной части Товары реквизитов, таких, например, как
// тип цен, валюта и т. д.
//
// Параметры:
//  ДокументОбъект                     - обьъект редактируемого документа; 
//  СпособЗаполненияЦен                - значение перечисления "Способы заполнения цен", определяет по какому из 
//                                       регистров ("Цены компании" или "Цены контрагентов") будет строиться запрос.
//  СтруктураРеквизитовДокумента       - структура, задает список обрабатываемых реквизитов документа;
//                                       если реквизит надо обрабатывать, то для него есть ключ в этой структуре;
//  СтруктураНеРедактируемыхРеквизитов - структура, задает список реквизитов, которые надо показывать, 
//                                       но не надо давать изменять, необязательный параметр;
//  ИмяТабличнойЧасти                  - строка, имя табличной части, которую надо пересчитать;
//  ВалютаРегламентированногоУчета     - валюта регламентированного учета
//  СтруктураЗначений                  - для эмуляции ввода пользователем валюты, типа цен и пр. Применяется при
//                                       автоматическом заполнении документов.
//  НовыйТипЦенДляУстановки            - тип цен, который по возможности нужно установить как новый в форме;
//  СтруктураНеобрабатываемыхТабличныхЧастей - структура, содержащая имена табличных частей, которые не надо 
//                                       обрабатывать при изменении цен/валюты;
//
Процедура ИзменитьЦеныВалюту(ДокументОбъект, СпособЗаполненияЦен, СтруктураРеквизитовДокумента, 
							   СтруктураНеРедактируемыхРеквизитов = Неопределено, ИмяТабличнойЧасти,
							   ВалютаРегламентированногоУчета,
							   СкидкаУстановлена = Ложь,
							   СтруктураЗначений = Неопределено,
							   НовыйТипЦенДляУстановки = Неопределено,
							   СтруктураНеобрабатываемыхТабличныхЧастей = Неопределено) Экспорт

	// Откроем модально форму "Цены и Налоги" и получим структуру старых и новых значений реквизитов документа
	Автозаполнение = Ложь;
	Если СтруктураЗначений = Неопределено Тогда

		СтруктураЗначений = ОткрытьФормуЦеныИВалюта(ДокументОбъект, СтруктураРеквизитовДокумента, ВалютаРегламентированногоУчета,
									  СтруктураНеРедактируемыхРеквизитов, ИмяТабличнойЧасти, НовыйТипЦенДляУстановки);

	Иначе
		Автозаполнение = Истина;

	КонецЕсли;

	// Если в форме отказались от изменений, то необходимо прекратить обработку
	Если СтруктураЗначений = Неопределено Тогда
		Возврат;
	КонецЕсли; 

	//обрабатываем изменения Товаров, Услуг, ВозворатнойТары и Оборудования
	МетаданныеДокумента = ДокументОбъект.Метаданные();
	Для каждого ТЧОбъекта Из МетаданныеДокумента.ТабличныеЧасти Цикл

		ТекущееИмяТабличнойЧасти = ТЧОбъекта.Имя;

		Если (СтруктураНеобрабатываемыхТабличныхЧастей = Неопределено
			  ИЛИ Не СтруктураНеобрабатываемыхТабличныхЧастей.Свойство(ТекущееИмяТабличнойЧасти))
			И (   ЕстьРеквизитТабЧастиДокумента("Цена",               МетаданныеДокумента, ТекущееИмяТабличнойЧасти)
			  ИЛИ ЕстьРеквизитТабЧастиДокумента("Сумма",              МетаданныеДокумента, ТекущееИмяТабличнойЧасти)
			  ИЛИ ЕстьРеквизитТабЧастиДокумента("ФактурнаяСтоимость", МетаданныеДокумента, ТекущееИмяТабличнойЧасти)
			  ИЛИ ЕстьРеквизитТабЧастиДокумента("ЦенаПоступления",    МетаданныеДокумента, ТекущееИмяТабличнойЧасти)
			  ИЛИ ЕстьРеквизитТабЧастиДокумента("СуммаПоступления",   МетаданныеДокумента, ТекущееИмяТабличнойЧасти)
			  ИЛИ ЕстьРеквизитТабЧастиДокумента("ЦенаПередачи",       МетаданныеДокумента, ТекущееИмяТабличнойЧасти)
			  ИЛИ ЕстьРеквизитТабЧастиДокумента("СуммаПередачи",      МетаданныеДокумента, ТекущееИмяТабличнойЧасти)
			  ИЛИ ЕстьРеквизитТабЧастиДокумента("ЦенаСтарая",         МетаданныеДокумента, ТекущееИмяТабличнойЧасти)
			  ИЛИ ЕстьРеквизитТабЧастиДокумента("СуммаСтарая",        МетаданныеДокумента, ТекущееИмяТабличнойЧасти)
			  ИЛИ ЕстьРеквизитТабЧастиДокумента("СуммаНДС",           МетаданныеДокумента, ТекущееИмяТабличнойЧасти)) Тогда

			ОбработатьИзмененияПоКнопкеЦеныВалюта(ДокументОбъект,
												  СпособЗаполненияЦен,
												  СтруктураРеквизитовДокумента,
												  ТекущееИмяТабличнойЧасти,
												  ВалютаРегламентированногоУчета,
												  СкидкаУстановлена,
												  СтруктураЗначений,
												  Автозаполнение);

		КонецЕсли;

	КонецЦикла;

КонецПроцедуры // ИзменитьЦеныВалюту()


////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ДЛЯ ОБРАБОТКИ XML

Функция ПрочитатьЭлементXML(ОбъектДоступаXML, ИмяЭлемента = Неопределено)
	
	ИмяПоследнегоЗакрытогоУзла = "";
	
	Пока ОбъектДоступаXML.ТипУзла <> ТипУзлаXML.НачалоЭлемента Цикл // тип узла = начало элемента
		Если НЕ ОбъектДоступаXML.Прочитать() Тогда // должен прочитаться узел
			Возврат Неопределено;
		КонецЕсли;
		Если ОбъектДоступаXML.ТипУзла = ТипУзлаXML.КонецЭлемента Тогда
			ИмяПоследнегоЗакрытогоУзла = ОбъектДоступаXML.Имя;
		КонецЕсли;
	КонецЦикла;
	
	Если ИмяЭлемента <> Неопределено Тогда // если определили имя элемента, нужно чтобы совпадало с полученным
		Если ОбъектДоступаXML.Имя <> ИмяЭлемента Тогда
			Сообщить("Неправильное имя узла (" + ИмяЭлемента + ")!"); 
			Возврат Неопределено;
		КонецЕсли;
	КонецЕсли;
	
	СоответствиеАтрибутов = Новый Соответствие();
	
	СоответствиеАтрибутов.Вставить("ИмяТекущегоУзлаXML", ОбъектДоступаXML.Имя);
	СоответствиеАтрибутов.Вставить("ИмяПоследнегоЗакрытогоУзла", ИмяПоследнегоЗакрытогоУзла);
	
	Пока ОбъектДоступаXML.ПрочитатьАтрибут() Цикл
		СоответствиеАтрибутов.Вставить(ОбъектДоступаXML.Имя, ОбъектДоступаXML.Значение);
	КонецЦикла;
	
	Возврат СоответствиеАтрибутов;

КонецФункции

Функция ДочитатьУзелДоКонца(ОбъектДоступаXML,ИмяЭлемента)
	
	Пока (ОбъектДоступаXML.ТипУзла <> ТипУзлаXML.КонецЭлемента) И (ОбъектДоступаXML.ИмяУзла = ИмяЭлемента) Цикл // тип узла = начало элемента
		Если НЕ ОбъектДоступаXML.Прочитать() Тогда // должен прочитаться узел
			Возврат Неопределено;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ДЛЯ РАБОТЫ С ПОДМЕНЮ ПЕРЕЙТИ

Функция ПолучитьXMLОписаниеПодменю()
	
	Возврат ПолучитьОбщийМакет("СоставПодменюПерейти").ПолучитьТекст();
	
КонецФункции

Функция ПолучитьДеревоПодменюПерейти(ТипОбъекта, ИмяОбъекта, ДействиеПоУмолчанию, СоответствиеДействийПодменюПерейти) Экспорт
	
	ОбъектЧтенияПодменю = Новый ЧтениеXML();
	ОбъектЧтенияПодменю.УстановитьСтроку(ПолучитьXMLОписаниеПодменю());
	
	СоответствиеАттрибутов = ПрочитатьЭлементXML(ОбъектЧтенияПодменю, "УказательПодменюПерейти");
	
	Если СоответствиеАттрибутов = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	СоответствиеАттрибутов = ПрочитатьЭлементXML(ОбъектЧтенияПодменю, "ПодменюПерейти");

	Если СоответствиеАттрибутов = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Пока ("" + СоответствиеАттрибутов["Тип"] + СоответствиеАттрибутов["Имя"]) <> (ТипОбъекта + ИмяОбъекта) Цикл
		
		ДочитатьУзелДоКонца(ОбъектЧтенияПодменю, "ПодменюПерейти");
		
		СоответствиеАттрибутов = ПрочитатьЭлементXML(ОбъектЧтенияПодменю, "ПодменюПерейти");
		
		Если СоответствиеАттрибутов = Неопределено Тогда
			Возврат Неопределено;
		КонецЕсли;
		
	КонецЦикла;
	
	ДеревоПодменю = ИнициализироватьДеревоДополнительныхКнопок();
	ТекущаяСтрокаДерева = ДеревоПодменю;
	
	СоответствиеАттрибутов = ПрочитатьЭлементXML(ОбъектЧтенияПодменю);
	
	Если СоответствиеАттрибутов = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ИмяУзла = СоответствиеАттрибутов["ИмяТекущегоУзлаXML"];
	ИмяПоследнегоЗакрытогоУзла = СоответствиеАттрибутов["ИмяПоследнегоЗакрытогоУзла"];
	
	Пока ИмяПоследнегоЗакрытогоУзла <> "ПодменюПерейти" Цикл
		
		Если ИмяПоследнегоЗакрытогоУзла = "Подменю" Тогда
			ТекущаяСтрокаДерева = ТекущаяСтрокаДерева.Родитель;
			Если ТекущаяСтрокаДерева = Неопределено Тогда
				ТекущаяСтрокаДерева= ДеревоПодменю;
			КонецЕсли;
		КонецЕсли;
			
		Если ИмяУзла = "Кнопка" Тогда
			ДобавитьСтрокуВДеревоКнопок(ТекущаяСтрокаДерева, СоответствиеАттрибутов["Имя"], ТипКнопкиКоманднойПанели.Действие, СоответствиеАттрибутов["Текст"], ДействиеПоУмолчанию, Неопределено, Ложь, СоответствиеАттрибутов["Подсказка"]);
			СоответствиеДействийПодменюПерейти.Вставить( СоответствиеАттрибутов["Имя"], СоответствиеАттрибутов["Действие"]);
			
		ИначеЕсли ИмяУзла = "Разделитель" Тогда
			ДобавитьСтрокуВДеревоКнопок(ТекущаяСтрокаДерева, СоответствиеАттрибутов["Имя"], ТипКнопкиКоманднойПанели.Разделитель, СоответствиеАттрибутов["Текст"], ДействиеПоУмолчанию, Неопределено, Ложь, СоответствиеАттрибутов["Подсказка"]);
			
		ИначеЕсли ИмяУзла = "Подменю" Тогда
			СтрокаПодменю = ДобавитьСтрокуВДеревоКнопок(ТекущаяСтрокаДерева, СоответствиеАттрибутов["Имя"], ТипКнопкиКоманднойПанели.Подменю, СоответствиеАттрибутов["Текст"], Неопределено, Неопределено, Ложь, СоответствиеАттрибутов["Подсказка"]);
			ТекущаяСтрокаДерева = СтрокаПодменю;
			
		КонецЕсли;
		
		СоответствиеАттрибутов = ПрочитатьЭлементXML(ОбъектЧтенияПодменю);
		
		Если СоответствиеАттрибутов = Неопределено Тогда
			Возврат ДеревоПодменю;
		КонецЕсли;
		
		ИмяУзла = СоответствиеАттрибутов["ИмяТекущегоУзлаXML"];
		ИмяПоследнегоЗакрытогоУзла = СоответствиеАттрибутов["ИмяПоследнегоЗакрытогоУзла"];
		
	КонецЦикла;
	
	Возврат ДеревоПодменю;

КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ДЛЯ РАБОТЫ С ДОПОЛНИТЕЛЬНЫМИ КНОПКАМИ

// Функция инициализирует дерево дополнительных кнопок
//	Параметры:
//		Нет
// Возвращаемое значение:
//		Тип: ДереваЗначений.
Функция ИнициализироватьДеревоДополнительныхКнопок() Экспорт
	
	ДеревоКнопок = Новый ДеревоЗначений;
	
	//Если ИмяКнопки = Неопределено, создается разделитель
	//Если Дерево имеет подчиненные, то 
	
	ДеревоКнопок.Колонки.Добавить("Имя");
	ДеревоКнопок.Колонки.Добавить("ТипКнопки");
	ДеревоКнопок.Колонки.Добавить("Текст");
	ДеревоКнопок.Колонки.Добавить("Подсказка");
	ДеревоКнопок.Колонки.Добавить("Картинка");
	ДеревоКнопок.Колонки.Добавить("Действие");
	ДеревоКнопок.Колонки.Добавить("Пометка");
	//Остальные свойства кнопки
	
	ДеревоКнопок.Колонки.Добавить("Расшифровка");
	
	Возврат ДеревоКнопок;
	
КонецФункции // ()

// Функция добавляет новую строку в дерево кнопок
// Параметры:
//	< СтрокаПодменю > (обязательный)
//		Тип: Дерево или элемент дерева значений, в который необходимо добавить новое описание кнопки
//	< Имя > (обязательный)
//		Тип: Строка. Имя создаваемой кнопки;
//	< ТипКнопки > (по умолчанию «Действие»)
//		Тип: ТипКнопкиКоманднойПанели. Тип создаваемой кнопки (Кнопка, разделитель, подменю);
//	< Текст > (по умолчанию пустая строка)
//		Тип: Строка. Текст кнопки.
//	< Текст > (по умолчанию пустая строка)
//		Тип: Строка. Текст кнопки.
//	< Действие > (по умолчанию «Не Определено»)
//		Тип: Действие. Действие кнопки (процедура должна быть описана в форме объекта, на который навешивается подменю).
//	< Расшифровка > (по умолчанию не определено)
//		Тип: Произвольный.
//	< Пометка > (по умолчанию «Ложь»)
//		Тип: Булево.
//	< Подсказка > (по умолчанию пустая строка)
//		Тип: Строка. Подсказка создаваемой кнопки.
//	< Картинка > (по умолчанию «Не Определено»)
//		Тип: Картинка. Картинка создаваемой кнопки.
// Возвращаемое значение:
//		Тип: СтрокаДереваЗначений.
Функция ДобавитьСтрокуВДеревоКнопок(СтрокаПодменю, Имя, Знач ТипКнопки = Неопределено ,Текст = "", Действие = Неопределено, Расшифровка = Неопределено, Пометка = Ложь, Подсказка = "", Картинка = Неопределено )
	
	Если ТипКнопки = Неопределено Тогда
	
		ТипКнопки = ТипКнопкиКоманднойПанели.Действие;
		 
	КонецЕсли; 
	
    СтрокаКнопки             = СтрокаПодменю.Строки.Добавить();
	
	СтрокаКнопки.Имя         = Имя;
	СтрокаКнопки.ТипКнопки   = ТипКнопки;
	СтрокаКнопки.Текст       = Текст;
	СтрокаКнопки.Действие    = Действие;
	СтрокаКнопки.Картинка    = Картинка;
	СтрокаКнопки.Подсказка   = Подсказка;
	СтрокаКнопки.Пометка     = Пометка;
	
	СтрокаКнопки.Расшифровка = Расшифровка;
	Возврат СтрокаКнопки;
	
КонецФункции

// Процедура формирует подменю по дереву значений
// Параметры:
//	< СтрокаПодменю > (обязательный)
//		Тип: Дерево или элемент дерева значений, по данным которого необходимо построить подменю.
//	< Подменю> (обязательный)
//		Тип: Элемент командной панели «Кнопка» типа «Подменю». На которой необходимо сформировать новое подменю.
//	< Очищать> (по умолчанию «Ложь»)
//		Тип: булево. Определяет: следует ли очищать переданное подменю.
//	< ДобавлятьРазделительВНачало > (по умолчанию «Ложь»)
//		Тип: булево. Определяет: следует ли добавить в начало подменю разделитель.
Процедура СформироватьПодменю(СтрокаПодменю, Подменю, Очищать = Ложь, ДобавлятьРазделительВНачало = Ложь) Экспорт
	
	Строки = СтрокаПодменю.Строки;
	Кнопки = Подменю.Кнопки;
	
	Если Очищать Тогда
		Кнопки.Очистить();
	
	КонецЕсли; 
	
	Если ДобавлятьРазделительВНачало и Строки.Количество() > 0 Тогда
		Кнопки.Добавить(,ТипКнопкиКоманднойПанели.Разделитель);
	
	КонецЕсли; 
	
	Для каждого СтрокаКнопки Из Строки Цикл
		
		Кнопка = Кнопки.Добавить(СтрокаКнопки.Имя,СтрокаКнопки.ТипКнопки, СтрокаКнопки.Текст, СтрокаКнопки.Действие);
		
		Если СтрокаКнопки.Строки.Количество() > 0 Тогда
			
			СформироватьПодменю(СтрокаКнопки, Подменю, Ложь, Ложь)
			
		КонецЕсли; 
		
		Если Не СтрокаКнопки.Картинка = Неопределено Тогда
			
			Кнопка.Картинка  = СтрокаКнопки.Картинка;
		
		КонецЕсли; 
		
		Кнопка.Подсказка = СтрокаКнопки.Подсказка;
		Кнопка.Пометка   = СтрокаКнопки.Пометка;
		
		//Остальные свойства кнопки
		
	КонецЦикла; 
	

КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ДЛЯ ЗАПОЛНЕНИЯ ТАБЛИЧНЫХ ЧАСТЕЙ ИЗ ВНЕШНИХ ОБРАБОТОК

// Процедура - обработчик нажатия любой из дополнительных кнопок заполнения табличных частей
// Параметры:
//    Форма       : Форма, вызвавшая процедуру
Процедура ОбработатьНажатиеНаДополнительнуюКнопкуЗаполненияТЧ(СтрокаКнопки,ЭтотОбъект) Экспорт
	
	ИмяМакета = СтрокаКнопки.Расшифровка;
	
	ИмяФайла = КаталогВременныхФайлов()+"PrnForm.tmp";
	ОбъектВнешнейФормы = ИмяМакета.ПолучитьОбъект();
	
	Если ОбъектВнешнейФормы = Неопределено Тогда
		Сообщить("Ошибка получения внешней обработки заполнения табличной части документа. Возможно обработка была удалена", СтатусСообщения.Важное);
		Возврат;
	КонецЕсли;
	
	ДвоичныеДанные = ОбъектВнешнейФормы.ХранилищеВнешнейОбработки.Получить();
	ДвоичныеДанные.Записать(ИмяФайла);
	
	Попытка
		
		Обработка = ВнешниеОбработки.Создать(ИмяФайла);
		
	Исключение
		
		Сообщить("Ошибка исполнения внешней обработки табличной части документа."+Символы.ПС+ОписаниеОшибки(), СтатусСообщения.Важное);
		Возврат;
		
	КонецПопытки;
	
	Попытка
		
		Обработка.Инициализировать(ЭтотОбъект, СтрокаКнопки.Родитель.Имя, СтрокаКнопки.Родитель.Расшифровка);
		
	Исключение
		
		СообщитьОбОшибке(ОписаниеОшибки(),, "Заполнение ТЧ не произведено!");
		
	КонецПопытки;
	
КонецПроцедуры

// Процедура формирует подменю "Заполнить" у ТЧ по дереву значений
//
Функция СформироватьПодменюЗаполненияТЧ(Ссылка, СоответствиеТЧ, Действие) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	ВнешниеОбработкиПринадлежность.Ссылка,
	|	ВнешниеОбработкиПринадлежность.Ссылка.Наименование,
	|	ВнешниеОбработкиПринадлежность.ТабличнаяЧастьИмя КАК ТабличнаяЧастьИмя
	|ИЗ
	|	Справочник.ВнешниеОбработки.Принадлежность КАК ВнешниеОбработкиПринадлежность
	|ГДЕ
	|	(НЕ ВнешниеОбработкиПринадлежность.Ссылка.ПометкаУдаления)
	|	И ВнешниеОбработкиПринадлежность.СсылкаОбъекта = &Ссылка
	|	И ВнешниеОбработкиПринадлежность.Ссылка.ВидОбработки = &ВидОбработки
	|
	|УПОРЯДОЧИТЬ ПО
	|	ТабличнаяЧастьИмя
	|ИТОГИ ПО
	|	ТабличнаяЧастьИмя";
	
	МетаданныеОбъекта = Ссылка.Метаданные();
	ДеревоКнопок = ИнициализироватьДеревоДополнительныхКнопок();
	
	Запрос.УстановитьПараметр("ВидОбработки", Перечисления.ВидыДополнительныхВнешнихОбработок.ЗаполнениеТабличныхЧастей);
	Если Метаданные.Документы.Содержит(МетаданныеОбъекта) Тогда
		Запрос.УстановитьПараметр("Ссылка", Документы[МетаданныеОбъекта.Имя].ПустаяСсылка());
	ИначеЕсли Метаданные.Справочники.Содержит(МетаданныеОбъекта) Тогда
		Запрос.УстановитьПараметр("Ссылка", Справочники[МетаданныеОбъекта.Имя].ПустаяСсылка());
	Иначе
		Возврат ДеревоКнопок;
	КонецЕсли;
	
	НомерКнопки = 0;
	
	ДеревоТЧ = Запрос.Выполнить().Выгрузить(ОбходРезультатаЗапроса.ПоГруппировкам);
	
	Для каждого КлючИЗначение Из СоответствиеТЧ Цикл
		ИмяТабличнойЧасти = КлючИЗначение.Ключ.Данные;
		СтрокаДереваТЧ = ДеревоТЧ.Строки.Найти(ИмяТабличнойЧасти,"ТабличнаяЧастьИмя");
		Если Не СтрокаДереваТЧ = Неопределено Тогда
			СтрокаПодменю = ДобавитьСтрокуВДеревоКнопок(ДеревоКнопок,ИмяТабличнойЧасти, ТипКнопкиКоманднойПанели.Действие , , , КлючИЗначение.Ключ);
			Для каждого ПодСтрокаДереваТЧ Из СтрокаДереваТЧ.Строки Цикл
				НомерКнопки = НомерКнопки + 1;
				ДобавитьСтрокуВДеревоКнопок(СтрокаПодменю, "ЗаполнениеТЧ"+НомерКнопки, ТипКнопкиКоманднойПанели.Действие, ПодСтрокаДереваТЧ.Наименование, Действие , ПодСтрокаДереваТЧ.Ссылка)
			КонецЦикла;
			ПодменюИлиКоманднаяПанель = КлючИЗначение.Значение;
			
			Если ТипЗНЧ(ПодменюИлиКоманднаяПанель) = Тип("КоманднаяПанель") Тогда
				
				ПодменюИлиКоманднаяПанель = ПодменюИлиКоманднаяПанель.Кнопки.Добавить(,ТипКнопкиКоманднойПанели.Подменю,"Заполнить");
				
			КонецЕсли;
			СформироватьПодменю(СтрокаПодменю, ПодменюИлиКоманднаяПанель,Ложь,Истина);
			
		КонецЕсли;
		 
	КонецЦикла;
	
	Возврат ДеревоКнопок;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ОБРАБОТКИ ПЕЧАТИ

// Функция заполняет начальные параметры построителю отчета, который
//  используется для настройки отбора в мезанизме подключения внешних печатных форм.
//
// Параметры
//  ИмяТаблицы     - Строка, имя таблицы БД к которой необходимо определить запрос
//  СинонимТаблицы - Строка, синоним таблицы БД к которой необходимо определить запрос
//
// Возвращаемое значение:
//   ПостроительОтчета
//
Функция ИнициализироватьПостроительДопПечатныхФорм(ИмяТаблицы, СинонимТаблицы) Экспорт

	ПостроительОтчета = Новый ПостроительОтчета;
	ПостроительОтчета.Текст = "
	|ВЫБРАТЬ ПЕРВЫЕ 1
	|	Объект.Ссылка КАК Ссылка
	|ИЗ
	|	" + ИмяТаблицы + " КАК Объект
	|ГДЕ
	|	Объект.Ссылка = &Ссылка
	|{ГДЕ
	|	Объект.Ссылка.*}
	|";
	
	ПолеОбъекта = ПостроительОтчета.ДоступныеПоля.Найти("Ссылка");
	ПолеОбъекта.Представление = ?(ЗначениеНеЗаполнено(СинонимТаблицы), ИмяТаблицы, СинонимТаблицы);
	
	Возврат ПостроительОтчета;

КонецФункции // ()

Функция ПолучитьСтрокуДереваМакетовПоУмолчанию(ИмяМетаданных,ДеревоКнопок)
	
	ИмяМакетаПоУмолчанию = ВосстановитьЗначение(ИмяМетаданных+ "МакетПечати");
	
	Если ИмяМакетаПоУмолчанию = Ложь или ДеревоКнопок.Строки.Количество() = 0 Тогда
		
		СтрокаПоУмолчанию = Неопределено;
		
	Иначе
		
		СтрокаПоУмолчанию = ДеревоКнопок.Строки.Найти(ИмяМакетаПоУмолчанию,"Текст");
		
		Если СтрокаПоУмолчанию = Неопределено Тогда
			
			СтрокаПоУмолчанию = ДеревоКнопок.Строки[0];
			
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат СтрокаПоУмолчанию;
	
КонецФункции // ()

// Процедура формирует дерево кнопок для подменю "Печать"
//
Функция ПолучитьДеревоМакетовПечати(СсылкаОбъекта, ВнутренниеПечатныеФормы, Действие = Неопределено, ДействиеУстановитьПечатьПоУмолчанию = Неопределено) Экспорт
	
	ДеревоКнопок = ИнициализироватьДеревоДополнительныхКнопок();
	
	Если Не ВнутренниеПечатныеФормы = Неопределено Тогда
		ДобавитьВДеревоМакетовВстроенныеФормы(ДеревоКнопок, ВнутренниеПечатныеФормы, Действие);
		
	КонецЕсли;
	
	ДобавитьВДеревоМакетовДополнительныеФормы(ДеревоКнопок, СсылкаОбъекта, Действие);
	
	СтрокаПоУмолчанию = ПолучитьСтрокуДереваМакетовПоУмолчанию(СсылкаОбъекта.Метаданные().Имя ,ДеревоКнопок);
	
	Если Не СтрокаПоУмолчанию = Неопределено Тогда
		
		СтрокаПоУмолчанию.Пометка = Истина;
		
	КонецЕсли;
	 
		
	Если ДеревоКнопок.Строки.Количество() > 0 Тогда
	
		ДобавитьСтрокуВДеревоКнопок(ДеревоКнопок, Строка(Новый УникальныйИдентификатор), ТипКнопкиКоманднойПанели.Разделитель);
		
		ДобавитьСтрокуВДеревоКнопок(ДеревоКнопок, "ПечатьПоУмолчанию", ТипКнопкиКоманднойПанели.Действие, "По умолчанию...", ДействиеУстановитьПечатьПоУмолчанию, "ПечатьПоУмолчанию");
	
	КонецЕсли; 
	
	
	Возврат ДеревоКнопок;
	
КонецФункции // ()

// Процедура Устанавливает кнопку "Печать по умолчанию"
//
Процедура УстановитьПечатьПоУмолчанию(ПечатьПоУмолчанию, КоманднаяПанель, ДеревоМакетов, ИмяМетаданных, ДействиеПечатьПоУмолчанию) Экспорт
	
	СтрокаПоУмолчанию = ПолучитьСтрокуДереваМакетовПоУмолчанию(ИмяМетаданных,ДеревоМакетов);
	
	
	Если Не СтрокаПоУмолчанию = Неопределено Тогда
		Если ПечатьПоУмолчанию = Неопределено Тогда
			
			ИмяКнопки = Строка (Новый УникальныйИдентификатор);
			
			Если КоманднаяПанель.ВыравниваниеКнопок = ВыравниваниеКнопокКоманднойПанели.Право Тогда
				КоманднаяПанель.Кнопки.Вставить(0,,ТипКнопкиКоманднойПанели.Разделитель);
				ПечатьПоУмолчанию = КоманднаяПанель.Кнопки.Вставить(0,ИмяКнопки,ТипКнопкиКоманднойПанели.Действие,"",ДействиеПечатьПоУмолчанию);
			Иначе
				КоманднаяПанель.Кнопки.Добавить(,ТипКнопкиКоманднойПанели.Разделитель);
				ПечатьПоУмолчанию = КоманднаяПанель.Кнопки.Добавить(ИмяКнопки,ТипКнопкиКоманднойПанели.Действие,"",ДействиеПечатьПоУмолчанию);
			КонецЕсли;
			
			ПечатьПоУмолчанию.Подсказка = "Печать по умолчанию";
			
		КонецЕсли; 
		
		ПечатьПоУмолчанию.Текст       = СтрокаПоУмолчанию.Текст;
		ПечатьПоУмолчанию.Доступность = Истина; 
		
	ИначеЕсли Не ПечатьПоУмолчанию = Неопределено Тогда
		
		ПечатьПоУмолчанию.Текст       = "Печать по умолчанию не назначена"; 
		ПечатьПоУмолчанию.Доступность = Ложь; 
		
	КонецЕсли; 
	
КонецПроцедуры

// Процедура устанавливает Подменю "Печать" 
// Параметры:
//    Форма       : Форма, вызвавшая процедуру
//    ДополнительныеКнопки : Структура дополнительных кнопок
Процедура УстановитьПодменюПечати(ПодменюПечати, КоманднаяПанель, СоздаватьПриНеобходимости) Экспорт
	
	Если Не ПодменюПечати = Неопределено или  Не СоздаватьПриНеобходимости Тогда
		Возврат;
	КонецЕсли; 
	
	ИмяПодменю = Строка (Новый УникальныйИдентификатор);
	Если КоманднаяПанель.ВыравниваниеКнопок = ВыравниваниеКнопокКоманднойПанели.Право Тогда
		КоманднаяПанель.Кнопки.Вставить(0,,ТипКнопкиКоманднойПанели.Разделитель);
		ПодменюПечати = КоманднаяПанель.Кнопки.Вставить(0,ИмяПодменю,ТипКнопкиКоманднойПанели.Подменю,"Печать");
	Иначе
		КоманднаяПанель.Кнопки.Добавить(,ТипКнопкиКоманднойПанели.Разделитель);
		ПодменюПечати = КоманднаяПанель.Кнопки.Добавить(ИмяПодменю,ТипКнопкиКоманднойПанели.Подменю,"Печать");
	КонецЕсли;
	ПодменюПечати.Подсказка = "Меню выбора печатных форм";
			
	
КонецПроцедуры

// Процедура - обработчик нажатия любой из дополнительных кнопок печати
// Параметры:
//    Форма       : Форма, вызвавшая процедуру
//Процедура ПечатьПоДополнительнойКнопке(Форма,ДополнительнаяКнопка) 
Процедура ПечатьПоДополнительнойКнопке(ДеревоМакетов, Объект, Форма, ТекстКнопки,ЗаписыватьПередПечатью=Истина) Экспорт
	
	Если ЗаписыватьПередПечатью Тогда
		
		Если Не ПроверитьМодифицированностьВФорме(Объект,Форма,"Объект изменен. Для печати его необходимо записать ") Тогда
			Возврат;
			//ИначеЕсли Не РазрешитьПечатьНепроведенныхДокументов(Объект.Проведен) Тогда
			//	Предупреждение("Недостаточно полномочий для печати непроведенного документа!");
			//	Возврат;
		КонецЕсли;
		
	КонецЕсли; 
	
	СтрокаКнопки = ДеревоМакетов.Строки.Найти(ТекстКнопки,"Текст");
	
	Если СтрокаКнопки = Неопределено Тогда
		
		Предупреждение("Печать не доступна. Изменился набор реквизитов!");
		Возврат;
		
	КонецЕсли;
	
	НаПринтер = ПолучитьЗначениеПоУмолчанию(ПараметрыСеанса.ТекущийПользователь, "ПечатьДокументовБезПредварительногоПросмотра") = Истина;
	
	Если ТипЗнч(СтрокаКнопки.Расшифровка) = Тип("ДвоичныеДанные") Тогда
		
		ТабДокумент = НапечататьВнешнююФорму(Объект.Ссылка, СтрокаКнопки.Расшифровка);
		НапечататьДокумент(ТабДокумент, 0, НаПринтер, СформироватьЗаголовокДокумента(Объект));
		
	Иначе
		
		Объект.Печать(СтрокаКнопки.Имя, 0, НаПринтер);
		
	КонецЕсли; 
	
КонецПроцедуры

// Процедура назначает макет по умолчанию
//
Функция НазначитьКнопкуПечатиПоУмолчанию(ДеревоМакетов, ИмяМетаданных) Экспорт
	
	СтрокаПоУмолчанию = ПолучитьСтрокуДереваМакетовПоУмолчанию(ИмяМетаданных,ДеревоМакетов);
	
	СписокМакетов = Новый СписокЗначений;
	
	Для каждого Строка Из ДеревоМакетов.Строки Цикл
	
		Если Строка.ТипКнопки = ТипКнопкиКоманднойПанели.Действие и Не Строка.Расшифровка = "ПечатьПоУмолчанию" Тогда
			
			СписокМакетов.Добавить(Строка.Текст,,СтрокаПоУмолчанию = Строка);
			
		КонецЕсли; 
		
	
	КонецЦикла; 
	
	ФормаВыбораПечатнойФормыПоУмолчанию = ПолучитьОбщуюФорму("ФормаВыбораПечатнойФормыПоУмолчанию");
	ФормаВыбораПечатнойФормыПоУмолчанию.СписокВыбораПечатнойФормы = СписокМакетов;
	
	МакетПоУмолчанию = ФормаВыбораПечатнойФормыПоУмолчанию.ОткрытьМодально();
	
	Если МакетПоУмолчанию = "" Тогда
		СохранитьЗначение(ИмяМетаданных + "МакетПечати", Ложь);
		
	ИначеЕсли Не МакетПоУмолчанию = Неопределено Тогда
		СохранитьЗначение(ИмяМетаданных + "МакетПечати", МакетПоУмолчанию);
	Иначе
		Возврат Ложь;
	КонецЕсли; 
	
	Возврат Истина;
	
КонецФункции

// Функция получает ТабличныйДокумент для печати из внешней печатной формы.
//
// Параметры
//  Ссылка         - Ссылка, для которой необходимо напечатать документ
//  ДвоичныеДанные - ДвоичныеДанные, внешняя обработка для печати
//
// Возвращаемое значение:
//   ТабличныйДокумент
//
Функция НапечататьВнешнююФорму(Ссылка, ДвоичныеДанные) Экспорт

	ТабДокумент = Неопределено;
	
	ИмяФайла = ПолучитьИмяВременногоФайла("epf");
	Попытка
		ДвоичныеДанные.Записать(ИмяФайла);
		Обработка = ВнешниеОбработки.Создать(ИмяФайла);
		Обработка.СсылкаНаОбъект = Ссылка;
		ТабДокумент = Обработка.Печать();
		УдалитьФайлы(ИмяФайла);
	Исключение
		СообщитьОбОшибке(ОписаниеОшибки(),, "Не удалось сформировать внешнюю печатную форму!");
	КонецПопытки;
	
	Возврат ТабДокумент;

КонецФункции

// Процедура дополняет таблицу печатных форма (ТаблицаМакетов) объекта
// из справочника "Дополнительные печатные формы"
Процедура ДобавитьВДеревоМакетовДополнительныеФормы(ДеревоМакетов, СсылкаОбъекта, Действие)
	СтрокиДерева = ДеревоМакетов.Строки;
	Если ТипЗнч(СсылкаОбъекта) = Тип("ОбъектМетаданных") Тогда
		Возврат;
	КонецЕсли; 
	
	МетаданныеОбъекта = СсылкаОбъекта.Метаданные();
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	ВнешниеОбработкиПринадлежность.Ссылка КАК Ссылка,
	|	ВнешниеОбработкиПринадлежность.Ссылка.Наименование КАК Наименование,
	|	ВнешниеОбработкиПринадлежность.Ссылка.ХранилищеВнешнейОбработки КАК СсылкаХранилищеВнешнейОбработки,
	|	ВнешниеОбработкиПринадлежность.НастройкиПостроителяДляОтбора КАК НастройкиПостроителяДляОтбора,
	|	ВнешниеОбработкиПринадлежность.ХранилищеВнешнейОбработки КАК ХранилищеВнешнейОбработки,
	|	ВнешниеОбработкиПринадлежность.ЗаменяемаяПечатнаяФорма КАК ЗаменяемаяПечатнаяФорма,
	|	ВнешниеОбработкиПринадлежность.НомерСтроки
	|ИЗ
	|	Справочник.ВнешниеОбработки.Принадлежность КАК ВнешниеОбработкиПринадлежность
	|ГДЕ
	|	(НЕ ВнешниеОбработкиПринадлежность.Ссылка.ПометкаУдаления)
	|	И ВнешниеОбработкиПринадлежность.СсылкаОбъекта = &Ссылка
	|	И ВнешниеОбработкиПринадлежность.Ссылка.ВидОбработки = &ВидОбработки
	|ИТОГИ ПО
	|	Ссылка";
	
	ИмяТаблицыОбъекта = "";
	Запрос.УстановитьПараметр("ВидОбработки", Перечисления.ВидыДополнительныхВнешнихОбработок.ПечатнаяФорма);
	Если Метаданные.Документы.Содержит(МетаданныеОбъекта) Тогда
		Запрос.УстановитьПараметр("Ссылка", Документы[МетаданныеОбъекта.Имя].ПустаяСсылка());
		ИмяТаблицыОбъекта = "Документ." + МетаданныеОбъекта.Имя;
	ИначеЕсли Метаданные.Справочники.Содержит(МетаданныеОбъекта) Тогда
		Запрос.УстановитьПараметр("Ссылка", Справочники[МетаданныеОбъекта.Имя].ПустаяСсылка());
		ИмяТаблицыОбъекта = "Справочник." + МетаданныеОбъекта.Имя;
	Иначе
		Возврат;
	КонецЕсли;
	
	БылРазделитель = СтрокиДерева.Количество() = 0 ;
	ВыборкаСсылок = Запрос.Выполнить().Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);
	Пока ВыборкаСсылок.Следующий() Цикл
		ПорядковыйНомер = 0;
		Выборка = ВыборкаСсылок.Выбрать();
		Пока Выборка.Следующий() Цикл
			
			НоваяОбработка = Неопределено;
			ОбработкаСтроки = Выборка.ХранилищеВнешнейОбработки.Получить();
			Если ТипЗнч(ОбработкаСтроки) = Тип("ДвоичныеДанные") Тогда
				НоваяОбработка = ОбработкаСтроки;
			Иначе
				ОбработкаЭлемента = Выборка.СсылкаХранилищеВнешнейОбработки.Получить();
				Если ТипЗнч(ОбработкаЭлемента) = Тип("ДвоичныеДанные") Тогда
					НоваяОбработка = ОбработкаЭлемента;
				КонецЕсли; 
			КонецЕсли; 
			
			Если НоваяОбработка = Неопределено Тогда
				Продолжить;
			КонецЕсли; 
			
			
			// Проверим, удовлетворяет ли подключаемый отчет указанным в нем условиям
			НастройкиПостроителя = Выборка.НастройкиПостроителяДляОтбора.Получить();
			Если ТипЗнч(НастройкиПостроителя) = Тип("НастройкиПостроителяОтчета") Тогда
				ПостроительОтчета = ИнициализироватьПостроительДопПечатныхФорм(ИмяТаблицыОбъекта, МетаданныеОбъекта.Синоним);
				ПостроительОтчета.Параметры.Вставить("Ссылка", СсылкаОбъекта);
				ПостроительОтчета.УстановитьНастройки(НастройкиПостроителя, Истина, Ложь, Ложь, Ложь, Ложь);
				ПостроительОтчета.Выполнить();
				Если ПостроительОтчета.Результат.Пустой() Тогда
					Продолжить;
				КонецЕсли;
				Подсказка = "Отбор";
			Иначе
				Подсказка = "";
			КонецЕсли;
			
			
			// Теперь проверим, надо ли заменять существующую печ.форму или нужно добавить новую
			Если НЕ ЗначениеНеЗаполнено(Выборка.ЗаменяемаяПечатнаяФорма) Тогда
				СтрокаДерева = СтрокиДерева.Найти(Выборка.ЗаменяемаяПечатнаяФорма, "Имя");
				Если СтрокаДерева <> Неопределено И ТипЗнч(СтрокаДерева.Расшифровка) <> Тип("ДвоичныеДанные") Тогда
					СтрокаДерева.Расшифровка = НоваяОбработка;
					СтрокаДерева.Подсказка = Подсказка;
					Продолжить;
				КонецЕсли; 
			КонецЕсли; 
			
			// Только тут будем добавлять новую печ. форму в дополнение списка
			Если Не БылРазделитель Тогда
				ДобавитьСтрокуВДеревоКнопок(ДеревоМакетов, Строка(Новый УникальныйИдентификатор), ТипКнопкиКоманднойПанели.Разделитель);
				БылРазделитель = Истина;
			КонецЕсли;
			
			Суффикс = ?(ПорядковыйНомер = 0 ,"" , "("+ПорядковыйНомер+")");
			ДобавитьСтрокуВДеревоКнопок(ДеревоМакетов, Строка(Новый УникальныйИдентификатор), ТипКнопкиКоманднойПанели.Действие, Выборка.Наименование + Суффикс, Действие ,НоваяОбработка,);
			
		КонецЦикла;
	
	КонецЦикла; 
	
	
КонецПроцедуры

// Процедура добавляет в дерево кнопок макетов встроенные печатные формы
//
Процедура ДобавитьВДеревоМакетовВстроенныеФормы(ДеревоКнопок, ВнутренниеПечатныеФормы, Действие)

	Для каждого КлючИЗначение Из ВнутренниеПечатныеФормы Цикл
		Если КлючИЗначение.Значение = Неопределено Тогда
			
			ДобавитьСтрокуВДеревоКнопок(ДеревоКнопок, , ТипКнопкиКоманднойПанели.Разделитель);
			
		Иначе
			
			ДобавитьСтрокуВДеревоКнопок(ДеревоКнопок, КлючИЗначение.Ключ, ТипКнопкиКоманднойПанели.Действие, КлючИЗначение.Значение, Действие);
			
		КонецЕсли; 
		
	КонецЦикла;

КонецПроцедуры

Функция НапечататьДокументПоУмолчанию(Объект, КоличествоЭкземпляров = 1, НаПринтер = Ложь, НепосредственнаяПечать = Ложь) Экспорт
	
	Попытка
		
		СтруктураВнутреннихПечатныхФорм = Объект.ПолучитьСтруктуруПечатныхФорм()
		
	Исключение
		
		СтруктураВнутреннихПечатныхФорм = Новый Структура;
		
	КонецПопытки;
	
	ДеревоМакетов = ПолучитьДеревоМакетовПечати(Объект, СтруктураВнутреннихПечатныхФорм);
	
	СтрокаПоУмолчанию = ПолучитьСтрокуДереваМакетовПоУмолчанию(Объект.Метаданные().Имя, ДеревоМакетов);
	
	Если СтрокаПоУмолчанию = Неопределено Тогда
		
		Сообщить(Строка(Объект) + ": Печать по умолчанию не определена!", СтатусСообщения.Важное); 
		Возврат Ложь;
		
	КонецЕсли; 
	
	Если ТипЗнч(СтрокаПоУмолчанию.Расшифровка) = Тип("ДвоичныеДанные") Тогда
		
		ТабДокумент = НапечататьВнешнююФорму(Объект.Ссылка, СтрокаПоУмолчанию.Расшифровка);
		НапечататьДокумент(ТабДокумент, КоличествоЭкземпляров, НаПринтер, СформироватьЗаголовокДокумента(Объект.Ссылка), НепосредственнаяПечать);
		
	Иначе
		
		Объект.Печать(СтрокаПоУмолчанию.Имя, КоличествоЭкземпляров, НаПринтер, НепосредственнаяПечать);
		
	КонецЕсли; 
	
	Возврат Истина;
	
КонецФункции // ()

// Печатает документ полученный по нажатию кнопки в форме списка
//
// Параметры
//  Документ - документ,который нужно отпечатать
//
Процедура НапечататьДокументИзФормыСписка(Ссылка) Экспорт
	
	Если Ссылка = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	НаПринтер = ПолучитьЗначениеПоУмолчанию(ПараметрыСеанса.ТекущийПользователь, "ПечатьДокументовБезПредварительногоПросмотра") = Истина;
	Если Не НапечататьДокументПоУмолчанию(Ссылка.ПолучитьОбъект(), 0, НаПринтер) Тогда
		
		Предупреждение("Операция не выполнена");
		
	КонецЕсли;
	
КонецПроцедуры // НапечататьДокументИзФормыСписка()

// Печатает движения документа
//
// Параметры:
//  ДокументСсылка - ссылка на документ, движения которого печатаем
//
Процедура НапечататьДвиженияДокумента(ДокументСсылка) Экспорт

	// Получим контекст отчета
	ПечатьДвиженийДокумента = Отчеты.ДвиженияДокумента.Создать();

	//Установим реквизиты и переменые отчета
	ПечатьДвиженийДокумента.Документ = ДокументСсылка;
	
	// Напечатаем движения
	ПечатьДвиженийДокумента.СформироватьИВывестиОтчет();

КонецПроцедуры // НапечататьДвиженияДокумента()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ИСТОРИЕЙ ВВОДА ЗНАЧЕНИЙ

// Процедура по для переданной строке пути и строковому представлению //
//
// Параметры
//  Название - Строка .для которой определяется необходимость дополнения 
// сокращением
//  Уровень - уровень, для которго необходимо составить список сокращений
//
Процедура ДополнитьСписокИсторииВвода(Путь, Знач Значение) Экспорт

	Если ЗначениеНеЗаполнено(Значение) Тогда
		Возврат;
	КонецЕсли;

	СтрокаИстории = ВосстановитьЗначение(Путь);

	Если СтрокаИстории = Неопределено Тогда
		СписокИстории = Новый СписокЗначений();
	Иначе
		СписокИстории = ЗначениеИзСтрокиВнутр(СтрокаИстории);
	КонецЕсли;

	Если ТипЗнч(СписокИстории) <> Тип("СписокЗначений") Тогда
		СписокИстории = Новый СписокЗначений();
	КонецЕсли;

	Если ТипЗнч(Значение) <> Тип("Строка") Тогда
		Значение = ЗначениеВСтрокуВнутр(Значение);
	КонецЕсли;

	Если СписокИстории.НайтиПоЗначению(Значение) <> Неопределено Тогда
		 СписокИстории.Удалить(СписокИстории.НайтиПоЗначению(Значение));
	КонецЕсли;

	СписокИстории.Вставить(0, Значение, Значение);

	Пока СписокИстории.Количество() > 5 Цикл
		СписокИстории.Удалить(СписокИстории.Получить(СписокИстории.Количество() - 1));
	КонецЦикла;

	СохранитьЗначение(Путь, ЗначениеВСтрокуВнутр(СписокИстории));

КонецПроцедуры // ДополнитьСписокИсторииВвода()

// Функция по для переданной строке пути возвращает список заполненных значений
//
// Параметры
//  Путь - Строка .с указанием объекта метаданных и поля ввода 
// сокращением
//
// Возвращаемые значения
//  Возвращается список значений с историей ввода в это поле
//
Функция ПолучитьСписокИсторииВвода(Путь) Экспорт

	СтрокаИстории = ВосстановитьЗначение(Путь);

	Если СтрокаИстории = Неопределено Тогда
		Возврат Новый СписокЗначений();
	КонецЕсли;

	СписокИстории = ЗначениеИзСтрокиВнутр(СтрокаИстории);

	Если ТипЗнч(СписокИстории) = Тип("СписокЗначений") Тогда
		Для каждого ЭлементСписка из СписокИстории Цикл
			Если ТипЗнч(ЭлементСписка.Значение) <> Тип("Строка") Тогда
				СписокИстории.Удалить(ЭлементСписка);
			КонецЕсли;
		КонецЦикла;

		Для каждого ЭлементСписка из СписокИстории Цикл
			Если ТипЗнч(ЗначениеИзСтрокиВнутр(ЭлементСписка.Значение)) <> Тип("Строка") Тогда
				ЭлементСписка.Значение = ЗначениеИзСтрокиВнутр(ЭлементСписка.Значение);
				ЭлементСписка.Представление = Строка(ЭлементСписка.Значение);
			КонецЕсли;
		КонецЦикла;

		Возврат СписокИстории;

	Иначе
		Возврат Новый СписокЗначений();

	КонецЕсли;

КонецФункции // ПолучитьСписокИсторииВвода()

////////////////////////////////////////////////////////////////////////////////
// ПРОЧИЕ ПРОЦЕДУРЫ И ФУНКЦИИ

Процедура УстановитьДоступностьЯчееекПоСчету(Счет, Субконто1, Субконто2, Субконто3) Экспорт
	
	ЭлементыСубконто = Новый Структура("Субконто1,Субконто2,Субконто3", Субконто1, Субконто2, Субконто3);
	ЧислоАктивныхСубконто = Счет.ВидыСубконто.Количество();
	ЧислоАктивныхСубконто=Мин(ЧислоАктивныхСубконто,3);
	
	Для Сч = 1 По ЧислоАктивныхСубконто Цикл
		ЭлементыСубконто["Субконто" + Сч].Доступность = (Сч <= ЧислоАктивныхСубконто);
	КонецЦикла;
	
КонецПроцедуры

// Процедура открывает форму для отправки сообщения по электронной почте на линию
// технической поддержки пользователей
// 
// Параметры:
//  НЕТ
//
Процедура ОтправитьСообщениеВОтделТехническойПоддержки() Экспорт

	ОбработкаОтправки = Обработки.ОтправкаЭлектронногоСообщенияВОтделТехническойПоддержки.Создать();
	
	ОбработкаОтправки.ТекстСообщения = ПолучитьТекстСообщенияВОтделТехническойПоддержки();
	ОбработкаОтправки.ТемаСообщения  = "Сообщение в отдел технической поддержки";
	
	ОбработкаОтправки.ПолучитьФорму().Открыть();

КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ФОРМИРОВАНИЯ И ОБРАБОТКИ МЕНЮ

// Проверяет модифицированность документа перед печатью, и если необходимо 
// записывает его
// 
// Параметры
//  Документ - (ДокументОбъект.*) - проверяемый документ
//
Функция ПроверитьМодифицированность(Документ) Экспорт

	Результат = Ложь;

	Если Документ.Модифицированность() Тогда

		Проведен = ?(Документ.Проведен, " и провести","");

		Ответ = Вопрос("Документ изменен. Для печати его необходимо записать"+ Проведен +".
		               |Записать" + Проведен + "?",
		               РежимДиалогаВопрос.ОКОтмена, , 
		               КодВозвратаДиалога.Отмена,
		               "Документ изменен");

		Если Ответ = КодВозвратаДиалога.ОК Тогда

			Если Документ.Проведен Тогда

				ДатаДока = НачалоДня(Документ.Дата);
				ДатаДня  = НачалоДня(ТекущаяДата());

				Попытка
					
					Если ДатаДока = ДатаДня и Документ.Метаданные().ОперативноеПроведение = Метаданные.СвойстваОбъектов.ОперативноеПроведение.Разрешить Тогда
						Документ.Записать(РежимЗаписиДокумента.Проведение, РежимПроведенияДокумента.Оперативный);
					Иначе
						Документ.Записать(РежимЗаписиДокумента.Проведение, РежимПроведенияДокумента.Неоперативный);
					КонецЕсли;

				Исключение

					Предупреждение("Операция не выполнена!");
					Возврат Результат = Истина;

				КонецПопытки;

			Иначе
				Документ.Записать();
			КонецЕсли;

			Результат = Истина;

		КонецЕсли;

	Иначе
		Результат = Истина;
	КонецЕсли;

	Возврат Результат;

КонецФункции // ПроверитьМодифицированность()

// Проверяет модифицированность документа / справочника перед печатью, и если необходимо 
// записывает его
// 
// Параметры
//  Объект - (ДокументОбъект.*, СправочникОбъект.*) - проверяемый документ / справочник
//  Форма    - форма проверяемого документа / справочника
//
Функция ПроверитьМодифицированностьВФорме(Объект, Форма,ОсновнойТекстВопроса) Экспорт

	Результат = Ложь;
   // ,Объект изменен. Для печати его необходимо записать "
	Если Форма.Модифицированность Тогда

		Проведен    = Метаданные.Документы.Содержит(Объект.Метаданные()) И Объект.Проведен;
		СтрПроведен = ?(Проведен, " и провести","");
		
		Ответ = Вопрос(ОсновнойТекстВопроса+ СтрПроведен +".
		               |Записать" + СтрПроведен + "?",
		               РежимДиалогаВопрос.ОКОтмена, , 
		               КодВозвратаДиалога.Отмена,
		               "Объект изменен");

		Если Ответ = КодВозвратаДиалога.ОК Тогда
			
			Попытка
				Если Проведен Тогда
					Результат  = Форма.ЗаписатьВФорме(РежимЗаписиДокумента.Проведение);
				Иначе
					Результат = Форма.ЗаписатьВФорме();
				КонецЕсли;
			Исключение
				СообщитьОбОшибке(ОписаниеОшибки());
			КонецПопытки;
			
		КонецЕсли;

	Иначе
		Результат = Истина;
	КонецЕсли;

	Возврат Результат;

КонецФункции // ПроверитьМодифицированность()

// Функция формирует представление суммы прописью в указанной валюте
//
// Возвращаемое значение:
//  Строка - сумма прописью
//
Функция СформироватьСуммуПрописью(Сумма, Валюта) Экспорт

	Если Валюта.Наименование="USD" Тогда
		ФормСтрока = "Л = ru_RU; ДП = Ложь";
		ПарПредмета="доллар США,доллара США,долларов США,м,цент,цента,центов,м,2";
		Возврат ЧислоПрописью(Сумма, ФормСтрока, ПарПредмета);	
	ИначеЕсли Валюта.ПараметрыПрописиНаРусском = "" Тогда
		Возврат ФорматСумм(Сумма);
	Иначе
		Возврат ЧислоПрописью(Сумма,"ДП = Ложь",Валюта.ПараметрыПрописиНаРусском);
	КонецЕсли;

КонецФункции // СформироватьСуммуПрописью()

// Функция спрашивает пользователя записать ли объект, или нет, если он новый
//
// Параметры
//  ФормаОбъекта - Форма объекта, из которой пытаются произвести действия
//
// Возвращаемое значение:
//   Булево - Объект записан или нет
//
Функция ЗаписатьНовыйОбъектВФорме(ФормаОбъекта) Экспорт

	Если ФормаОбъекта.ЭтоНовый() Тогда
		Если Документы.ТипВсеСсылки().СодержитТип(ТипЗнч(ФормаОбъекта.ЭтотОбъект.Ссылка)) Тогда
			ТекстВопроса = "Для выполнения данной операции необходимо записать документ. Записать?";
		Иначе // Справочник
			ТекстВопроса = "Для выполнения данной операции необходимо записать элемент. Записать?";
		КонецЕсли; 
		Ответ = Вопрос(ТекстВопроса, РежимДиалогаВопрос.ДаНет);
		Если Ответ <> КодВозвратаДиалога.Да Тогда
			Возврат Ложь;
		Иначе
			Попытка
				Возврат ФормаОбъекта.ЗаписатьВФорме();
			Исключение
				Сообщить(ОписаниеОшибки());
				Возврат Ложь;
			КонецПопытки;
		КонецЕсли;
	Иначе
		Возврат Истина;
	КонецЕсли; 

КонецФункции // ЗаписатьНовыйОбъектВФорме()

// Процедура возвращает паспортные данные физлица в виде строки
//
// Параметры: 
//  Валюта                         - Валюта, курс которой необходимо отобразить
//  Курс                           - курс, которой необходимо отобразить
//  Кратность                      - кратность, которую необходимо отобразить
//  ВалютаРегламентированногоУчета - валюта регламентированного учета
//  СформироватьСкобки             - признак необходимости скобок
//
// Возвращаемое значение:
//  Строка с данными о курсе и кратности валюты
//
Функция ПолучитьИнформациюКурсаВалютыСтрокой(Валюта, Курс, Кратность, ВалютаРегламентированногоУчета, СформироватьСкобки = Ложь) Экспорт

	Если ЗначениеНеЗаполнено(Валюта) Тогда
		Возврат "";

	Иначе
		Возврат ?(СформироватьСкобки, "   ( ", "") + Кратность + " "
		      + СокрЛП(Валюта)
		      + " = "
		      + Курс + " " 
		      + СокрЛП(ВалютаРегламентированногоУчета)
		      + ?(СформироватьСкобки, " )", "");
	КонецЕсли;

КонецФункции // ПолучитьИнформациюКурсаВалютыСтрокой()

// Процедура - обработчик события ПриИзменении поля ввода Организация
//
// Параметры:
//  ДокументОбъект - объект документ в форме которого произошло событие.
//  ТекПользователь - текущий пользователь, настройки которого используются
//                 по умолчанию.
//
Процедура ПриИзмененииЗначенияОрганизации(ДокументОбъект, ТекПользователь) Экспорт

	МетаданныеДокумента = ДокументОбъект.Метаданные();
	Если ЕстьРеквизитДокумента("Организация", МетаданныеДокумента) Тогда

		Если ЕстьРеквизитДокумента("ПодразделениеОрганизации", МетаданныеДокумента)
		   И НЕ ЗначениеНеЗаполнено(ДокументОбъект.Организация) Тогда
		   
			ПодразделениеПоУмолчанию = ПолучитьЗначениеПоУмолчанию(ТекПользователь, "ОсновноеПодразделениеОрганизации");
			
			// Если ПодразделениеОрганизации не заполнено.
			Если ЗначениеНеЗаполнено(ДокументОбъект.ПодразделениеОрганизации) Тогда
				
				// Если ПодразделениеПоУмолчанию сооответствует выбранной организации, подставляем его.
				Если ПодразделениеПоУмолчанию.Владелец = ДокументОбъект.Организация Тогда
					ДокументОбъект.ПодразделениеОрганизации = ПодразделениеПоУмолчанию;
				КонецЕсли;
			
			Иначе // Если ПодразделениеОрганизации заполнено.
				
				// Если ПодразделениеОрганизации не соответствует выбранной организации.
				Если НЕ ДокументОбъект.ПодразделениеОрганизации.Владелец = ДокументОбъект.Организация Тогда
					
					// Если ПодразделениеПоУмолчанию сооответствует выбранной организации, подставляем его.
					Если ПодразделениеПоУмолчанию.Владелец = ДокументОбъект.Организация Тогда
						ДокументОбъект.ПодразделениеОрганизации = ПодразделениеПоУмолчанию;
					Иначе // Выбрана не основная организация. ПодразделениеОрганизации нужно очистить.
						ДокументОбъект.ПодразделениеОрганизации = Справочники.ПодразделенияОрганизаций.ПустаяСсылка();
						СообщитьОбОшибке("Значение в поле ""Подразделение"" не соответствует выбранной организации и было очищено.");
					КонецЕсли;
					
				КонецЕсли;

			КонецЕсли;
			
		КонецЕсли;

		Если ЕстьРеквизитДокумента("ДоговорКонтрагента", МетаданныеДокумента)
		   И НЕ ЗначениеНеЗаполнено(ДокументОбъект.Организация)
		   И НЕ ЗначениеНеЗаполнено(ДокументОбъект.ДоговорКонтрагента)
		   И НЕ ДокументОбъект.ДоговорКонтрагента.Организация = ДокументОбъект.Организация Тогда

			ДокументОбъект.ДоговорКонтрагента = Неопределено;

		КонецЕсли;

	КонецЕсли;

КонецПроцедуры // ПриИзмененииЗначенияОрганизации()

// Процедура проверяет принадлежность реквизита типа ПодразделениеОрганизации
// выбранной организации.
//
// Параметры:
//  ДокументОбъект - объект документ, в форме которого произошло событие
//  ТекПользователь - текущий пользователь, настройки которого используются
//                 по умолчанию
//  НазваниеРеквизитаСубконто - название проверяемого реквизита
//  Субконто     - значение проверяемого реквизита
//
Процедура ПроверитьСубконтоПодразделение(ДокументОбъект, ТекПользователь, Организация, НазваниеРеквизитаСубконто, Субконто)
	
	Если ТипЗнч(Субконто) = Тип("СправочникСсылка.ПодразделенияОрганизаций") Тогда
		
		ПодразделениеПоУмолчанию = ПолучитьЗначениеПоУмолчанию(ТекПользователь, "ОсновноеПодразделениеОрганизации");
		
		// Если субконто не заполнено.
		Если ЗначениеНеЗаполнено(Субконто) Тогда
			
			// Если субконто сооответствует выбранной организации, подставляем его.
			Если ПодразделениеПоУмолчанию.Владелец = Организация Тогда
				ДокументОбъект[НазваниеРеквизитаСубконто] = ПодразделениеПоУмолчанию;
			КонецЕсли;
			
		Иначе // Если ПодразделениеОрганизации заполнено.
			
			// Если ПодразделениеОрганизации не соответствует выбранной организации.
			Если НЕ Субконто.Владелец = Организация Тогда
				
				// Если ПодразделениеПоУмолчанию сооответствует выбранной организации, подставляем его.
				Если ПодразделениеПоУмолчанию.Владелец = Организация Тогда
					ДокументОбъект[НазваниеРеквизитаСубконто] = ПодразделениеПоУмолчанию;
				Иначе // Выбрана не основная организация. ПодразделениеОрганизации нужно очистить.
					ДокументОбъект[НазваниеРеквизитаСубконто] = Справочники.ПодразделенияОрганизаций.ПустаяСсылка();
					СообщитьОбОшибке("Значение в поле ""Подразделение"" не соответствует выбранной организации и было очищено.");
				КонецЕсли;
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры   // ПроверитьСубконтоПодразделение()
 
// Процедура - обработчик события ПриИзменении поля ввода Организация
//
// Параметры:
//	ДокументОбъект - объект документ в форме которого произошло событие
//  ТекПользователь - текущий пользователь, настройки которого используются
//                 по умолчанию
//  СтруктураРеквизитов - структура с названиеями и значениями реквизитов, 
//                 кот.необходимо проверить
//
 Процедура ПроверитьВладельцаСубконтоПодразделение(ДокументОбъект, ТекПользователь, Организация, СтруктураРеквизитов) Экспорт

	Если СтруктураРеквизитов.Свойство("НазваниеСубконтоБУ1") И СтруктураРеквизитов.Свойство("СубконтоБУ1") Тогда
		ПроверитьСубконтоПодразделение(ДокументОбъект, ТекПользователь, Организация, СтруктураРеквизитов.НазваниеСубконтоБУ1, СтруктураРеквизитов.СубконтоБУ1);
	КонецЕсли;
	
	Если СтруктураРеквизитов.Свойство("НазваниеСубконтоБУ2") И СтруктураРеквизитов.Свойство("СубконтоБУ2") Тогда
		ПроверитьСубконтоПодразделение(ДокументОбъект, ТекПользователь, Организация, СтруктураРеквизитов.НазваниеСубконтоБУ2, СтруктураРеквизитов.СубконтоБУ2);
	КонецЕсли;
	
	Если СтруктураРеквизитов.Свойство("НазваниеСубконтоБУ3") И СтруктураРеквизитов.Свойство("СубконтоБУ3") Тогда
		ПроверитьСубконтоПодразделение(ДокументОбъект, ТекПользователь, Организация, СтруктураРеквизитов.НазваниеСубконтоБУ3, СтруктураРеквизитов.СубконтоБУ3);
	КонецЕсли;
	 
	 
 КонецПроцедуры  // ПроверитьВладельцаПодразделения()

Процедура УстановитьСписокПоляВыбора(ПолеВыбора, Список) Экспорт

	ПрошлоеЗначение = ПолеВыбора.Значение;
	ПолеВыбора.СписокВыбора = Список;
	Если НЕ ЗначениеНеЗаполнено(ПрошлоеЗначение) Тогда
		Если  Список.НайтиПоЗначению(ПрошлоеЗначение) <> Неопределено Тогда
			Если НЕ ПолеВыбора.Значение = ПрошлоеЗначение Тогда
				ПолеВыбора.Значение = ПрошлоеЗначение;
			КонецЕсли;
		Иначе
			ПолеВыбора.Значение = Неопределено;
		КонецЕсли;
	КонецЕсли; 
	
КонецПроцедуры // УстановитьСписокПоляВыбора()

// Процедура установки типа и доступности субконто в зависимости от  выбранного счета
////
Процедура ПриВыбореСчетаВТабличномПоле(Счет, Субконто1, ЭлементДиалогаСубконто1, Субконто2, ЭлементДиалогаСубконто2, Субконто3, ЭлементДиалогаСубконто3, ЭлементДиалогаСчет = НЕОПРЕДЕЛЕНО, ТолькоПросмотр = ЛОЖЬ,ЧислоАктивныхСубконто=0, Субконто4=Неопределено, ЭлементДиалогаСубконто4=Неопределено) Экспорт
	
	ЭлементыСубконто = Новый Структура("Субконто1,ЭлементДиалогаСубконто1,Субконто2,ЭлементДиалогаСубконто2,Субконто3,ЭлементДиалогаСубконто3,Субконто4,ЭлементДиалогаСубконто4", Субконто1, ЭлементДиалогаСубконто1, Субконто2, ЭлементДиалогаСубконто2, Субконто3, ЭлементДиалогаСубконто3, Субконто4, ЭлементДиалогаСубконто4);
	
	Если ЧислоАктивныхСубконто=0 Тогда
		ЧислоАктивныхСубконто = Счет.ВидыСубконто.Количество();
	КонецЕсли; 
	
	ЧислоАктивныхСубконто = Мин(ЧислоАктивныхСубконто,4);
	
	
	Для Сч = 1 По ЧислоАктивныхСубконто Цикл
		
		Если ЭлементыСубконто["ЭлементДиалогаСубконто" + Сч]=Неопределено Тогда
			Продолжить;
		КонецЕсли; 
		
		ТипСубк = Счет.ВидыСубконто[Сч - 1].ВидСубконто.ТипЗначения;
		
		ЭлементыСубконто["ЭлементДиалогаСубконто" + Сч].ТолькоПросмотр = ТолькоПросмотр;
		
		Если ТипЗнч(ЭлементыСубконто["ЭлементДиалогаСубконто" + Сч]) = Тип("ПолеВвода") Тогда
			ЭлементыСубконто["ЭлементДиалогаСубконто" + Сч].ВыбиратьТип = (ТипСубк.Типы().Количество() > 1);
		Иначе
			ЭлементыСубконто["ЭлементДиалогаСубконто" + Сч].ЭлементУправления.ВыбиратьТип = (ТипСубк.Типы().Количество() > 1);
		КонецЕсли; 
			
		// Чтобы не устанавливался флаг модифицированности при открытии формы
		Если ТипСубк.ПривестиЗначение(ЭлементыСубконто["Субконто" + Сч]) <> ЭлементыСубконто["Субконто" + Сч] Тогда
			ЭлементыСубконто["Субконто" + Сч] = ТипСубк.ПривестиЗначение(ЭлементыСубконто["Субконто" + Сч]);
		КонецЕсли;
		
	КонецЦикла;
	
	//Для Сч = (ЧислоАктивныхСубконто + 1) По 4 Цикл
	Для Сч = (ЧислоАктивныхСубконто + 1) По ?(Субконто4 = Неопределено , 3, 4) Цикл
			
		Если Не ЭлементыСубконто["Субконто" + Сч] = Неопределено Тогда
			ЭлементыСубконто["Субконто" + Сч] = Неопределено;
		КонецЕсли;
		
		ЭлементыСубконто["ЭлементДиалогаСубконто" + Сч].ТолькоПросмотр = Истина;
		
	КонецЦикла;
	
	Если ЭлементДиалогаСчет <> Неопределено Тогда
		ЭлементДиалогаСчет.ТолькоПросмотр = ТолькоПросмотр;
	КонецЕсли;

	Если Не Субконто1 = ЭлементыСубконто.Субконто1 Тогда
		Субконто1 = ЭлементыСубконто.Субконто1;
	КонецЕсли;
	Если Не Субконто2 = ЭлементыСубконто.Субконто2 Тогда
		Субконто2 = ЭлементыСубконто.Субконто2;
	КонецЕсли;
	Если Не Субконто3 = ЭлементыСубконто.Субконто3 Тогда
		Субконто3 = ЭлементыСубконто.Субконто3;
	КонецЕсли;
	Если Не Субконто4 = ЭлементыСубконто.Субконто4 Тогда
		Субконто4 = ЭлементыСубконто.Субконто4;
	КонецЕсли;
	
КонецПроцедуры // ПриВыбореСчета()

// Процедура установки типа и доступности субконто в зависимости от  выбранного счета
////
Процедура ПриВыбореСчетаВТабличномПолеДля4Субконто(Счет, Субконто1, ЭлементДиалогаСубконто1, Субконто2, ЭлементДиалогаСубконто2, Субконто3, ЭлементДиалогаСубконто3, Субконто4, ЭлементДиалогаСубконто4, ЭлементДиалогаСчет = НЕОПРЕДЕЛЕНО, ТолькоПросмотр = ЛОЖЬ,ЧислоАктивныхСубконто=0) Экспорт
	
	ЭлементыСубконто = Новый Структура("Субконто1,ЭлементДиалогаСубконто1,Субконто2,ЭлементДиалогаСубконто2,Субконто3,ЭлементДиалогаСубконто3,Субконто4,ЭлементДиалогаСубконто4", Субконто1, ЭлементДиалогаСубконто1, Субконто2, ЭлементДиалогаСубконто2, Субконто3, ЭлементДиалогаСубконто3, Субконто4, ЭлементДиалогаСубконто4);
	
	Если ЧислоАктивныхСубконто=0 Тогда
		ЧислоАктивныхСубконто = Счет.ВидыСубконто.Количество();
	КонецЕсли; 
	
	ЧислоАктивныхСубконто = Мин(ЧислоАктивныхСубконто,4);
	
	
	Для Сч = 1 По ЧислоАктивныхСубконто Цикл
		ТипСубк = Счет.ВидыСубконто[Сч - 1].ВидСубконто.ТипЗначения;
		
		ЭлементыСубконто["ЭлементДиалогаСубконто" + Сч].ТолькоПросмотр = ТолькоПросмотр;
		
		Если ТипЗнч(ЭлементыСубконто["ЭлементДиалогаСубконто" + Сч]) = Тип("ПолеВвода") Тогда
			ЭлементыСубконто["ЭлементДиалогаСубконто" + Сч].ВыбиратьТип = (ТипСубк.Типы().Количество() > 1);
		Иначе
			ЭлементыСубконто["ЭлементДиалогаСубконто" + Сч].ЭлементУправления.ВыбиратьТип = (ТипСубк.Типы().Количество() > 1);
		КонецЕсли; 
			
		// Чтобы не устанавливался флаг модифицированности при открытии формы
		Если ТипСубк.ПривестиЗначение(ЭлементыСубконто["Субконто" + Сч]) <> ЭлементыСубконто["Субконто" + Сч] Тогда
			ЭлементыСубконто["Субконто" + Сч] = ТипСубк.ПривестиЗначение(ЭлементыСубконто["Субконто" + Сч]);
		КонецЕсли;
		
	КонецЦикла;
	
	Для Сч = (ЧислоАктивныхСубконто + 1) По 4 Цикл
			
		Если Не ЭлементыСубконто["Субконто" + Сч] = Неопределено Тогда
			ЭлементыСубконто["Субконто" + Сч] = Неопределено;
		КонецЕсли;
		
		ЭлементыСубконто["ЭлементДиалогаСубконто" + Сч].ТолькоПросмотр = Истина;
		
	КонецЦикла;
	
	Если ЭлементДиалогаСчет <> Неопределено Тогда
		ЭлементДиалогаСчет.ТолькоПросмотр = ТолькоПросмотр;
	КонецЕсли;

	Если Не Субконто1 = ЭлементыСубконто.Субконто1 Тогда
		Субконто1 = ЭлементыСубконто.Субконто1;
	КонецЕсли;
	
	Если Не Субконто2 = ЭлементыСубконто.Субконто2 Тогда
		Субконто2 = ЭлементыСубконто.Субконто2;
	КонецЕсли;
	
	Если Не Субконто3 = ЭлементыСубконто.Субконто3 Тогда
		Субконто3 = ЭлементыСубконто.Субконто3;
	КонецЕсли;
	
	Если Не Субконто4 = ЭлементыСубконто.Субконто4 Тогда
		Субконто4 = ЭлементыСубконто.Субконто4;
	КонецЕсли;
	
КонецПроцедуры // ПриВыбореСчета()

// Процедура выводит форму структуры подчиненности документа
Процедура ПоказатьСтруктуруПодчиненностиДокумента(ДокументСсылка) Экспорт
	
	ФормаСтруктурыПодчиненности = ПолучитьОбщуюФорму("ФормаСтруктурыПодчиненности");
	Если ФормаСтруктурыПодчиненности.Открыта() Тогда
		ФормаСтруктурыПодчиненности.Закрыть();
	КонецЕсли;
	ФормаСтруктурыПодчиненности.ДокументСсылка = ДокументСсылка;
	ФормаСтруктурыПодчиненности.Открыть();
	 
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ РАБОТЫ С МНОГОФИРМЕННЫМ И ОДНОФИРМЕННЫМ УЧЕТОМ

// Процедура устанавливает отбор по основной организации в указанно форме
//
Процедура УстановитьОтборПоОрганизации(Форма, УчетПоВсемОрганизациям, ОсновнаяОрганизация, ИмяРеквизитаСписка, СкрыватьКолонку = Истина, ИмяОтбора = "Организация") Экспорт

	// В том случае если учте ведется по одной организации необходимо установить мягкий отбор.
	// т.е. отбор, с возможностью его изменения.

	Если НЕ УчетПоВсемОрганизациям Тогда // Установлен режим учета по одной организации

		Если НЕ (ТипЗнч(Форма[ИмяРеквизитаСписка]) = Тип("ТаблицаЗначений")) Тогда // Элемент - табличное поле

			// Проверим - Если это связанный регитср сведений тогда не нужно устанавливать отбор - 
			// он уже установлен системой автоматически

			Если ИмяРеквизитаСписка = "РегистрСведенийСписок" Тогда

				// Возвможно это переход по кнопке ПЕрейти
				Если ТипЗнч(Форма.ПараметрОтборПоИзмерению) = Тип("Структура") Тогда
					Если НЕ ЗначениеНеЗаполнено(Форма.ПараметрОтборПоИзмерению) Тогда
						Возврат; // Это переход по кнопке Перейти - не нужно устанавливать отбор
					КонецЕсли;
				КонецЕсли;

			КонецЕсли;

			Форма[ИмяРеквизитаСписка].Отбор[ИмяОтбора].ВидСравнения  = ВидСравнения.Равно;
			Форма[ИмяРеквизитаСписка].Отбор[ИмяОтбора].Использование = Истина;
			Форма[ИмяРеквизитаСписка].Отбор[ИмяОтбора].Значение      = ОсновнаяОрганизация;

			Форма.ЭлементыФормы[ИмяРеквизитаСписка].НастройкаОтбора[ИмяОтбора].Доступность = Ложь;

		КонецЕсли;

		Если СкрыватьКолонку Тогда

			Если НЕ Форма.ЭлементыФормы[ИмяРеквизитаСписка].Колонки.Найти(ИмяОтбора) = Неопределено Тогда

				Форма.ЭлементыФормы[ИмяРеквизитаСписка].Колонки[ИмяОтбора].Видимость         = Ложь;
				Форма.ЭлементыФормы[ИмяРеквизитаСписка].Колонки[ИмяОтбора].ИзменятьВидимость = Ложь;

			КонецЕсли;

		КонецЕсли;

	КонецЕсли;

КонецПроцедуры // УстановитьОтборПоОрганизации()

Процедура УстановитьОтборПоОтветственномуВСпискеДокументов(Форма,Пользователь,ИмяРеквизитаСписка="ДокументСписок") экспорт
	
	ДоступНаПросмотрБезОтбора=ложь;
	
	Если РольДоступна(Метаданные.Роли.ПолныеПрава)
	или РольДоступна(Метаданные.Роли.ГлавныйБухгалтер)
	или РольДоступна(Метаданные.Роли.ПолныйПросмотр)
	или РольДоступна(Метаданные.Роли.ПросмотрДокументовДругихПользователейССписках) Тогда
		ДоступНаПросмотрБезОтбора=Истина;
	КонецЕсли;
		
		
	Если не ДоступНаПросмотрБезОтбора Тогда
		Форма.ЭлементыФормы[ИмяРеквизитаСписка].НастройкаОтбора.Ответственный.Доступность = Ложь;
		Форма[ИмяРеквизитаСписка].Отбор.Ответственный.Значение=Пользователь;
		Форма[ИмяРеквизитаСписка].Отбор.Ответственный.Использование=истина;
	Иначе
		Форма.ЭлементыФормы[ИмяРеквизитаСписка].НастройкаОтбора.Ответственный.Доступность = Истина;
		Форма[ИмяРеквизитаСписка].Отбор.Ответственный.Использование=Ложь;
	КонецЕсли;
	
КонецПроцедуры	
	


// Проверяет, ведется или нет на счете партионный учет
//
Функция ПроверитьВедениеПартионногоУчета(Владелец, НовоеЗначение, ПланСчетов, ЗапрашиватьИзменения = Истина) Экспорт

	Если НовоеЗначение = Перечисления.СпособыОценки.ПоСредней Тогда
		Возврат Истина;
	КонецЕсли;

	НУ = ПланыСчетов[ПланСчетов].А10_10.ПолучитьОбъект();

	// Бухгалтерский учет
	ПартионныйУчет = ?(НУ.ВидыСубконто.Найти(ПланыВидовХарактеристик.ВидыСубконтоХозрасчетные.Партии, "ВидСубконто") = Неопределено, Ложь, Истина);

	Если НЕ ПартионныйУчет И ЗапрашиватьИзменения Тогда
		Ответ = Вопрос("Данный способ оценки может быть установлен если по счетам учета МПЗ установлено ведение партионного учета. 
		               |Открыть обработку, устанавливающую ведение партионного учета?", РежимДиалогаВопрос.ДаНет, , КодВозвратаДиалога.Да, "");

		Если Ответ = КодВозвратаДиалога.Нет Тогда
			Возврат Ложь;
		КонецЕсли;

		ФормаНастройки = ПолучитьОбщуюФорму("НастройкаПараметровУчета");
		ФормаНастройки.ЭлементыФормы.ПанельНастроек.ТекущаяСтраница     = ФормаНастройки.ЭлементыФормы.ПанельНастроек.Страницы.УчетМПЗ;
		Если ФормаНастройки.Открыта() Тогда
			ФормаНастройки.Активизировать();
		Иначе
			ФормаНастройки.ЭлементыФормы.ПанельНастроек.ОтображениеЗакладок = ОтображениеЗакладок.НеИспользовать;
			ФормаНастройки.ОткрытьМодально();
		Конецесли;

		НУ = ПланыСчетов[ПланСчетов].А10_10.ПолучитьОбъект();
		ПартионныйУчет = ?(НУ.ВидыСубконто.Найти(ПланыВидовХарактеристик.ВидыСубконтоХозрасчетные.Партии, "ВидСубконто") = Неопределено, Ложь, Истина);

		Возврат ПартионныйУчет;

	КонецЕсли;

	Возврат ПартионныйУчет;

КонецФункции // ПроверитьВедениеПартионногоУчета()

// Функция проверяет возможность использования счета в проводках.
//
// Параметры:
//  Счет     - Проверяемый счет.
//  Сообщать - признак вывода сообщений.
//
// Возвращаемое значение:
//  Булево - возможность использования счета в проводках
//  
//
Функция СчетМожноИспользоватьВПроводках(Счет, Сообщать = Истина) Экспорт

	Если ТипЗнч(Счет) <> Тип("ПланСчетовСсылка.Хозрасчетный") Тогда
		Возврат Ложь; // Неправильный тип
	КонецЕсли;

	Если ТипЗнч(Счет) = Тип("ПланСчетовСсылка.Хозрасчетный") Тогда
		Если Счет = ПланыСчетов.Хозрасчетный.ПустаяСсылка() Тогда
			Возврат Истина; // Пустая ссылка может использоваться
		КонецЕсли;
		
		Если ЭтоСчетГруппа(Счет.Ссылка) Тогда
			
			Если Сообщать Тогда
				Предупреждение("Счет " + СокрЛП(Счет)+" """ + Счет.Наименование + """ нельзя использовать в проводках.");
			КонецЕсли;
			
			Возврат Ложь; // Счет использовать в проводках нельзя
			
		КонецЕсли;
	КонецЕсли;
	

	Возврат Истина; // Счет можно использовать в проводках 

КонецФункции // СчетМожноИспользоватьВПроводках()

////////////////////////////////////////////////////////////////////////////////
// ФУНКЦИИ ОБЕСПЕЧЕНИЯ РАБОТЫ ФОРМ ДОКУМЕНТОВ С ИМУЩЕСТВОМ В ЭКСПЛУАТАЦИИ

// Функция возвращает расшифровку срока полезного использования в годах и 
// месяцах.
//
// Параметры:
//  СрокПолезногоИспользования - срок полезного использования (в месяцах),
//                 подлежащий расшифровке
//
// Возвращаемое значение:
//  Строка       - расшифровка срока полезного использования в годах и 
//                 месяцах
//
Функция РасшифровкаСрокаПолезногоИспользования(СрокПолезногоИспользования) Экспорт
	
	РасшифровкаСрокаПолезногоИспользования = "";
	
	Если НЕ ЗначениеНеЗаполнено(СрокПолезногоИспользования) Тогда
	
		ЧислоЛет     = Цел(СрокПолезногоИспользования / 12);
		ЧислоМесяцев = (СрокПолезногоИспользования % 12);
		
		Если НЕ (ЧислоЛет = 0) Тогда
			
			// Построим строку с числом лет
			Если (СтрДлина(ЧислоЛет) > 1) И (Число(Сред(ЧислоЛет, СтрДлина(ЧислоЛет) - 1, 1)) = 1) Тогда
				СтрокаГод = " лет";
			ИначеЕсли Число(Прав(ЧислоЛет, 1)) = 1 Тогда
				СтрокаГод = " год";
			ИначеЕсли (Число(Прав(ЧислоЛет, 1)) > 1) И (Число(Прав(ЧислоЛет, 1)) < 5) Тогда
				СтрокаГод = " года";
			Иначе
				СтрокаГод = " лет";
			КонецЕсли;
			
			РасшифровкаСрокаПолезногоИспользования = РасшифровкаСрокаПолезногоИспользования + Строка(ЧислоЛет) + СтрокаГод;
			
		КонецЕсли;
		
		Если НЕ (ЧислоМесяцев = 0) Тогда
			
			// Построим строку с числом месяцев
			Если (СтрДлина(ЧислоМесяцев) > 1) И (Число(Сред(ЧислоМесяцев, СтрДлина(ЧислоМесяцев) - 1, 1)) = 1) Тогда
				СтрокаМесяц = " месяцев";
			ИначеЕсли Число(Прав(ЧислоМесяцев, 1)) = 1 Тогда
				СтрокаМесяц = " месяц";
			ИначеЕсли (Число(Прав(ЧислоМесяцев, 1)) > 1) И (Число(Прав(ЧислоМесяцев, 1)) < 5) Тогда
				СтрокаМесяц = " месяца";
			Иначе
				СтрокаМесяц = " месяцев";
			КонецЕсли;
			
			РасшифровкаСрокаПолезногоИспользования = РасшифровкаСрокаПолезногоИспользования + ?(ЗначениеНеЗаполнено(РасшифровкаСрокаПолезногоИспользования), "", " ") + Строка(ЧислоМесяцев) + СтрокаМесяц;
		
		КонецЕсли;
		
		РасшифровкаСрокаПолезногоИспользования = "(" + РасшифровкаСрокаПолезногоИспользования + ")";
		
	КонецЕсли;
	
	Возврат РасшифровкаСрокаПолезногоИспользования;
	                                        	
КонецФункции // РасшифровкаСрокаПолезногоИспользования()


// Формирует текст про счет-фактуру для показа в форме документа
//
// Параметры: 
//  СчетФактура - ссылка на документ, определяет счет-фактуру, про который надо получить текстовую строку .
//
// Возвращаемое значение:
//  Текстовая строка про счет-фактуру.
//
Функция ПолучитьТекстСчетаФактуры(СчетФактура) Экспорт

	Если ЗначениеНеЗаполнено(СчетФактура) Тогда
		Возврат "Ввести счет-фактуру";

	Иначе
		Возврат Строка(СчетФактура);

	КонецЕсли;

КонецФункции // ПолучитьТекстСчетаФактуры()

// Выполняет общие для всех документов действия при нажатии на гиперссылку на Счет-фактуру
//
// Параметры:
//  ДокументОбъект  - объект документа, 
//  ФормаДокумента  - форма документа.
//  ВидСчетаФактуры - строка, вид счета-фактуры, по умолчанию "СчетФактураВыданный"
//
Процедура ВвестиСчетФактуру(ДокументОбъект, ФормаДокумента, ВидСчетаФактуры = "СчетФактураВыданный", РазрешитьВыборСФнаАванс = Истина) Экспорт

	Если (Не ДокументОбъект.Проведен) и (Не ДокументОбъект.ПометкаУдаления) Тогда

		Ответ = Вопрос("Счет-фактуру нельзя вводить на основании не проведенного документа! Провести документ?", РежимДиалогаВопрос.ДаНет);

		Если Ответ = КодВозвратаДиалога.Да Тогда

			Попытка
				// выполняем проведение документа
				ДокументОбъект.Записать(РежимЗаписиДокумента.Проведение);
				Если ЕстьРеквизитДокумента("ВидОперации", ДокументОбъект.Метаданные()) Тогда
					УстановитьЗаголовокФормыДокумента(Строка(ДокументОбъект.ВидОперации), ДокументОбъект, ФормаДокумента);
				Иначе
					УстановитьЗаголовокФормыДокумента(, ДокументОбъект, ФормаДокумента);
				КонецЕсли;
			Исключение
				Возврат;
			КонецПопытки;

		Иначе
			Возврат;
		КонецЕсли;

	КонецЕсли;

	//Попытаемся найти счет-фактуру
	СчетФактура = НайтиПодчиненныйДокумент(ДокументОбъект.Ссылка, ВидСчетаФактуры, РазрешитьВыборСФнаАванс);

	ОбъектСчетаФактуры = Неопределено;

	//Если потерпели неудачу, то необходимо ввести новый документ 
	Если (ЗначениеНеЗаполнено(СчетФактура))
	   И (Не ДокументОбъект.ПометкаУдаления) Тогда
		//Вводим новый документ на основании нашего
		Если ДокументОбъект.Модифицированность() Тогда
			Предупреждение("Документ был изменен! Сначала следует записать документ!");
			Возврат;
		КонецЕсли;

		ОбъектСчетаФактуры = Документы[ВидСчетаФактуры].СоздатьДокумент();
		ОбъектСчетаФактуры.Заполнить(ДокументОбъект); 

	ИначеЕсли Не ЗначениеНеЗаполнено(СчетФактура) Тогда
		ОбъектСчетаФактуры = СчетФактура.ПолучитьОбъект();

	Иначе
		Предупреждение("На основании документов, помеченных на удаление, ввод счетов-фактур не предусмотрен.");

	КонецЕсли;

	Если ОбъектСчетаФактуры <> Неопределено Тогда
		// Откроем форму для редактирования счета-фактуры
		ОбъектСчетаФактуры.ПолучитьФорму( , ФормаДокумента, Строка(ДокументОбъект)).Открыть();

	КонецЕсли;

КонецПроцедуры // ВвестиСчетФактуру()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ОБРАБОТКИ ПОДБОРА В ТОРГОВЫЕ ДОКУМЕНТЫ

// Универсальная процедура, которая инициирует механизм подбора
// номенклатуры в документы (открывает основную форму обработки подбор).
//
// Параметры:
//  ФормаДокумента - форма документа, в который осуществляется подбор,
//  СтруктураПараметров - параметры, которые передаются в форму подбора.
//
Процедура ОткрытьПодборНоменклатуры(ФормаДокумента, СтруктураПараметров, ФормаПодбора = Неопределено) Экспорт

	// Добавляем обработчики в форму
	//МетаданныеДокумента = ФормаДокумента.ДокументОбъект.Метаданные();
	МетаданныеДокумента = ФормаДокумента.ЭтотОбъект.Метаданные();
	Для Каждого ЭлементСтруктурыПараметров Из СтруктураПараметров Цикл
		Если ЕстьРеквизитДокумента(ЭлементСтруктурыПараметров.Ключ, МетаданныеДокумента) Тогда
			ФормаДокумента.ПодключитьОбработчикИзмененияДанных(ЭлементСтруктурыПараметров.Ключ, "ОбновитьФормуПодбора", Ложь);
		КонецЕсли;
	КонецЦикла;
	
	// Открываем форму подбора.
	ФормаПодбора = Обработки.ПодборНоменклатуры.ПолучитьФорму("ОсновнаяФорма", ФормаДокумента, ФормаДокумента);
	ФормаПодбора.ОбработкаОбъект.СтруктураИсходныхПараметров = СтруктураПараметров;
	ФормаПодбора.Открыть();

КонецПроцедуры // ОткрытьПодборНоменклатуры()

// Универсальная процедура, которая инициирует механизм подбора
// номенклатуры в документы (открывает основную форму обработки подбор).
//
// Параметры:
//  ФормаДокумента - форма документа, в который осуществляется подбор,
//  СтруктураПараметров - параметры, которые передаются в форму подбора.
//
Процедура ОткрытьПодборНоменклатурыПродаж(ФормаДокумента, СтруктураПараметров, ФормаПодбора = Неопределено) Экспорт

	// Добавляем обработчики в форму
	//МетаданныеДокумента = ФормаДокумента.ДокументОбъект.Метаданные();
	МетаданныеДокумента = ФормаДокумента.ЭтотОбъект.Метаданные();
	Для Каждого ЭлементСтруктурыПараметров Из СтруктураПараметров Цикл
		Если ЕстьРеквизитДокумента(ЭлементСтруктурыПараметров.Ключ, МетаданныеДокумента) Тогда
			ФормаДокумента.ПодключитьОбработчикИзмененияДанных(ЭлементСтруктурыПараметров.Ключ, "ОбновитьФормуПодбора", Ложь);
		КонецЕсли;
	КонецЦикла;
	
	// Открываем форму подбора.
	ФормаПодбора = Обработки.ПодборНоменклатурыПродаж.ПолучитьФорму("ОсновнаяФорма", ФормаДокумента, ФормаДокумента);
	ФормаПодбора.ОбработкаОбъект.СтруктураИсходныхПараметров = СтруктураПараметров;
	ФормаПодбора.Открыть();

КонецПроцедуры // ОткрытьПодборНоменклатуры()

// Процедура, которая обновляет параметры подбора номенклатуры и
// инициирует обновление формы подбора, если она открыта
//
// Параметры:
//  ДокументОбъект           - объект документа, в котором производится подбор.
//  ФормаПодбораНоменклатуры - форма подбора номенклатуры,
//  ПолноеИмяРеквизита       - полное имя реквизита, который изменился.
//
Процедура ОбновитьПараметрыИФормуПодбора(ДокументОбъект, ФормаПодбораНоменклатуры, ПолноеИмяРеквизита) Экспорт

	Если ФормаПодбораНоменклатуры.Открыта() Тогда

		ИмяРеквизита = СтрЗаменить(ПолноеИмяРеквизита, "ДокументОбъект.", "");

		Если ФормаПодбораНоменклатуры.ОбработкаОбъект.СтруктураИсходныхПараметров.Свойство(ИмяРеквизита) Тогда

			ФормаПодбораНоменклатуры.ОбработкаОбъект.СтруктураИсходныхПараметров.Вставить(ИмяРеквизита, ДокументОбъект[ИмяРеквизита]);

			Родитель = ФормаПодбораНоменклатуры.ЭлементыФормы.ДеревоНоменклатуры.ТекущаяСтрока;
			//СтруктураЗапроса = ФормаПодбораНоменклатуры.ЭлементыФормы.СписокВидовПодбора.Значение;
			//ФормаПодбораНоменклатуры.ПерезаполнитьТаблицуНоменклатуры(Родитель, СтруктураЗапроса);

		КонецЕсли;

	КонецЕсли;

КонецПроцедуры // ОбновитьПараметрыИФормуПодбора()


// Предназначена для реализации "произвольного" ввода даты-месяца
// подбирает по переданному тексту строку-представление даты или список таких строк
// в переданный параметр ДатаПоТексту возвращает подобранную по тексту дату
Функция ДатаКакМесяцПодобратьДатуПоТексту(Текст, ДатаПоТексту = НеОпределено) ЭКспорт
    СписокВозврата = Новый СписокЗначений;
    ТекущийГод = Год(ТекущаяДата());
    
    Если ПустаяСтрока(Текст) Тогда
        Возврат СписокВозврата;
    КонецЕсли;
    Если Найти(Текст, ".") <> 0 Тогда
        Подстроки = РазложитьСтрокуВМассивПодстрок(Текст, ".");
    ИначеЕсли Найти(Текст, ",") <> 0 Тогда
        Подстроки = РазложитьСтрокуВМассивПодстрок(Текст, ",");
    ИначеЕсли Найти(Текст, "-") <> 0 Тогда
        Подстроки = РазложитьСтрокуВМассивПодстрок(Текст, "-");
    ИначеЕсли Найти(Текст, "/") <> 0 Тогда
        Подстроки = РазложитьСтрокуВМассивПодстрок(Текст, "/");
    ИначеЕсли Найти(Текст, "\") <> 0 Тогда
        Подстроки = РазложитьСтрокуВМассивПодстрок(Текст, "\");
    Иначе
        Подстроки = РазложитьСтрокуВМассивПодстрок(Текст, " ");
    КонецЕсли;
    Если Подстроки.Количество() = 1 Тогда
        // единственное слово - пытаемся получить месяц
        Если ТолькоЦифрыВСтроке(Текст) Тогда
            МесяцЧислом = Число(Текст);
            Если МесяцЧислом >= 1 и МесяцЧислом <=12 Тогда
                ДатаПоТексту = Дата(ТекущийГод, МесяцЧислом, 1);
                Если СтрДлина(Текст) = 1 Тогда
                    СписокВозврата.Добавить(Формат(ДатаПоТексту, "ДФ='М/гг'"));
                Иначе
                    СписокВозврата.Добавить(Формат(ДатаПоТексту, "ДФ='ММ/гг'"));
                КонецЕсли;
            Иначе
                Возврат СписокВозврата;
            КонецЕсли;                
        Иначе
            СписокМесяцев = СписокМесяцевПоСтроке(Текст);
            Для Каждого Месяц Из СписокМесяцев Цикл
                ДатаПоТексту = Дата(ТекущийГод, Месяц, 1);
                СписокВозврата.Добавить(Формат(ДатаПоТексту, "ДФ='ММММ гг'"));
            КонецЦикла;
        КонецЕсли;
    ИначеЕсли Подстроки.Количество() = 2 Тогда
        // два слова - первое считаем месяцем, второе - годом
        Если ТолькоЦифрыВСтроке(Подстроки[1]) Тогда
            Если ПустаяСтрока(Подстроки[1]) Тогда
                ГодЧислом = 0;
                Подстроки[1] = "0";
                ТекстВозврата = Текст + "0";
            Иначе
                ГодЧислом = Число(Подстроки[1]);
                ТекстВозврата = "";
            КонецЕсли;
            Если ГодЧислом > 3000 Тогда
                Возврат СписокВозврата;
            КонецЕсли;
            Если СтрДлина(Подстроки[1]) <= 1 Тогда
                ГодЧислом = Число(Лев(Формат(ТекущийГод, "ЧГ="), 3) + Подстроки[1]);
                СтрокаФорматированияГода = "г";
            ИначеЕсли СтрДлина(Подстроки[1]) = 2 Тогда
                ГодЧислом = Число(Лев(Формат(ТекущийГод, "ЧГ="), 2) + Подстроки[1]);
                СтрокаФорматированияГода = "гг";
            ИначеЕсли СтрДлина(Подстроки[1]) = 3 Тогда
                ГодЧислом = Число(Лев(Формат(ТекущийГод, "ЧГ="), 1) + Подстроки[1]);
                СтрокаФорматированияГода = "гггг";
            КонецЕсли;                    
        Иначе
            // второе слово может быть только годом
            Возврат СписокВозврата;
        КонецЕсли;                
        Если ТолькоЦифрыВСтроке(Подстроки[0]) Тогда
            МесяцЧислом = Число(Подстроки[0]);
            Если МесяцЧислом >= 1 и МесяцЧислом <= 12 Тогда
                // если "правильный" месяц и год
                ДатаПоТексту = Дата(ГодЧислом, МесяцЧислом, 1);
                СписокВозврата.Добавить(ТекстВозврата);
            Иначе
                Возврат СписокВозврата;
            КонецЕсли;                
        Иначе
            СписокМесяцев = СписокМесяцевПоСтроке(Подстроки[0]);
            Если СписокМесяцев.Количество() = 1 Тогда
                ДатаПоТексту = Дата(ГодЧислом, СписокМесяцев[0], 1);
                СписокВозврата.Добавить("");
            Иначе
                Для Каждого Месяц Из СписокМесяцев Цикл
                    ДатаПоТексту = Дата(ГодЧислом, Месяц, 1);
                    СписокВозврата.Добавить(Формат(Дата(ГодЧислом, Месяц, 1), "ДФ='ММММ гг'"));
                КонецЦикла;
            КонецЕсли;
        КонецЕсли;
    КонецЕсли;
    Возврат СписокВозврата;
КонецФункции

// подбирает массив номеров месяцев, соответствующих переданной строке
// например, для строки "ма" это будут 3 и 5, для "а" - 4 и 8
// используется в ПодобратьДатуПоТексту
Функция СписокМесяцевПоСтроке(Текст)
    СписокМесяцев = Новый СписокЗначений;
    Месяцы = Новый Соответствие;
    МесяцыВозврата = Новый Массив;
    Для Счетчик = 1 По 12 Цикл
        Представление = Формат(Дата(2000, Счетчик, 1), "ДФ='ММММ'");
        СписокМесяцев.Добавить(Счетчик, Представление);
        Представление = Формат(Дата(2000, Счетчик, 1), "ДФ='МММ'");
        СписокМесяцев.Добавить(Счетчик, Представление);
    КонецЦикла;
    Для Каждого ЭлементСписка Из СписокМесяцев Цикл
        Если ВРег(Текст) = ВРег(Лев(ЭлементСписка.Представление, СтрДлина(Текст))) Тогда
            Месяцы[ЭлементСписка.Значение] = 0;
        КонецЕсли;
    КонецЦикла;
    Для Каждого Элемент Из Месяцы Цикл
        МесяцыВозврата.Добавить(Элемент.Ключ);
    КонецЦикла;
    Возврат МесяцыВозврата;
КонецФункции

Процедура ДатаКакМесяцАвтоПодборТекста(Текст, ТекстАвтоПодбора, СтандартнаяОбработка) Экспорт
    Список = ДатаКакМесяцПодобратьДатуПоТексту(Текст);
    Если Список.Количество() = 1 Тогда
        ТекстАвтоПодбора = Список[0];
    КонецЕсли;
    СтандартнаяОбработка = Ложь;
КонецПроцедуры

Процедура ДатаКакМесяцОкончаниеВводаТекста(Текст, Значение, СтандартнаяОбработка) Экспорт
    Список = ДатаКакМесяцПодобратьДатуПоТексту(Текст);
    Если Список.Количество() = 1 Тогда
        Значение = Текст;
    Иначе
        Значение = Список;
    КонецЕсли;
    СтандартнаяОбработка = Ложь;
КонецПроцедуры

Функция ДатаКакМесяцПредставление(ДатаДата) Экспорт
    Возврат Формат(ДатаДата, "ДФ='ММММ гггг'");
КонецФункции

// Процедура обрабатывает событие начала выбора из списка в поле периода регистрации
// Процедура исполняется только на клиенте
//
Процедура НачалоВыбораИзСпискаПредставленияПериодаРегистрации(Элемент, СтандартнаяОбработка, ПериодРегистрации, ЭтаФорма, НачальноеЗначение = Неопределено) Экспорт

	СтандартнаяОбработка = Ложь;
	
	Если НачальноеЗначение = Неопределено Тогда
		НачальноеЗначение = ПериодРегистрации;
	КонецЕсли; 
	
	СписокВыбора = Новый СписокЗначений;
	НачалоТекущегоГода = НачалоГода(НачальноеЗначение);
	НачалоПрошлогоГода = НачалоГода(НачалоТекущегоГода - 1);
	СписокВыбора.Добавить(НачалоПрошлогоГода, (Формат(НачалоПрошлогоГода, "ДФ='yyyy'") + "..."));
	НачалоМесяцаЗаполнения = НачалоТекущегоГода;
	ЭлементПоУмолчанию = Неопределено;
	Для а = 1 По 12 Цикл
		ДобавленныйЭлемент = СписокВыбора.Добавить(НачалоМесяцаЗаполнения, ДатаКакМесяцПредставление(НачалоМесяцаЗаполнения));
		Если НачальноеЗначение = НачалоМесяцаЗаполнения Тогда
			ЭлементПоУмолчанию = ДобавленныйЭлемент;
		КонецЕсли; 
		НачалоМесяцаЗаполнения = ДобавитьМесяц(НачалоМесяцаЗаполнения, 1);
	КонецЦикла;
	НачалоСледующегоГода = КонецГода(НачалоТекущегоГода) + 1;
	СписокВыбора.Добавить(НачалоСледующегоГода, (Формат(НачалоСледующегоГода, "ДФ='yyyy'") + "..."));
	
	ВыбранныйЭлемент = ЭтаФорма.ВыбратьИзСписка(СписокВыбора, Элемент, ЭлементПоУмолчанию);
	
	Если ВыбранныйЭлемент = Неопределено Тогда
		Возврат;
	ИначеЕсли Год(ВыбранныйЭлемент.Значение) <> Год(НачальноеЗначение) Тогда
		НачалоВыбораИзСпискаПредставленияПериодаРегистрации(Элемент, СтандартнаяОбработка, ПериодРегистрации, ЭтаФорма, ВыбранныйЭлемент.Значение);
		Возврат;
	КонецЕсли;
	
	ПериодРегистрации = ВыбранныйЭлемент.Значение;
	Элемент.Значение  = ДатаКакМесяцПредставление(ПериодРегистрации);
	
КонецПроцедуры

